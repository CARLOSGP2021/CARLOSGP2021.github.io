<!DOCTYPE html><html lang="zh-CN" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="prefer-datetime-locale" content="Asia/Shanghai"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="一、二叉树" /><meta name="author" content="卡卡成长汇聚阿豹" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="解题方法" /><meta property="og:description" content="解题方法" /><link rel="canonical" href="/posts/%E4%B8%80-%E4%BA%8C%E5%8F%89%E6%A0%91/" /><meta property="og:url" content="/posts/%E4%B8%80-%E4%BA%8C%E5%8F%89%E6%A0%91/" /><meta property="og:site_name" content="卡卡成长汇聚阿豹" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-06-27T02:34:00+00:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="一、二叉树" /><meta name="twitter:site" content="@twitter_username" /><meta name="twitter:creator" content="@卡卡成长汇聚阿豹" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"卡卡成长汇聚阿豹"},"dateModified":"2022-06-27T02:34:00+00:00","datePublished":"2022-06-27T02:34:00+00:00","description":"解题方法","headline":"一、二叉树","mainEntityOfPage":{"@type":"WebPage","@id":"/posts/%E4%B8%80-%E4%BA%8C%E5%8F%89%E6%A0%91/"},"url":"/posts/%E4%B8%80-%E4%BA%8C%E5%8F%89%E6%A0%91/"}</script><title>一、二叉树 | 卡卡成长汇聚阿豹</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="卡卡成长汇聚阿豹"><meta name="application-name" content="卡卡成长汇聚阿豹"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="/assets/config/kaka.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">卡卡成长汇聚阿豹</a></div><div class="site-subtitle font-italic">微信公众号：卡卡成长汇聚</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>首页</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>分类</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>标签</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>归档</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>关于</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/CARLOSGP2021" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/twitter_username" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['example','doamin.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> 首页 </a> </span> <span>一、二叉树</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> 文章</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="搜索..."> </span> <span id="search-cancel" >取消</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>一、二叉树</h1><div class="post-meta text-muted"> <span> 发表于 <em class="" data-ts="1656297240" data-df="YYYY-MM-DD" data-toggle="tooltip" data-placement="bottom"> 2022-06-27 </em> </span><div class="d-flex justify-content-between"> <span> 作者 <em> CARLOSGP2021 </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="23437 字"> <em>130 分钟</em>阅读</span></div></div></div><div class="post-content"><h1 id="解题方法">解题方法</h1><p>1️⃣ 遇到二叉树的题目，如何去思考？或者说有没有思考的框架呢？</p><ul><li><p><strong>是否可以通过遍历一遍二叉树得到答案</strong>？如果可以，用一个 <code class="language-plaintext highlighter-rouge">traverse</code> 函数配合外部变量来实现，这叫「遍历」的思维模式。</p><li><p><strong>是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案</strong>？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值，这叫「<strong>分解问题</strong>」的思维模式。</p></ul><p>无论使用哪种思维模式，你都需要思考：</p><p><strong>如果单独抽出一个二叉树节点，它需要做什么事情？需要在什么时候（前/中/后序位置）做</strong>？其他的节点不用你操心，递归函数会帮你在所有节点上执行相同的操作。</p><p>2️⃣ 如何正确地理解<strong>前中后序遍历</strong>呢？</p><p><strong>前中后序是遍历二叉树过程中处理每一个节点的三个特殊时间点</strong>，绝不仅仅是三个顺序不同的 List：</p><ul><li>前序位置的代码在刚刚进入一个二叉树节点的时候执行；<li>后序位置的代码在将要离开一个二叉树节点的时候执行；<li>中序位置的代码在一个二叉树节点左子树都遍历完，即将开始遍历右子树的时候执行。</ul><div align="center"><img data-src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204170940278.png" alt="image-20220417094016966" style="zoom:50%;" data-proofer-ignore></div><div align="center"><img data-src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204170942506.png" alt="image-20220417094235414" style="zoom:60%;" data-proofer-ignore></div><p>3️⃣前序位置和后序位置的代码有什么区别？后序位置有什么特殊之处？</p><p>前序位置的代码只能从函数参数中获取父节点传递来的数据，而后序位置的代码不仅可以获取参数数据，还可以获取到<strong>子树</strong>通过函数返回值传递回来的数据。</p><p>🔥总结：二叉树的所有问题，就是让你在前中后序位置注入巧妙的代码逻辑，去达到自己的目的，<strong>你只需要单独思考每一个节点应该做什么</strong>，其他的不用你管，抛给二叉树遍历框架，递归会在所有节点上做相同的操作。</p><h1 id="二叉树深度">二叉树深度</h1><h2 id="104求二叉树最大深度"><span class="mr-2">104、求二叉树最大深度</span><a href="#104求二叉树最大深度" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数，叶子节点是指没有子节点的节点。</p><p><strong>示例：</strong> 给定二叉树<code class="language-plaintext highlighter-rouge">[3,9,20,null,null,15,7]</code>，</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>    <span class="mi">3</span>
   <span class="o">/</span> <span class="err">\</span>
  <span class="mi">9</span>  <span class="mi">20</span>
    <span class="o">/</span>  <span class="err">\</span>
   <span class="mi">15</span>   <span class="mi">7</span>
</pre></table></code></div></div><p>返回它的最大深度 3。</p><p><strong>解法一</strong>：递归遍历二叉树，回溯算法思路</p><p>遍历一遍二叉树，用一个外部变量记录<strong>每个节点</strong>所在的深度，取最大值就可以得到最大深度。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">int</span> <span class="n">depth</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">int</span> <span class="nf">maxDepth</span><span class="p">(</span><span class="nc">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">traverse</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">//遍历二叉树</span>
    <span class="n">void</span> <span class="nf">traverse</span><span class="p">(</span><span class="nc">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">){</span>
		<span class="k">if</span><span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="n">nullptr</span><span class="p">){</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">//前序遍历位置</span>
        <span class="n">depth</span><span class="o">++</span><span class="p">;</span>
        <span class="c1">//遍历过程中记录最大深度</span>
        <span class="n">res</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">depth</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
        <span class="nf">traverse</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
        <span class="nf">traverse</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
        <span class="c1">//后序遍历位置</span>
        <span class="n">depth</span><span class="o">--</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><p><strong>解法二</strong>：分解成子树问题，动态规划思路</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="c1">// 定义：输入一个节点，返回以该节点为根的二叉树的最大深度</span>
    <span class="n">int</span> <span class="nf">maxDepth</span><span class="p">(</span><span class="nc">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span><span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="n">nullptr</span><span class="p">){</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">int</span> <span class="n">leftDepth</span> <span class="o">=</span> <span class="nf">maxDepth</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
        <span class="n">int</span> <span class="n">rightDepth</span> <span class="o">=</span> <span class="nf">maxDepth</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
        <span class="c1">// 根据左右子树的最大深度推出原二叉树的最大深度</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">leftDepth</span><span class="p">,</span> <span class="n">rightDepth</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><p><strong>解法三</strong>：层序遍历</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">int</span> <span class="nf">maxDepth</span><span class="p">(</span><span class="nc">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">int</span> <span class="n">depth</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">queue</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">*&gt;</span> <span class="n">que</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">root</span><span class="p">)</span> <span class="n">que</span><span class="mf">.</span><span class="nf">push</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
        <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">que</span><span class="mf">.</span><span class="nb">empty</span><span class="p">()){</span>
            <span class="n">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">que</span><span class="mf">.</span><span class="nf">size</span><span class="p">();</span>
            <span class="n">depth</span><span class="o">++</span><span class="p">;</span>
            <span class="k">for</span><span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
                <span class="nc">TreeNode</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">que</span><span class="mf">.</span><span class="nf">front</span><span class="p">();</span>
                <span class="n">que</span><span class="mf">.</span><span class="nf">pop</span><span class="p">();</span>
                <span class="k">if</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="n">que</span><span class="mf">.</span><span class="nf">push</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
                <span class="k">if</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span> <span class="n">que</span><span class="mf">.</span><span class="nf">push</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">depth</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><p>求二叉树的最大深度可以延伸到求二叉树的直径：</p><h2 id="543二叉树直径"><span class="mr-2">543、二叉树直径</span><a href="#543二叉树直径" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p><p><strong>示例 :</strong> 给定二叉树</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>          <span class="mi">1</span>
         <span class="o">/</span> <span class="err">\</span>
        <span class="mi">2</span>   <span class="mi">3</span>
       <span class="o">/</span> <span class="err">\</span>     
      <span class="mi">4</span>   <span class="mi">5</span>    
</pre></table></code></div></div><p>返回 <strong>3</strong>, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。</p><p>每一条二叉树的「<strong>直径</strong>」长度，就是一个节点的左右子树的<strong>最大深度之和</strong>。把计算「直径」的逻辑放在<strong>后序位置</strong>，准确说应该是放在 <code class="language-plaintext highlighter-rouge">maxDepth</code> 的后序位置，因为 <code class="language-plaintext highlighter-rouge">maxDepth</code> 的后序位置是知道左右子树的最大深度的。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">int</span> <span class="n">maxDiameter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">int</span> <span class="nf">diameterOfBinaryTree</span><span class="p">(</span><span class="nc">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
		<span class="nf">maxDepth</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">maxDiameter</span><span class="p">;</span>       
    <span class="p">}</span>
    
    <span class="c1">//定义：输入一个节点，返回以该节点为根节点的二叉树的深度</span>
    <span class="n">int</span> <span class="nf">maxDepth</span><span class="p">(</span><span class="nc">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">){</span>
		<span class="k">if</span><span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="n">nullptr</span><span class="p">){</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">int</span> <span class="n">leftDepth</span> <span class="o">=</span> <span class="nf">maxDepth</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
        <span class="n">int</span> <span class="n">rightDepth</span> <span class="o">=</span> <span class="nf">maxDepth</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
        <span class="c1">// 后序位置，顺便计算最大直径</span>
        <span class="n">maxDiameter</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">leftDepth</span> <span class="o">+</span> <span class="n">rightDepth</span><span class="p">,</span> <span class="n">maxDiameter</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">leftDepth</span><span class="p">,</span> <span class="n">rightDepth</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h2 id="111二叉树的最小深度"><span class="mr-2">111、二叉树的最小深度</span><a href="#111二叉树的最小深度" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>给定一个二叉树，找出其最小深度。最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p><p><strong>示例</strong>：给定二叉树<code class="language-plaintext highlighter-rouge">[3，9，20，null，null，15，7]</code>：</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>      <span class="mi">3</span>
     <span class="o">/</span> <span class="err">\</span>
    <span class="mi">9</span>  <span class="mi">20</span>
       <span class="o">/</span> <span class="err">\</span>     
      <span class="mi">15</span>  <span class="mi">7</span>    
</pre></table></code></div></div><p>返回它的最小深度2。</p><p><strong>解法一</strong>：分解成子树问题，动态规划思想</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="c1">//定义：输入一个节点，返回以该节点为根节点的二叉树的最小深度</span>
    <span class="n">int</span> <span class="nf">minDepth</span><span class="p">(</span><span class="nc">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">int</span> <span class="n">leftDepth</span> <span class="o">=</span> <span class="nf">minDepth</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
        <span class="n">int</span> <span class="n">rightDepth</span> <span class="o">=</span> <span class="nf">minDepth</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">leftDepth</span><span class="p">,</span> <span class="n">rightDepth</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>        
    <span class="p">}</span>    
<span class="p">};</span>
</pre></table></code></div></div><p>❓<strong>上面的算法对吗？为什么？</strong></p><p>❎错误！这个代码就犯了此图中的误区：</p><div align="center"><img data-src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204171128504.png" alt="111.二叉树的最小深度" style="zoom:50%;" data-proofer-ignore></div><p>如果这么求的话，<strong>没有左孩子的分支会算为最短深度</strong>。</p><p>所以，如果左子树为空，右子树不为空，说明最小深度是 1 + 右子树的深度；</p><p>反之，右子树为空，左子树不为空，最小深度是 1 + 左子树的深度；</p><p>最后如果左右子树都不为空，返回左右子树深度最小值 + 1 。</p><p>✅<strong>正确的解法一</strong>：分解成子树问题，动态规划思想</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">int</span> <span class="nf">minDepth</span><span class="p">(</span><span class="nc">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">){</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">int</span> <span class="n">leftDepth</span> <span class="o">=</span> <span class="nf">minDepth</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
        <span class="n">int</span> <span class="n">rightDepth</span> <span class="o">=</span> <span class="nf">minDepth</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">){</span>
            <span class="k">return</span> <span class="n">rightDepth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">){</span>
            <span class="k">return</span> <span class="n">leftDepth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">leftDepth</span><span class="p">,</span> <span class="n">rightDepth</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><p><strong>解法二</strong>：层序遍历</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">int</span> <span class="nf">minDepth</span><span class="p">(</span><span class="nc">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">int</span> <span class="n">depth</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">queue</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">*&gt;</span> <span class="n">que</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">root</span><span class="p">)</span> <span class="n">que</span><span class="mf">.</span><span class="nf">push</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
        <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">que</span><span class="mf">.</span><span class="nb">empty</span><span class="p">()){</span>
            <span class="n">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">que</span><span class="mf">.</span><span class="nf">size</span><span class="p">();</span>
            <span class="n">depth</span><span class="o">++</span><span class="p">;</span>
            <span class="k">for</span><span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
                <span class="nc">TreeNode</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">que</span><span class="mf">.</span><span class="nf">front</span><span class="p">();</span>
                <span class="n">que</span><span class="mf">.</span><span class="nf">pop</span><span class="p">();</span>
                <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span> <span class="k">return</span> <span class="n">depth</span><span class="p">;</span>
                <span class="k">if</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="n">que</span><span class="mf">.</span><span class="nf">push</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
                <span class="k">if</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span> <span class="n">que</span><span class="mf">.</span><span class="nf">push</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">depth</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h2 id="110平衡二叉树"><span class="mr-2">110、平衡二叉树</span><a href="#110平衡二叉树" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p><p>本题中，一棵高度平衡二叉树定义为：</p><blockquote><p>一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1 。</p></blockquote><p><strong>示例 ：</strong></p><div align="center"><img data-src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204202031331.jpeg" alt="img" style="zoom: 60%;" data-proofer-ignore></div><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">root</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="kc">null</span><span class="p">,</span><span class="kc">null</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span>
<span class="n">输出</span><span class="err">：</span><span class="kc">true</span>
</pre></table></code></div></div><p>本题依然是二叉树深度相关的题目，依然是把计算「高度差」的逻辑放在<strong>后序位置</strong>，准确说应该是放在 <code class="language-plaintext highlighter-rouge">maxDepth</code> 的后序位置，因为 <code class="language-plaintext highlighter-rouge">maxDepth</code> 的后序位置是知道左右子树的最大深度的。</p><p>只计算一次最大深度，计算的过程中在<strong>后序遍历位置</strong>顺便判断二叉树是否平衡：对于每个节点，先算出来左右子树的最大高度，然后在后序遍历的位置根据左右子树的最大高度判断平衡性。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="c1">// 记录二叉树是否平衡</span>
    <span class="n">bool</span> <span class="n">balance</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>

    <span class="n">bool</span> <span class="nf">isBalanced</span><span class="p">(</span><span class="nc">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">maxDepth</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">balance</span><span class="p">;</span>
    <span class="p">}</span>
	<span class="c1">// 定义：输入一个节点，返回以该节点为根的二叉树的最大深度</span>
    <span class="n">int</span> <span class="nf">maxDepth</span><span class="p">(</span><span class="nc">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">int</span> <span class="n">leftDepth</span><span class="o">=</span> <span class="nf">maxDepth</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
        <span class="n">int</span> <span class="n">rightDepth</span> <span class="o">=</span> <span class="nf">maxDepth</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">leftDepth</span> <span class="o">-</span> <span class="n">rightDepth</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="n">balance</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">leftDepth</span><span class="p">,</span> <span class="n">rightDepth</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h1 id="翻转二叉树">翻转二叉树</h1><p><strong>226、翻转二叉树</strong></p><p>给你一棵二叉树的根节点 <code class="language-plaintext highlighter-rouge">root</code> ，翻转这棵二叉树，并返回其根节点。</p><p><strong>示例 1：</strong></p><div align="center"><img data-src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204171844420.jpeg" alt="img" style="zoom:50%;" data-proofer-ignore></div><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">root</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">9</span><span class="p">]</span>
<span class="n">输出</span><span class="err">：</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
</pre></table></code></div></div><p><strong>解法一</strong>：递归遍历，回溯算法的思想</p><p>遍历二叉树的每个节点，每个节点的左、右子树交换位置。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="nc">TreeNode</span><span class="o">*</span> <span class="nf">invertTree</span><span class="p">(</span><span class="nc">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
		<span class="nf">traverse</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 二叉树遍历函数</span>
    <span class="n">void</span> <span class="nf">traverse</span><span class="p">(</span><span class="nc">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">){</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// 每一个节点需要做的事就是交换它的左右子节点</span>
        <span class="nc">TreeNode</span><span class="o">*</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
        <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
        <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
        <span class="c1">// 遍历框架，去遍历左右子树的节点</span>
        <span class="nf">traverse</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
        <span class="nf">traverse</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><p><strong>解法二</strong>：分解为子树的问题，动态规划思想</p><p>用 <code class="language-plaintext highlighter-rouge">invertTree(x.left)</code> 先把 <code class="language-plaintext highlighter-rouge">x</code> 的左子树翻转，再用 <code class="language-plaintext highlighter-rouge">invertTree(x.right)</code> 把 <code class="language-plaintext highlighter-rouge">x</code> 的右子树翻转，最后把 <code class="language-plaintext highlighter-rouge">x</code> 的左右子树交换，这恰好完成了以 <code class="language-plaintext highlighter-rouge">x</code> 为根的整棵二叉树的翻转，即完成了 <code class="language-plaintext highlighter-rouge">invertTree(x)</code> 的定义。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="c1">//定义：输入一个节点，将以该节点为根节点的二叉树进行翻转，返回其根节点</span>
    <span class="nc">TreeNode</span><span class="o">*</span> <span class="nf">invertTree</span><span class="p">(</span><span class="nc">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// 利用函数定义，先翻转左右子树</span>
        <span class="nc">TreeNode</span><span class="o">*</span> <span class="n">left</span> <span class="o">=</span> <span class="nf">invertTree</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
        <span class="nc">TreeNode</span><span class="o">*</span> <span class="n">right</span> <span class="o">=</span> <span class="nf">invertTree</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
        <span class="c1">// 然后交换左右子节点</span>
		<span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">right</span><span class="p">;</span>
        <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
    <span class="p">}</span>    
<span class="p">};</span>
</pre></table></code></div></div><p><strong>解法三</strong>：层序遍历</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="nc">TreeNode</span><span class="o">*</span> <span class="nf">invertTree</span><span class="p">(</span><span class="nc">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
        <span class="n">stack</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">*&gt;</span> <span class="n">st</span><span class="p">;</span>
        <span class="n">st</span><span class="mf">.</span><span class="nf">push</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
        <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">st</span><span class="mf">.</span><span class="nb">empty</span><span class="p">())</span> <span class="p">{</span>
            <span class="nc">TreeNode</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">st</span><span class="mf">.</span><span class="nf">top</span><span class="p">();</span>              <span class="c1">// 中</span>
            <span class="n">st</span><span class="mf">.</span><span class="nf">pop</span><span class="p">();</span>
            <span class="nf">swap</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
            <span class="k">if</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span> <span class="n">st</span><span class="mf">.</span><span class="nf">push</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>   <span class="c1">// 右</span>
            <span class="k">if</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="n">st</span><span class="mf">.</span><span class="nf">push</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>     <span class="c1">// 左</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h1 id="路径总和">路径总和</h1><h2 id="112路径总和"><span class="mr-2">112、路径总和</span><a href="#112路径总和" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>给你二叉树的根节点 <code class="language-plaintext highlighter-rouge">root</code> 和一个表示目标和的整数 <code class="language-plaintext highlighter-rouge">targetSum</code> 。判断该树中是否存在 <strong>根节点到叶子节点</strong> 的路径，这条路径上所有节点值相加等于目标和 <code class="language-plaintext highlighter-rouge">targetSum</code> 。如果存在，返回 <code class="language-plaintext highlighter-rouge">true</code> ；否则，返回 <code class="language-plaintext highlighter-rouge">false</code> 。</p><p><strong>示例：</strong></p><div align="center"><img data-src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204221122861.jpeg" alt="img" style="zoom:50%;" data-proofer-ignore></div><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">root</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="kc">null</span><span class="p">,</span><span class="mi">13</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="kc">null</span><span class="p">,</span><span class="kc">null</span><span class="p">,</span><span class="kc">null</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">targetSum</span> <span class="o">=</span> <span class="mi">22</span>
<span class="n">输出</span><span class="err">：</span><span class="kc">true</span>
<span class="n">解释</span><span class="err">：</span><span class="n">等于目标和的根节点到叶节点路径如上图所示</span><span class="err">。</span>
</pre></table></code></div></div><p><strong>解法一</strong>：递归遍历，回溯算法思想</p><p>前部遍历位置（进入节点）<code class="language-plaintext highlighter-rouge">sum += root-&gt;val</code>，顺便判断是否到达叶子节点且和为<code class="language-plaintext highlighter-rouge">targetSum</code>；后序遍历位置（离开节点）<code class="language-plaintext highlighter-rouge">sum -= root-&gt;val</code>。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">bool</span> <span class="n">res</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
    <span class="n">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">bool</span> <span class="nf">hasPathSum</span><span class="p">(</span><span class="nc">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="n">int</span> <span class="n">targetSum</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">traverse</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">targetSum</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">void</span> <span class="nf">traverse</span><span class="p">(</span><span class="nc">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="n">int</span> <span class="n">targetSum</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
        <span class="c1">//前序遍历位置</span>
        <span class="n">sum</span> <span class="o">+=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span>
        <span class="c1">// 到达叶子节点且和为targetSum</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">&amp;&amp;</span> <span class="n">sum</span> <span class="o">==</span> <span class="n">targetSum</span><span class="p">)</span> <span class="n">res</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
        <span class="nf">traverse</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">targetSum</span><span class="p">);</span>
        <span class="nf">traverse</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">targetSum</span><span class="p">);</span>
        <span class="c1">//后序遍历位置</span>
        <span class="n">sum</span> <span class="o">-=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><p><strong>解法二</strong>：分解成子树问题，动态规划思想</p><p>遍历到一个节点，继续遍历左孩子和右孩子，且targetSum减去节点的数值。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
    
<span class="k">public</span><span class="o">:</span>
    <span class="c1">// 定义：输入一个根节点，返回该根节点到叶子节点是否存在一条和为 targetSum 的路径</span>
    <span class="n">bool</span> <span class="nf">hasPathSum</span><span class="p">(</span><span class="nc">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="n">int</span> <span class="n">targetSum</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">&amp;&amp;</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">==</span> <span class="n">targetSum</span><span class="p">)</span> <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
        <span class="c1">// 左子树或者右子树有一个满足即可</span>
        <span class="k">return</span> <span class="nf">hasPathSum</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">targetSum</span> <span class="o">-</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">)</span> <span class="o">||</span>
                <span class="nf">hasPathSum</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">targetSum</span> <span class="o">-</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h2 id="113路径总和ii"><span class="mr-2">113、路径总和ii</span><a href="#113路径总和ii" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>给你二叉树的根节点 <code class="language-plaintext highlighter-rouge">root</code> 和一个整数目标和 <code class="language-plaintext highlighter-rouge">targetSum</code> ，找出所有 <strong>从根节点到叶子节点</strong> 路径总和等于给定目标和的路径。</p><p><strong>示例：</strong></p><div align="center"><img data-src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204221122861.jpeg" alt="img" style="zoom:50%;" data-proofer-ignore></div><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">root</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="kc">null</span><span class="p">,</span><span class="mi">13</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="kc">null</span><span class="p">,</span><span class="kc">null</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">targetSum</span> <span class="o">=</span> <span class="mi">22</span>
<span class="n">输出</span><span class="err">：</span><span class="p">[[</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">5</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]]</span>
</pre></table></code></div></div><p>相对于⌈<strong>112、路径总和</strong>⌋来说，前序和后序位置不仅要维护<code class="language-plaintext highlighter-rouge">sum</code>，还要维护路径<code class="language-plaintext highlighter-rouge">path</code>。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&gt;</span> <span class="n">res</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span> <span class="n">path</span><span class="p">;</span>
    <span class="n">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&gt;</span> <span class="nf">pathSum</span><span class="p">(</span><span class="nc">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="n">int</span> <span class="n">targetSum</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">traverse</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">targetSum</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">void</span> <span class="nf">traverse</span><span class="p">(</span><span class="nc">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="n">int</span> <span class="n">targetSum</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
        <span class="c1">//前序遍历位置</span>
        <span class="n">sum</span> <span class="o">+=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span>
        <span class="n">path</span><span class="mf">.</span><span class="nf">push_back</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">&amp;&amp;</span> <span class="n">sum</span> <span class="o">==</span> <span class="n">targetSum</span><span class="p">)</span> <span class="n">res</span><span class="mf">.</span><span class="nf">push_back</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
        <span class="nf">traverse</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">targetSum</span><span class="p">);</span>
        <span class="nf">traverse</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">targetSum</span><span class="p">);</span>
        <span class="c1">//后序遍历位置</span>
        <span class="n">sum</span> <span class="o">-=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span>
        <span class="n">path</span><span class="mf">.</span><span class="nf">pop_back</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h2 id="437路径总和iii"><span class="mr-2">437、路径总和iii</span><a href="#437路径总和iii" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>给定一个二叉树的根节点 <code class="language-plaintext highlighter-rouge">root</code> ，和一个整数 <code class="language-plaintext highlighter-rouge">targetSum</code> ，求该二叉树里节点值之和等于 <code class="language-plaintext highlighter-rouge">targetSum</code> 的 <strong>路径</strong> 的数目。</p><p><strong>路径</strong> 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p><p><strong>示例：</strong></p><div align="center"><img data-src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204221609909.jpeg" alt="img" style="zoom: 50%;" data-proofer-ignore></div><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">root</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="kc">null</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="kc">null</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">targetSum</span> <span class="o">=</span> <span class="mi">8</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">3</span>
<span class="n">解释</span><span class="err">：</span><span class="n">和等于</span> <span class="mi">8</span> <span class="n">的路径有</span> <span class="mi">3</span> <span class="n">条</span><span class="err">，</span><span class="n">如图所示</span>
</pre></table></code></div></div><p>这题及要求你准确理解二叉树的前序后序遍历，还要熟悉前缀和技巧，把前缀和技巧用到二叉树上。</p><p>这道题涉及到数组的技巧，暂定先不做。</p><h1 id="二叉树是否对称相等">二叉树是否对称/相等</h1><p><strong>101、对称二叉树</strong>和<strong>100、相同的树</strong>结合起来看，两道题方法和代码上非常相似。</p><h2 id="100相同的树"><span class="mr-2">100、相同的树</span><a href="#100相同的树" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>给你两棵二叉树的根节点 <code class="language-plaintext highlighter-rouge">p</code> 和 <code class="language-plaintext highlighter-rouge">q</code> ，编写一个函数来检验这两棵树是否相同。</p><p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p><p><strong>示例：</strong></p><div align="center"><img data-src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204201830207.jpeg" alt="img" style="zoom:60%;" data-proofer-ignore></div><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">p</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="n">q</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="n">输出</span><span class="err">：</span><span class="kc">true</span>
</pre></table></code></div></div><p>解法一：分解成子树问题</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">bool</span> <span class="nf">isSameTree</span><span class="p">(</span><span class="nc">TreeNode</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="nc">TreeNode</span><span class="o">*</span> <span class="n">q</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">p</span> <span class="o">||</span> <span class="o">!</span><span class="n">q</span><span class="p">)</span> <span class="k">return</span> <span class="n">p</span> <span class="o">==</span> <span class="n">q</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">!=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">)</span> <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
        <span class="n">bool</span> <span class="n">left</span> <span class="o">=</span> <span class="nf">isSameTree</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>	<span class="c1">//比较左子树</span>
        <span class="n">bool</span> <span class="n">right</span> <span class="o">=</span> <span class="nf">isSameTree</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span><span class="c1">//比较右子树</span>
        <span class="k">return</span> <span class="n">left</span> <span class="o">&amp;&amp;</span> <span class="n">right</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><p>代码简化为：</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">bool</span> <span class="nf">isSameTree</span><span class="p">(</span><span class="nc">TreeNode</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="nc">TreeNode</span><span class="o">*</span> <span class="n">q</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 判断一对节点是否相同</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">p</span> <span class="o">||</span> <span class="o">!</span><span class="n">q</span><span class="p">)</span> <span class="k">return</span> <span class="n">p</span> <span class="o">==</span> <span class="n">q</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">!=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">)</span> <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
        <span class="c1">// 判断其他节点是否相同</span>
        <span class="k">return</span> <span class="nf">isSameTree</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nf">isSameTree</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><p><strong>解法二</strong>：迭代法</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">bool</span> <span class="nf">isSameTree</span><span class="p">(</span><span class="nc">TreeNode</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="nc">TreeNode</span><span class="o">*</span> <span class="n">q</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">queue</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">*&gt;</span> <span class="n">que</span><span class="p">;</span>
        <span class="n">que</span><span class="mf">.</span><span class="nf">push</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
        <span class="n">que</span><span class="mf">.</span><span class="nf">push</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
        <span class="c1">//注意不能加上写成如下代码，否则会报错</span>
        <span class="c1">//if(p) que.push(p);   </span>
        <span class="c1">//if(q) que.push(q);  </span>
        <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">que</span><span class="mf">.</span><span class="nb">empty</span><span class="p">())</span> <span class="p">{</span>  <span class="c1">// 接下来就要判断这两颗树是否相等</span>
            <span class="nc">TreeNode</span><span class="o">*</span> <span class="n">leftNode</span> <span class="o">=</span> <span class="n">que</span><span class="mf">.</span><span class="nf">front</span><span class="p">();</span> <span class="n">que</span><span class="mf">.</span><span class="nf">pop</span><span class="p">();</span>
            <span class="nc">TreeNode</span><span class="o">*</span> <span class="n">rightNode</span> <span class="o">=</span> <span class="n">que</span><span class="mf">.</span><span class="nf">front</span><span class="p">();</span> <span class="n">que</span><span class="mf">.</span><span class="nf">pop</span><span class="p">();</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">leftNode</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">rightNode</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 左节点为空、右节点为空，此时说明是相等的</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="c1">// 左右一个节点不为空，或者都不为空但数值不相同，返回false</span>
            <span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">leftNode</span> <span class="o">||</span> <span class="o">!</span><span class="n">rightNode</span> <span class="o">||</span> <span class="p">(</span><span class="n">leftNode</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">!=</span> <span class="n">rightNode</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">)))</span> <span class="p">{</span>
                <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">que</span><span class="mf">.</span><span class="nf">push</span><span class="p">(</span><span class="n">leftNode</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>   
            <span class="n">que</span><span class="mf">.</span><span class="nf">push</span><span class="p">(</span><span class="n">rightNode</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span> 
            <span class="n">que</span><span class="mf">.</span><span class="nf">push</span><span class="p">(</span><span class="n">leftNode</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>  
            <span class="n">que</span><span class="mf">.</span><span class="nf">push</span><span class="p">(</span><span class="n">rightNode</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span> 
        <span class="p">}</span>
        <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><p><strong>注意</strong>：</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">que</span><span class="mf">.</span><span class="nf">push</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="n">que</span><span class="mf">.</span><span class="nf">push</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
</pre></table></code></div></div><p>不能写为：</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>if(p) que.push(p);   
if(q) que.push(q);  
</pre></table></code></div></div><p>否则会报错：</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="n">执行出错信息</span><span class="err">：</span>
<span class="nc">Line</span> <span class="mi">15</span><span class="o">:</span> <span class="nc">Char</span> <span class="mi">74</span><span class="o">:</span> <span class="n">runtime</span> <span class="n">error</span><span class="o">:</span> <span class="n">member</span> <span class="n">access</span> <span class="n">within</span> <span class="n">misaligned</span> <span class="n">address</span> <span class="mh">0xbebebebebebebebe</span> <span class="k">for</span> <span class="n">type</span> <span class="s1">'TreeNode'</span><span class="p">,</span> <span class="n">which</span> <span class="n">requires</span> <span class="mi">8</span> <span class="n">byte</span> <span class="nf">alignment</span> <span class="p">(</span><span class="n">solution</span><span class="mf">.</span><span class="n">cpp</span><span class="p">)</span>
<span class="mh">0xbebebebebebebebe</span><span class="o">:</span> <span class="n">note</span><span class="o">:</span> <span class="n">pointer</span> <span class="n">points</span> <span class="n">here</span>
<span class="o">&lt;</span><span class="n">memory</span> <span class="n">cannot</span> <span class="n">be</span> <span class="n">printed</span><span class="o">&gt;</span>
<span class="no">SUMMARY</span><span class="o">:</span> <span class="nc">UndefinedBehaviorSanitizer</span><span class="o">:</span> <span class="n">undefined</span><span class="o">-</span><span class="n">behavior</span> <span class="n">prog_joined</span><span class="mf">.</span><span class="n">cpp</span><span class="o">:</span><span class="mi">24</span><span class="o">:</span><span class="mi">74</span>
<span class="n">最后执行的输入</span><span class="err">：</span>
<span class="p">[]</span>
<span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></table></code></div></div><p>加上<code class="language-plaintext highlighter-rouge">if</code>判断后，若输入当中有为空的，则无法加入到队列当中，影响后序的代码逻辑运行。</p><h2 id="101对称二叉树"><span class="mr-2">101、对称二叉树</span><a href="#101对称二叉树" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>给定一个二叉树，检查它是否是镜像对称的。</p><div align="center"><img data-src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204251941296.png" alt="101. 对称二叉树" style="zoom:55%;" data-proofer-ignore></div><p><strong>解法一</strong>：分解成子树问题</p><p>对于二叉树是否对称，要比较的是根节点的左子树与右子树是不是相互翻转的，理解这一点就知道了<strong>其实我们要比较的是两颗树（这两颗树是根节点的左右子树）</strong>，所以在递归遍历的过程中，也是要同时遍历两棵树。</p><p>正是因为要遍历两棵树而且要<strong>比较内侧和外侧节点</strong>，所以准确的来说是一个树的遍历顺序是<strong>左右中</strong>，一个树的遍历顺序是<strong>右左中</strong>，只有内侧和外侧节点分别对应相等，这两棵树才是对称的。</p><p><strong>返回条件</strong>：</p><ul><li>左节点为空，右节点不为空，不对称，return false；<li>左不为空，右为空，不对称 return false；<li>左右都为空，对称，返回true；<li>左右都不为空，比较节点数值，不相同就return false；<li>左右节点相等的话，再递归判断子节点；</ul><p>代码如下：</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre>if (left == NULL &amp;&amp; right != NULL) return false;
else if (left != NULL &amp;&amp; right == NULL) return false;
else if (left == NULL &amp;&amp; right == NULL) return true;
else if (left-&gt;val != right-&gt;val) return false;
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if(!root) return true;
        return compare(root-&gt;left, root-&gt;right);
    }
    //定义：输入左、右节点，返回分别以这两节点为根节点的二叉树是否对称
    bool compare(TreeNode* left, TreeNode* right){
        // 注意这里终止条件的代码
        if(!left || !right) return left == right;
        if(left-&gt;val != right-&gt;val) return false;
        bool outside = compare(left-&gt;left, right-&gt;right);   //外侧节点比较
        bool inside = compare(left-&gt;right, right-&gt;left);    //内侧节点比较
        return outside &amp;&amp; inside;   //左右子节点需要对称相同
    }
};
</pre></table></code></div></div><p>代码简化为：</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre>class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if(!root) return true;
        return compare(root-&gt;left, root-&gt;right);
    }
    //定义：输入左、右节点，返回分别以这两节点为根节点的二叉树是否对称
    bool compare(TreeNode* left, TreeNode* right){
        // 该对节点是否对称
        if(!left || !right) return left == right;
        if(left-&gt;val != right-&gt;val) return false;
        // 其他节点是否对称
        return compare(left-&gt;left, right-&gt;right) &amp;&amp; compare(left-&gt;right, right-&gt;left);
    }
};
</pre></table></code></div></div><p><strong>解法二</strong>：迭代法，不是层序遍历，这里我们可以使用<strong>队列</strong>来比较两个树（根节点的左右子树）是否相互翻转。</p><p>把左右两个子树要比较的元素顺序放进一个容器，然后<strong>成对</strong>的取出来进行比较，那么其实使用<strong>栈</strong>也是可以的。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre>class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if (root == NULL) return true;
        queue&lt;TreeNode*&gt; que;
        que.push(root-&gt;left);   // 将左子树头结点加入队列
        que.push(root-&gt;right);  // 将右子树头结点加入队列
        
        while (!que.empty()) {  // 接下来就要判断这两个树是否相互翻转
            TreeNode* leftNode = que.front(); que.pop();
            TreeNode* rightNode = que.front(); que.pop();
            if (!leftNode &amp;&amp; !rightNode) {  // 左节点为空、右节点为空，此时说明是对称的
                continue;
            }
            // 左右一个节点不为空，或者都不为空但数值不相同，返回false
            if ((!leftNode || !rightNode || (leftNode-&gt;val != rightNode-&gt;val))) {
                return false;
            }
            que.push(leftNode-&gt;left);   // 加入左节点左孩子
            que.push(rightNode-&gt;right); // 加入右节点右孩子
            que.push(leftNode-&gt;right);  // 加入左节点右孩子
            que.push(rightNode-&gt;left);  // 加入右节点左孩子
        }
        return true;
    }
};
</pre></table></code></div></div><h2 id="572另一个树的子树"><span class="mr-2">572、另一个树的子树</span><a href="#572另一个树的子树" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>给你两棵二叉树 <code class="language-plaintext highlighter-rouge">root</code> 和 <code class="language-plaintext highlighter-rouge">subRoot</code> ，检验 <code class="language-plaintext highlighter-rouge">root</code> 中是否包含和 <code class="language-plaintext highlighter-rouge">subRoot</code> 具有相同结构和节点值的子树。如果存在，返回 <code class="language-plaintext highlighter-rouge">true</code> ；否则，返回 <code class="language-plaintext highlighter-rouge">false</code> 。</p><p>二叉树 <code class="language-plaintext highlighter-rouge">tree</code> 的一棵子树包括 <code class="language-plaintext highlighter-rouge">tree</code> 的某个节点和这个节点的所有后代节点，<code class="language-plaintext highlighter-rouge">tree</code> 也可以看做它自身的一棵子树。</p><p><strong>示例：</strong></p><div align="center"><img data-src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204201953856.jpeg" alt="img" style="zoom:50%;" data-proofer-ignore></div><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>输入：root = [3,4,5,1,2], subRoot = [4,1,2]
输出：true
</pre></table></code></div></div><p>遍历以 <code class="language-plaintext highlighter-rouge">root</code> 为根的这棵二叉树的所有节点，用 ⌈<strong>100、相同的树</strong>⌋ 中的 <code class="language-plaintext highlighter-rouge">isSameTree</code> 函数判断以该节点为根的子树是否和以 <code class="language-plaintext highlighter-rouge">subRoot</code> 为根的那棵树相同。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">bool</span> <span class="nf">isSubtree</span><span class="p">(</span><span class="nc">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="nc">TreeNode</span><span class="o">*</span> <span class="n">subRoot</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="k">return</span> <span class="n">root</span> <span class="o">==</span> <span class="n">subRoot</span><span class="p">;</span>
        <span class="c1">// 判断以 root 为根的二叉树是否和 subRoot 相同</span>
        <span class="k">if</span><span class="p">(</span><span class="nf">isSameTree</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">subRoot</span><span class="p">))</span> <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
        <span class="c1">// 去左右子树中判断是否有和 subRoot 相同的子树</span>
        <span class="k">return</span> <span class="nf">isSubtree</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">subRoot</span><span class="p">)</span> <span class="o">||</span> <span class="nf">isSubtree</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">subRoot</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">// 定义：输入两个节点，判断以两个节点为根节点的二叉树是否一样，返回结果</span>
    <span class="n">bool</span> <span class="nf">isSameTree</span><span class="p">(</span><span class="nc">TreeNode</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="nc">TreeNode</span><span class="o">*</span> <span class="n">q</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 判断一对节点是否相同</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">p</span> <span class="o">||</span> <span class="o">!</span><span class="n">q</span><span class="p">)</span> <span class="k">return</span> <span class="n">p</span> <span class="o">==</span> <span class="n">q</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">!=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">)</span> <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
        <span class="c1">// 判断其他节点是否相同</span>
        <span class="k">return</span> <span class="nf">isSameTree</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nf">isSameTree</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h1 id="左叶子左下角问题">左叶子/左下角问题</h1><h2 id="404左叶子之和"><span class="mr-2">404、左叶子之和</span><a href="#404左叶子之和" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>给定二叉树的根节点 <code class="language-plaintext highlighter-rouge">root</code> ，返回所有左叶子之和。</p><p><strong>示例：</strong></p><div align="center"><img data-src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204202035803.jpeg" alt="img" style="zoom:50%;" data-proofer-ignore></div><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="o">:</span> <span class="n">root</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="kc">null</span><span class="p">,</span><span class="kc">null</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span> 
<span class="n">输出</span><span class="o">:</span> <span class="mi">24</span> 
<span class="n">解释</span><span class="o">:</span> <span class="n">在这个二叉树中</span><span class="err">，</span><span class="n">有两个左叶子</span><span class="err">，</span><span class="n">分别是</span> <span class="mi">9</span> <span class="n">和</span> <span class="mi">15</span><span class="err">，</span><span class="n">所以返回</span> <span class="mi">24</span>
</pre></table></code></div></div><p><strong>首先要注意是判断左叶子，不是二叉树左侧节点，所以不要上来想着层序遍历。</strong></p><p>本题遍历二叉树即可，问题是如何判断节点是<strong>左叶子</strong>呢？</p><p><strong>如果左节点不为空，且左节点没有左右孩子，那么这个节点的左节点就是左叶子</strong>，必须要通过节点的父节点来判断其左孩子是不是左叶子：</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">!=</span> <span class="kc">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">==</span> <span class="kc">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">==</span> <span class="kc">NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">左叶子节点处理逻辑</span>
<span class="p">}</span>
</pre></table></code></div></div><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    
    <span class="n">int</span> <span class="nf">sumOfLeftLeaves</span><span class="p">(</span><span class="nc">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">traverse</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="n">void</span> <span class="nf">traverse</span><span class="p">(</span><span class="nc">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
        <span class="c1">// 找到左侧的叶子节点，记录累加值</span>
        <span class="k">if</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">){</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="nf">traverse</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
        <span class="nf">traverse</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h2 id="513找树左下角的值"><span class="mr-2">513、找树左下角的值</span><a href="#513找树左下角的值" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>给定一个二叉树的 <strong>根节点</strong> <code class="language-plaintext highlighter-rouge">root</code>，请找出该二叉树的 <strong>最底层 最左边</strong> 节点的值。</p><p>假设二叉树中至少有一个节点。</p><p><strong>示例：</strong></p><div align="center"><img data-src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204212053339.jpeg" alt="img" style="zoom:60%;" data-proofer-ignore></div><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>输入: root = [2,1,3]
输出: 1
</pre></table></code></div></div><p><strong>解法一</strong>：递归遍历二叉树</p><p>二叉树递归框架代码是先递归左子树，后递归右子树，所以<strong>到最大深度时第一次遇到的节点就是左下角的节点</strong>。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">int</span> <span class="n">depth</span><span class="p">;</span>		<span class="c1">// 记录 traverse 递归遍历到的深度</span>
    <span class="n">int</span> <span class="n">maxDepth</span><span class="p">;</span>	<span class="c1">// 记录二叉树的最大深度</span>
    <span class="nc">TreeNode</span><span class="o">*</span> <span class="n">res</span><span class="p">;</span>

    <span class="n">int</span> <span class="nf">findBottomLeftValue</span><span class="p">(</span><span class="nc">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">traverse</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">void</span> <span class="nf">traverse</span><span class="p">(</span><span class="nc">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
        <span class="n">depth</span><span class="o">++</span><span class="p">;</span>
        <span class="c1">// 到最大深度时第一次遇到的节点就是左下角的节点</span>
        <span class="k">if</span><span class="p">(</span><span class="n">depth</span> <span class="o">&gt;</span> <span class="n">maxDepth</span><span class="p">){</span>
            <span class="n">maxDepth</span> <span class="o">=</span> <span class="n">depth</span><span class="p">;</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="nf">traverse</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
        <span class="nf">traverse</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
        <span class="n">depth</span><span class="o">--</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><p><strong>解法二</strong>：层序遍历，很好理解</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">int</span> <span class="nf">findBottomLeftValue</span><span class="p">(</span><span class="nc">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">queue</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">*&gt;</span> <span class="n">que</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">!=</span> <span class="kc">NULL</span><span class="p">)</span> <span class="n">que</span><span class="mf">.</span><span class="nf">push</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
        <span class="n">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="c1">//后续循环会不断刷新result的值</span>
        <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">que</span><span class="mf">.</span><span class="nb">empty</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">que</span><span class="mf">.</span><span class="nf">size</span><span class="p">();</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="nc">TreeNode</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">que</span><span class="mf">.</span><span class="nf">front</span><span class="p">();</span>
                <span class="n">que</span><span class="mf">.</span><span class="nf">pop</span><span class="p">();</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">result</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span> <span class="c1">// 记录最后一行第一个元素</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="n">que</span><span class="mf">.</span><span class="nf">push</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span> <span class="n">que</span><span class="mf">.</span><span class="nf">push</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><p>找树左下角的值会做了，找树右下角的值自然也会做了，也就是把遍历的顺序改变一下：先遍历右子树，再遍历左子树。</p><h1 id="完全二叉树">完全二叉树</h1><h2 id="bm35-判断是不是完全二叉树"><span class="mr-2"><a href="https://www.nowcoder.com/practice/8daa4dff9e36409abba2adbe413d6fae?tpId=295&amp;tqId=2299105&amp;ru=/exam/oj&amp;qru=/ta/format-top101/question-ranking&amp;sourceUrl=%2Fexam%2Foj"><span class="mr-2">BM35 判断是不是完全二叉树</a></span><a href="#bm35-判断是不是完全二叉树" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>给定一个二叉树，确定他是否是一个<strong>完全二叉树</strong>。</p><p><strong>完全二叉树</strong>的定义：若二叉树的深度为 h，除第 h 层外，其它各层的结点数都达到最大个数，第 h 层所有的叶子结点都连续集中在最左边，这就是完全二叉树。（第 h 层可能包含 [1~2h] 个节点）</p><p>样例图1：叶子节点出现在最后一层</p><div align="center"><img data-src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205012041648.png" alt="img" style="zoom:80%;" data-proofer-ignore></div><p>样例图2：叶子节点出现在最后一次和倒数第二层</p><div align="center"><img data-src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205012050113.png" alt="img" style="zoom:60%;" data-proofer-ignore></div><p><a href="https://baike.baidu.com/item/完全二叉树/7773232?fr=aladdin">完全二叉树</a> 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。</p><p>本道题的解题关键就是要紧紧抓住<strong>完全二叉树的定义</strong>，使用<strong>层序遍历</strong>。如果遇到某个节点为空，进行标记，代表访问到完全二叉树的最下层，若是后续还有访问，则不符合完全二叉树的定义。</p><p>注意：</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">que</span><span class="mf">.</span><span class="nf">push</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
<span class="n">que</span><span class="mf">.</span><span class="nf">push</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
</pre></table></code></div></div><p>不能写成：</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="k">if</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="nf">push</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span> <span class="n">que</span><span class="mf">.</span><span class="nf">push</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
</pre></table></code></div></div><p>否则， 完全二叉树最后一层的空节点是访问不到的。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
    <span class="n">bool</span> <span class="nf">isCompleteTree</span><span class="p">(</span><span class="nc">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">//空树一定是完全二叉树</span>
        <span class="k">if</span><span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">NULL</span><span class="p">)</span>  <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
        <span class="n">queue</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">*&gt;</span> <span class="n">que</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">root</span><span class="p">)</span> <span class="n">que</span><span class="mf">.</span><span class="nf">push</span><span class="p">(</span><span class="n">root</span><span class="p">);</span> 
        <span class="c1">//定义一个首次出现的标记位</span>
        <span class="n">bool</span> <span class="n">flag</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span> 
        <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">que</span><span class="mf">.</span><span class="nb">empty</span><span class="p">()){</span> 
            <span class="n">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">que</span><span class="mf">.</span><span class="nf">size</span><span class="p">();</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="nc">TreeNode</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">que</span><span class="mf">.</span><span class="nf">front</span><span class="p">();</span>
                <span class="n">que</span><span class="mf">.</span><span class="nf">pop</span><span class="p">();</span>
                <span class="c1">//标记第一次遇到空节点</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node</span><span class="p">)</span> 
                    <span class="n">flag</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span> 
                <span class="k">else</span><span class="p">{</span>
                    <span class="c1">//后续访问已经遇到空节点了，说明经过了叶子</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">flag</span><span class="p">)</span> <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
                    <span class="n">que</span><span class="mf">.</span><span class="nf">push</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
                    <span class="n">que</span><span class="mf">.</span><span class="nf">push</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h2 id="222完全二叉树的节点个数"><span class="mr-2">222、完全二叉树的节点个数</span><a href="#222完全二叉树的节点个数" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>给你一棵 <strong>完全二叉树</strong> 的根节点 <code class="language-plaintext highlighter-rouge">root</code> ，求出该树的节点个数。</p><p><a href="https://baike.baidu.com/item/完全二叉树/7773232?fr=aladdin">完全二叉树</a> 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。</p><p><strong>示例：</strong></p><div align="center"><img data-src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204202028146.jpeg" alt="img" style="zoom:50%;" data-proofer-ignore></div><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">root</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">6</span>
</pre></table></code></div></div><p>首先要搞清楚什么是 ⌈<strong>完全二叉树</strong>⌋ 和 ⌈<strong>满二叉树</strong>⌋ ：</p><p><strong>完全二叉树</strong>如下图，每一层都是紧凑靠左排列的，除了最底层节点可能没填满外，其余每层节点数都达到最大值：</p><div align="center"><img data-src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204211628453.png" alt="img" style="zoom:50%;" data-proofer-ignore></div><p><strong>满二叉树</strong>如下图，是一种特殊的完全二叉树，每层都是是满的，像一个稳定的三角形：</p><div align="center"><img data-src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204211629053.png" alt="img" style="zoom:80%;" data-proofer-ignore></div><p>如果是一个<strong>普通</strong>二叉树，显然只要向下面这样遍历一边即可，时间复杂度 O(N)：</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">int</span> <span class="nf">countNodes</span><span class="p">(</span><span class="nc">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="nf">countNodes</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="o">+</span> <span class="nf">countNodes</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>那如果是一棵<strong>满</strong>二叉树，节点总数就和树的高度呈指数关系：</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="n">int</span> <span class="nf">countNodes</span><span class="p">(</span><span class="nc">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">int</span> <span class="n">h</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">// 计算树的高度</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">root</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
        <span class="n">h</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 节点总数就是 2^h - 1</span>
    <span class="k">return</span> <span class="p">(</span><span class="mi">2</span> <span class="o">&lt;&lt;</span> <span class="n">h</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p><strong>完全</strong>二叉树比普通二叉树特殊，但又没有满二叉树那么特殊，计算它的节点总数，可以说是普通二叉树和完全二叉树的结合版。</p><p>完全二叉树只有两种情况，情况一：就是满二叉树，情况二：最后一层叶子节点没有满。</p><p>对于情况一，可以直接用 2^树深度 - 1 来计算，注意这里根节点深度为1。</p><p>对于情况二，分别递归左孩子，和右孩子，递归到某一深度一定会有左孩子或者右孩子为满二叉树，然后依然可以按照情况1来计算。</p><div align="center"><img data-src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204211649576.png" alt="image-20220421164919517" style="zoom:60%;" data-proofer-ignore></div><div align="center"><img data-src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204211652510.png" alt="image-20220421165226452" style="zoom:40%;" data-proofer-ignore></div><p>可以看出如果整个树不是满二叉树，就递归其左右孩子，直到遇到满二叉树为止，用公式计算这个子树（满二叉树）的节点数量。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">int</span> <span class="nf">countNodes</span><span class="p">(</span><span class="nc">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="nc">TreeNode</span><span class="o">*</span> <span class="n">left</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
        <span class="nc">TreeNode</span><span class="o">*</span> <span class="n">right</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
        <span class="c1">// 这里初始为0是有目的的，为了下面求指数方便</span>
        <span class="n">int</span> <span class="n">leftHeight</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">int</span> <span class="n">rightHeight</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 
        <span class="c1">// 记录左、右子树的高度</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">left</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
            <span class="n">leftHeight</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">right</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">right</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
            <span class="n">rightHeight</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// 如果左右子树的高度相同，则是一棵满二叉树</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">leftHeight</span> <span class="o">==</span> <span class="n">rightHeight</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="p">(</span><span class="mi">2</span> <span class="o">&lt;&lt;</span> <span class="n">leftHeight</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 注意(2&lt;&lt;1) 相当于2^2，所以leftHeight初始为0</span>
        <span class="p">}</span>
        <span class="c1">// 如果左右高度不同，则按照普通二叉树的逻辑计算</span>
        <span class="k">return</span> <span class="nf">countNodes</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="o">+</span> <span class="nf">countNodes</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><p>这个算法的时间复杂度是 <code class="language-plaintext highlighter-rouge">O(logN*logN)</code>，但直觉感觉好像最坏情况下是 O(N*logN) ，因为之前的 while 需要 logN 的时间，最后要 O(N) 的时间向左右子树递归：</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="nf">countNodes</span><span class="p">(</span><span class="n">root</span><span class="mf">.</span><span class="n">left</span><span class="p">)</span> <span class="o">+</span> <span class="nf">countNodes</span><span class="p">(</span><span class="n">root</span><span class="mf">.</span><span class="n">right</span><span class="p">);</span>
</pre></table></code></div></div><p><strong>关键点在于，这两个递归只有一个会真的递归下去，另一个一定会触发 <code class="language-plaintext highlighter-rouge">leftHeight == rightHeight</code> 而立即返回，不会递归下去</strong>。</p><p>所以，算法的递归深度就是树的高度 O(logN)，每次递归所花费的时间就是 while 循环，需要 O(logN)，所以总体的时间复杂度是 O(logN*logN)。</p><h2 id="二叉树展开为链表"><span class="mr-2">二叉树展开为链表</span><a href="#二叉树展开为链表" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><strong>114、二叉树展开为链表</strong></p><p>给你二叉树的根结点 <code class="language-plaintext highlighter-rouge">root</code> ，请你将它展开为一个单链表：</p><ul><li>展开后的单链表应该同样使用 <code class="language-plaintext highlighter-rouge">TreeNode</code> ，其中 <code class="language-plaintext highlighter-rouge">right</code> 子指针指向链表中下一个结点，而左子指针始终为 <code class="language-plaintext highlighter-rouge">null</code> 。<li>展开后的单链表应该与二叉树 前序遍历 顺序相同。</ul><p><strong>示例 ：</strong></p><div align="center"><img data-src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204171905704.jpeg" alt="img" style="zoom:50%;" data-proofer-ignore></div><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">root</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="kc">null</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
<span class="n">输出</span><span class="err">：</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="kc">null</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="kc">null</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="kc">null</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="kc">null</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="kc">null</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
</pre></table></code></div></div><p><strong>解法一</strong>：递归遍历</p><p>对整棵树进行前序遍历，一边遍历一边构造出一条「链表」。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="c1">// 虚拟头节点，res-&gt;right 就是结果</span>
    <span class="nc">TreeNode</span><span class="o">*</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="c1">// 用来构建链表的指针</span>
    <span class="nc">TreeNode</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">res</span><span class="p">;</span>
    <span class="nc">TreeNode</span><span class="o">*</span> <span class="nf">flatten</span><span class="p">(</span><span class="nc">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">traverse</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="n">void</span> <span class="nf">traverse</span><span class="p">(</span><span class="nc">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">){</span>
		<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
        <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
        <span class="nf">traverse</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
        <span class="nf">traverse</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><p>但是注意 <code class="language-plaintext highlighter-rouge">flatten</code> 函数的签名，返回类型为 <code class="language-plaintext highlighter-rouge">void</code>，也就是说题目希望我们在原地把二叉树拉平成链表。</p><p>这样一来，没办法通过简单的二叉树遍历来解决这道题了。</p><p><strong>解法二</strong>：分解成子树的问题</p><p>对于一个节点 <code class="language-plaintext highlighter-rouge">x</code>，可以执行以下流程：</p><p>1、先利用 <code class="language-plaintext highlighter-rouge">flatten(x.left)</code> 和 <code class="language-plaintext highlighter-rouge">flatten(x.right)</code> 将 <code class="language-plaintext highlighter-rouge">x</code> 的左右子树拉平。</p><p>2、将 <code class="language-plaintext highlighter-rouge">x</code> 的右子树接到左子树下方，然后将整个左子树作为右子树。</p><div align="center"><img data-src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204171948600.png" alt="image-20220417194832538" style="zoom:50%;" data-proofer-ignore></div><p>这样，以 <code class="language-plaintext highlighter-rouge">x</code> 为根的整棵二叉树就被拉平了，恰好完成了 <code class="language-plaintext highlighter-rouge">flatten(x)</code> 的定义。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="c1">//定义：输入一个节点，将以该节点为根节点的二叉树展开成单链表</span>
    <span class="n">void</span> <span class="nf">flatten</span><span class="p">(</span><span class="nc">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
        <span class="c1">// 利用定义，把左右子树拉平</span>
        <span class="nf">flatten</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
        <span class="nf">flatten</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
        <span class="c1">// 1、左右子树已经被拉平成一条链表</span>
        <span class="nc">TreeNode</span><span class="o">*</span> <span class="n">left</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
        <span class="nc">TreeNode</span><span class="o">*</span> <span class="n">right</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
        <span class="c1">// 2、将左子树作为右子树</span>
        <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span>  <span class="n">nullptr</span><span class="p">;</span>
        <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span>
        <span class="c1">// 3、将原先的右子树接到当前右子树的末端</span>
        <span class="nc">TreeNode</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
        <span class="c1">// 注意这里的条件是 p-&gt;right，而不是 p ，即有右孩子则移动指针</span>
        <span class="k">while</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">){</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">p</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h1 id="填充每个节点的下一个右侧节点指针">填充每个节点的下一个右侧节点指针</h1><p><strong>116、填充每个节点的下一个右侧节点指针</strong></p><p>给定一个 <strong>完美二叉树</strong> ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="n">struct</span> <span class="nc">Node</span> <span class="p">{</span>
  <span class="n">int</span> <span class="n">val</span><span class="p">;</span>
  <span class="nc">Node</span> <span class="o">*</span><span class="n">left</span><span class="p">;</span>
  <span class="nc">Node</span> <span class="o">*</span><span class="n">right</span><span class="p">;</span>
  <span class="nc">Node</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 <code class="language-plaintext highlighter-rouge">NULL</code>。</p><p>初始状态下，所有 next 指针都被设置为 <code class="language-plaintext highlighter-rouge">NULL</code>。</p><p><strong>示例：</strong></p><div align="center"><img data-src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204171958858.png" alt="img" style="zoom:50%;" data-proofer-ignore></div><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">root</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span>
<span class="n">输出</span><span class="err">：</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="c1">#,2,3,#,4,5,6,7,#]</span>
</pre></table></code></div></div><p>这道题若使用<strong>常规的</strong>遍历二叉树的话，只能将一个节点的左子树指向右子树，<strong>不同节点的子树之间无法建立联系</strong>，所以要改变遍历的方式。传统的 <code class="language-plaintext highlighter-rouge">traverse</code> 函数是遍历二叉树的所有节点，但现在我们想遍历的其实是两个相邻节点之间的「<strong>空隙</strong>」，所以可以在二叉树的基础上进行抽象，把图中的每一个方框看做一个节点：</p><div align="center"><img data-src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204172004189.png" alt="img" style="zoom:30%;" data-proofer-ignore></div><p><strong>解法一</strong>：递归遍历二叉树</p><p><strong>这样，一棵二叉树被抽象成了一棵三叉树，三叉树上的每个节点就是原先二叉树的两个相邻节点</strong>。</p><p>现在，我们只要实现一个 <code class="language-plaintext highlighter-rouge">traverse</code> 函数来遍历这棵三叉树，每个「三叉树节点」需要做的事就是把自己内部的两个二叉树节点穿起来。这样，<code class="language-plaintext highlighter-rouge">traverse</code> 函数遍历整棵「三叉树」，将所有相邻节的二叉树节点都连接起来，也就避免了我们之前出现的问题，把这道题完美解决。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="nc">Node</span><span class="o">*</span> <span class="nf">connect</span><span class="p">(</span><span class="nc">Node</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
        <span class="nf">traverse</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 三叉树遍历框架</span>
    <span class="n">void</span> <span class="nf">traverse</span><span class="p">(</span><span class="nc">Node</span><span class="o">*</span> <span class="n">node1</span><span class="p">,</span> <span class="nc">Node</span><span class="o">*</span> <span class="n">node2</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">node1</span> <span class="o">||</span> <span class="o">!</span><span class="n">node2</span><span class="p">){</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">node1</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">node2</span><span class="p">;</span>
        <span class="nf">traverse</span><span class="p">(</span><span class="n">node1</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">node1</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
        <span class="nf">traverse</span><span class="p">(</span><span class="n">node2</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">node2</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
        <span class="nf">traverse</span><span class="p">(</span><span class="n">node1</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">node2</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><p><strong>解法二</strong>：层序遍历</p><p>在单层遍历的时候记录一下本层的头部节点，然后在遍历的时候让前一个节点指向本节点。</p><div align="center"><img data-src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204182056966.png" alt="填充每个节点的下一个右侧节点指针.drawio.png" style="zoom:70%;" data-proofer-ignore></div><p>核心代码逻辑为：</p><ul><li><p>遍历到每一层的第一个节点时，用pre记录该节点，然后节点出队，node记录pre；</p><li><p>向后每遍历一个节点，用node记录该节点，然后节点出队，<strong>pre指向node</strong>，pre指针向后移动一位；</p><li><p>该层最后一个节点指向nullptr；</p></ul><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="nc">Node</span><span class="o">*</span> <span class="nf">connect</span><span class="p">(</span><span class="nc">Node</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">queue</span><span class="o">&lt;</span><span class="nc">Node</span><span class="o">*&gt;</span> <span class="n">que</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">!=</span> <span class="kc">NULL</span><span class="p">)</span> <span class="n">que</span><span class="mf">.</span><span class="nf">push</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
        <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">que</span><span class="mf">.</span><span class="nb">empty</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">que</span><span class="mf">.</span><span class="nf">size</span><span class="p">();</span>
            <span class="nc">Node</span><span class="o">*</span> <span class="n">pre</span><span class="p">;</span>
            <span class="nc">Node</span><span class="o">*</span> <span class="n">node</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">pre</span> <span class="o">=</span> <span class="n">que</span><span class="mf">.</span><span class="nf">front</span><span class="p">();</span> <span class="c1">// 取出一层的头结点</span>
                    <span class="n">que</span><span class="mf">.</span><span class="nf">pop</span><span class="p">();</span>
                    <span class="n">node</span> <span class="o">=</span> <span class="n">pre</span><span class="p">;</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="n">node</span> <span class="o">=</span> <span class="n">que</span><span class="mf">.</span><span class="nf">front</span><span class="p">();</span>
                    <span class="n">que</span><span class="mf">.</span><span class="nf">pop</span><span class="p">();</span>
                    <span class="n">pre</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span> <span class="c1">// 本层前一个节点next指向本节点</span>
                    <span class="n">pre</span> <span class="o">=</span> <span class="n">pre</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="n">que</span><span class="mf">.</span><span class="nf">push</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span> <span class="n">que</span><span class="mf">.</span><span class="nf">push</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="n">pre</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="kc">NULL</span><span class="p">;</span> <span class="c1">// 本层最后一个节点指向NULL</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><p>二刷：</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="nc">Node</span><span class="o">*</span> <span class="nf">connect</span><span class="p">(</span><span class="nc">Node</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">queue</span><span class="o">&lt;</span><span class="nc">Node</span><span class="o">*&gt;</span> <span class="n">que</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">root</span><span class="p">)</span> <span class="n">que</span><span class="mf">.</span><span class="nf">push</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
        <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">que</span><span class="mf">.</span><span class="nb">empty</span><span class="p">()){</span>
            <span class="n">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">que</span><span class="mf">.</span><span class="nf">size</span><span class="p">();</span>
            <span class="nc">Node</span><span class="o">*</span> <span class="n">pre</span><span class="p">;</span>
            <span class="k">for</span><span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
                <span class="nc">Node</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">que</span><span class="mf">.</span><span class="nf">front</span><span class="p">();</span>
                <span class="n">que</span><span class="mf">.</span><span class="nf">pop</span><span class="p">();</span>
                <span class="k">if</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
                    <span class="n">pre</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
                <span class="p">}</span><span class="k">else</span><span class="p">{</span>
                    <span class="n">pre</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
                    <span class="n">pre</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="k">if</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="n">que</span><span class="mf">.</span><span class="nf">push</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
                <span class="k">if</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span> <span class="n">que</span><span class="mf">.</span><span class="nf">push</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="n">pre</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="kc">NULL</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h1 id="二叉树序列化">二叉树序列化</h1><h2 id="297-二叉树的序列化与反序列化"><span class="mr-2">297. 二叉树的序列化与反序列化</span><a href="#297-二叉树的序列化与反序列化" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><strong>序列化</strong>是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。</p><p>请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p><p><strong>示例：</strong></p><div align="center"><img data-src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205012111971.jpeg" alt="img" style="zoom:40%;" data-proofer-ignore></div><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">root</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="kc">null</span><span class="p">,</span><span class="kc">null</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="n">输出</span><span class="err">：</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="kc">null</span><span class="p">,</span><span class="kc">null</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
</pre></table></code></div></div><p>使用<strong>拼接字符串</strong>的方式把二叉树<strong>序列化</strong>。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Codec</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>

    <span class="c1">// 序列化</span>
    <span class="n">string</span> <span class="nb">serialize</span><span class="p">(</span><span class="nc">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="k">return</span> <span class="s2">"#"</span><span class="p">;</span>
        <span class="k">return</span> <span class="nf">to_string</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">)</span> <span class="o">+</span> <span class="s2">" "</span> <span class="o">+</span> <span class="nb">serialize</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="o">+</span> <span class="s2">" "</span> <span class="o">+</span> <span class="nb">serialize</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
    <span class="p">}</span>

     <span class="nc">TreeNode</span><span class="o">*</span> <span class="nf">build</span><span class="p">(</span><span class="n">istringstream</span><span class="o">&amp;</span> <span class="n">iss</span><span class="p">){</span>
        <span class="n">string</span> <span class="n">tmp</span><span class="p">;</span>
        <span class="n">iss</span><span class="o">&gt;&gt;</span><span class="n">tmp</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">tmp</span> <span class="o">==</span> <span class="s2">"#"</span><span class="p">)</span> <span class="k">return</span> <span class="kc">NULL</span><span class="p">;</span>
        <span class="nc">TreeNode</span><span class="o">*</span> <span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="nf">stoi</span><span class="p">(</span><span class="n">tmp</span><span class="p">));</span>
        <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="nf">build</span><span class="p">(</span><span class="n">iss</span><span class="p">);</span>
        <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="nf">build</span><span class="p">(</span><span class="n">iss</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 反序列化</span>
    <span class="nc">TreeNode</span><span class="o">*</span> <span class="nf">deserialize</span><span class="p">(</span><span class="n">string</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">istringstream</span> <span class="nf">iss</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
        <span class="k">return</span> <span class="nf">build</span><span class="p">(</span><span class="n">iss</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h2 id="652寻找重复的子树"><span class="mr-2">652、寻找重复的子树</span><a href="#652寻找重复的子树" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>给定一棵二叉树 root，返回所有重复的子树。</p><p>对于同一类的重复子树，你只需要返回其中任意一棵的根结点即可。</p><p>如果两棵树具有相同的结构和相同的结点值，则它们是重复的。</p><p><strong>示例</strong>：</p><div align="center"><img data-src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204172024286.jpeg" alt="img" style="zoom:50%;" data-proofer-ignore></div><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">root</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="kc">null</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="kc">null</span><span class="p">,</span><span class="kc">null</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="n">输出</span><span class="err">：</span><span class="p">[[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">4</span><span class="p">]]</span>
</pre></table></code></div></div><p>如何知道以某个节点为根的子树是不是重复的，是否应该加入结果列表中，需要知道什么信息呢？</p><p><strong>你需要知道以下两点</strong>：</p><p>1、以我为根的这棵二叉树（子树）长啥样？——<strong>后序遍历</strong></p><p>2、以其他节点为根的子树都长啥样？——利用哈希表存起来做比较</p><p>现在，明确了要用后序遍历，那应该怎么描述一棵二叉树的模样呢？二叉树的前序/中序/后序遍历结果可以描述二叉树的结构。所以，可以通过<strong>拼接字符串</strong>的方式把二叉树<strong>序列化</strong>。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="n">int</span><span class="o">&gt;</span> <span class="n">map</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">*&gt;</span> <span class="n">res</span><span class="p">;</span>
    
    <span class="n">vector</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">*&gt;</span> <span class="nf">findDuplicateSubtrees</span><span class="p">(</span><span class="nc">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
		<span class="nf">traverse</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">//定义：输入一个节点，将以该节点为根节点的二叉树序列化，返回序列化后的字符串</span>
    <span class="n">string</span> <span class="nf">traverse</span><span class="p">(</span><span class="nc">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">){</span>
		<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="k">return</span> <span class="s2">"#"</span><span class="p">;</span>
       	<span class="n">string</span> <span class="n">left</span> <span class="o">=</span> <span class="nf">traverse</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
        <span class="n">string</span> <span class="n">right</span> <span class="o">=</span> <span class="nf">traverse</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
        <span class="c1">// 后序位置获取二叉树序列化后的字符串</span>
        <span class="n">string</span> <span class="n">str</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="s2">","</span> <span class="o">+</span> <span class="n">right</span> <span class="o">+</span> <span class="s2">","</span> <span class="o">+</span> <span class="nf">to_string</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span><span class="n">map</span><span class="p">[</span><span class="n">str</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">){</span>
            <span class="n">res</span><span class="mf">.</span><span class="nf">push_back</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">map</span><span class="p">[</span><span class="n">str</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">str</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h1 id="构造二叉树">构造二叉树</h1><p>😶‍🌫️二叉树的构造问题一般都是使用「<strong>分解问题</strong>」的思路：<strong>构造整棵树 = 根节点 + 构造左子树 + 构造右子树</strong>。</p><h2 id="617合并二叉树"><span class="mr-2">617、合并二叉树</span><a href="#617合并二叉树" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，<strong>不为</strong> null 的节点将直接作为新二叉树的节点。返回合并后的二叉树。</p><p><strong>注意:</strong> 合并过程必须从两个树的根节点开始。</p><p><strong>示例：</strong></p><div align="center"><img data-src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204221505893.jpeg" alt="img" style="zoom:50%;" data-proofer-ignore></div><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">root1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="n">root2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="kc">null</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="kc">null</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span>
<span class="n">输出</span><span class="err">：</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="kc">null</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span>
</pre></table></code></div></div><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="c1">//定义：输入两二叉树根节点，返回二叉树处理后的根节点</span>
    <span class="nc">TreeNode</span><span class="o">*</span> <span class="nf">mergeTrees</span><span class="p">(</span><span class="nc">TreeNode</span><span class="o">*</span> <span class="n">root1</span><span class="p">,</span> <span class="nc">TreeNode</span><span class="o">*</span> <span class="n">root2</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">root1</span><span class="p">)</span> <span class="k">return</span> <span class="n">root2</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">root2</span><span class="p">)</span> <span class="k">return</span> <span class="n">root1</span><span class="p">;</span>
        <span class="n">root1</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">+=</span> <span class="n">root2</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span> 
        <span class="n">root1</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="nf">mergeTrees</span><span class="p">(</span><span class="n">root1</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">root2</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
        <span class="n">root1</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="nf">mergeTrees</span><span class="p">(</span><span class="n">root1</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">root2</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">root1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h2 id="654构造最大二叉树"><span class="mr-2">654、构造最大二叉树</span><a href="#654构造最大二叉树" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>给定一个不重复的整数数组 <code class="language-plaintext highlighter-rouge">nums</code> 。 <strong>最大二叉树</strong> 可以用下面的算法从 <code class="language-plaintext highlighter-rouge">nums</code> 递归地构建:</p><ol><li>创建一个根节点，其值为 <code class="language-plaintext highlighter-rouge">nums</code> 中的最大值。<li>递归地在最大值 <strong>左边</strong> 的 <strong>子数组前缀上</strong> 构建左子树。<li>递归地在最大值 <strong>右边</strong> 的 <strong>子数组后缀上</strong> 构建右子树。</ol><p>返回 <code class="language-plaintext highlighter-rouge">nums</code> 构建的<strong>最大二叉树</strong>。</p><p><strong>示例</strong>：</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">nums</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="n">输出</span><span class="err">：</span><span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="kc">null</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="kc">null</span><span class="p">,</span><span class="kc">null</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
               <span class="mi">6</span>
             <span class="o">/</span>  <span class="err">\</span>
            <span class="mi">3</span>    <span class="mi">5</span>
             <span class="err">\</span>   <span class="o">/</span>      
              <span class="mi">2</span> <span class="mi">0</span>   
               <span class="err">\</span>
                <span class="mi">1</span>
</pre></table></code></div></div><p>首先遍历数组把找到最大值 <code class="language-plaintext highlighter-rouge">maxVal</code>，从而把根节点 <code class="language-plaintext highlighter-rouge">root</code> 构造出来，然后对 <code class="language-plaintext highlighter-rouge">maxVal</code> 左边的数组和右边的数组进行递归构建，作为 <code class="language-plaintext highlighter-rouge">root</code> 的左、右子树。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre><td class="rouge-code"><pre><span class="c1">//定义二叉树</span>
<span class="n">struct</span> <span class="nc">TreeNode</span><span class="p">{</span>
    <span class="n">int</span> <span class="n">val</span><span class="p">;</span>
    <span class="nc">TreeNode</span><span class="o">*</span> <span class="n">left</span><span class="p">;</span>
    <span class="nc">TreeNode</span><span class="o">*</span> <span class="n">right</span><span class="p">;</span>
    <span class="nf">TreeNode</span><span class="p">(</span><span class="n">int</span> <span class="n">x</span><span class="p">)</span><span class="o">:</span><span class="nf">val</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="nf">left</span><span class="p">(</span><span class="n">nullptr</span><span class="p">),</span> <span class="nf">right</span><span class="p">(</span><span class="n">nullptr</span><span class="p">){}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="nc">TreeNode</span><span class="o">*</span> <span class="nf">constructMaximumBinaryTree</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nf">build</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">nums</span><span class="mf">.</span><span class="nf">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="c1">//定义：输入数组和区间左右端点，返回构造的最大二叉树的根节点</span>
    <span class="nc">TreeNode</span><span class="o">*</span> <span class="nf">build</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="n">int</span> <span class="n">lo</span><span class="p">,</span> <span class="n">int</span> <span class="n">hi</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="n">lo</span> <span class="o">&gt;</span> <span class="n">hi</span><span class="p">){</span>
            <span class="k">return</span> <span class="n">nullptr</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// 找到数组中的最大值和对应的索引</span>
        <span class="c1">// 注意不能写成 int rootVal = 0;</span>
        <span class="n">int</span> <span class="n">rootVal</span> <span class="o">=</span> <span class="no">INT32_MIN</span><span class="p">;</span>
        <span class="n">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">lo</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">hi</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
			<span class="k">if</span><span class="p">(</span><span class="n">rootVal</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]){</span>
                <span class="n">rootVal</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
                <span class="n">index</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="nc">TreeNode</span><span class="o">*</span> <span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="n">rootVal</span><span class="p">);</span>
        <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="nf">build</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="n">index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="nf">build</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">hi</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h2 id="105从前序与中序遍历序列构造二叉树"><span class="mr-2">105、从前序与中序遍历序列构造二叉树</span><a href="#105从前序与中序遍历序列构造二叉树" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>给定两个整数数组 <code class="language-plaintext highlighter-rouge">preorder</code> 和 <code class="language-plaintext highlighter-rouge">inorder</code> ，其中 <code class="language-plaintext highlighter-rouge">preorder</code> 是二叉树的<strong>先序遍历</strong>， <code class="language-plaintext highlighter-rouge">inorder</code> 是同一棵树的<strong>中序遍历</strong>，请构造二叉树并返回其根节点。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="o">:</span> <span class="n">preorder</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">7</span><span class="p">],</span> <span class="n">inorder</span> <span class="o">=</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span>
<span class="n">输出</span><span class="o">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="kc">null</span><span class="p">,</span><span class="kc">null</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span>
</pre></table></code></div></div><div align="center"><img data-src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204171505952.jpeg" alt="img" style="zoom: 67%;" data-proofer-ignore></div><p>前序遍历<code class="language-plaintext highlighter-rouge">preorder</code> 和 中序遍历<code class="language-plaintext highlighter-rouge">inorder</code> 数组中的元素分布有如下特点：</p><div align="center"><img data-src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204171510562.png" alt="image-20220417151011413" style="zoom:80%;" data-proofer-ignore></div><p>找到根节点是很简单的，前序遍历的第一个值 <code class="language-plaintext highlighter-rouge">preorder[0]</code> 就是根节点的值。关键在于如何通过根节点的值，将 <code class="language-plaintext highlighter-rouge">preorder</code> 和 <code class="language-plaintext highlighter-rouge">postorder</code> 数组划分成两半，构造根节点的左右子树？</p><p><strong>暴力</strong>方法是利用for循环遍历整个数组找出<code class="language-plaintext highlighter-rouge">index</code>，但是通过 for 循环遍历的方式去确定 <code class="language-plaintext highlighter-rouge">index</code> 效率不算高，可以进一步优化：采用<strong>哈利表</strong>的查到 <code class="language-plaintext highlighter-rouge">rootVal</code> 对应的 <code class="language-plaintext highlighter-rouge">index</code>，数组元素无序且不重复，故采用 <code class="language-plaintext highlighter-rouge">unordered_map</code>来实现，底层由<strong>哈希表</strong>实现。</p><p>本道题的一大<strong>难点</strong>在于如何确定左右数组对应的起始索引和终止索引，这个可以通过左子树的节点数推导出来，假设左子树的节点数为 <code class="language-plaintext highlighter-rouge">leftSize</code>，那么 <code class="language-plaintext highlighter-rouge">preorder</code> 数组上的索引情况是这样的：</p><div align="center"><img data-src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204171511724.png" alt="image-20220417151152530" style="zoom:60%;" data-proofer-ignore></div><p>做这种题目一定要画示意图，选择闭区间，若索引填错了，就会引起栈溢出的错误。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">int</span><span class="p">,</span> <span class="n">int</span><span class="o">&gt;</span> <span class="n">map</span><span class="p">;</span>
    
    <span class="nc">TreeNode</span><span class="o">*</span> <span class="nf">buildTree</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&amp;</span> <span class="n">preorder</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&amp;</span> <span class="n">inorder</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">inorder</span><span class="mf">.</span><span class="nf">size</span><span class="p">();</span>
        <span class="c1">//遍历数组构造哈希表</span>
        <span class="k">for</span><span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="n">map</span><span class="p">[</span><span class="n">inorder</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nf">build</span><span class="p">(</span><span class="n">preorder</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">inorder</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">//定义：输入两个数组和区间左右端点，输入构造的二叉树的根节点</span>
    <span class="nc">TreeNode</span><span class="o">*</span> <span class="nf">build</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&amp;</span> <span class="n">preorder</span><span class="p">,</span> <span class="n">int</span> <span class="n">preStart</span><span class="p">,</span> <span class="n">int</span> <span class="n">preEnd</span><span class="p">,</span> 
                    <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&amp;</span> <span class="n">inorder</span><span class="p">,</span> <span class="n">int</span> <span class="n">inStart</span><span class="p">,</span> <span class="n">int</span> <span class="n">inEnd</span><span class="p">){</span>
    	<span class="k">if</span><span class="p">(</span><span class="n">preStart</span> <span class="o">&gt;</span> <span class="n">preEnd</span><span class="p">){</span>
            <span class="k">return</span> <span class="n">nullptr</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">//根节点的值，注意不能写成 int rootVal = preorder[0];</span>
        <span class="n">int</span> <span class="n">rootVal</span> <span class="o">=</span> <span class="n">preorder</span><span class="p">[</span><span class="n">preStart</span><span class="p">];</span>
        <span class="c1">//利用哈希表查询到 rootVal 在 inorder 中的索引 index</span>
        <span class="n">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">map</span><span class="p">[</span><span class="n">rootVal</span><span class="p">];</span>
        
        <span class="n">int</span> <span class="n">leftSize</span> <span class="o">=</span> <span class="n">index</span> <span class="o">-</span> <span class="n">inStart</span><span class="p">;</span>
        
        <span class="nc">TreeNode</span><span class="o">*</span> <span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="n">rootVal</span><span class="p">);</span>
        <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="nf">build</span><span class="p">(</span><span class="n">preorder</span><span class="p">,</span> <span class="n">preStart</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">preStart</span> <span class="o">+</span> <span class="n">leftSize</span><span class="p">,</span> 
                          <span class="n">inorder</span><span class="p">,</span> <span class="n">inStart</span><span class="p">,</span> <span class="n">index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    	<span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="nf">build</span><span class="p">(</span><span class="n">preorder</span><span class="p">,</span> <span class="n">preStart</span> <span class="o">+</span> <span class="n">leftSize</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">preEnd</span><span class="p">,</span>
                           <span class="n">inorder</span><span class="p">,</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">inEnd</span><span class="p">);</span>
    	<span class="k">return</span> <span class="n">root</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h2 id="106从中序与后序遍历序列构造二叉树"><span class="mr-2">106、从中序与后序遍历序列构造二叉树</span><a href="#106从中序与后序遍历序列构造二叉树" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>给定两个整数数组 <code class="language-plaintext highlighter-rouge">inorder</code> 和 <code class="language-plaintext highlighter-rouge">postorder</code> ，其中 <code class="language-plaintext highlighter-rouge">inorder</code> 是二叉树的中序遍历， <code class="language-plaintext highlighter-rouge">postorder</code> 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">inorder</span> <span class="o">=</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">7</span><span class="p">],</span> <span class="n">postorder</span> <span class="o">=</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="n">输出</span><span class="err">：</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="kc">null</span><span class="p">,</span><span class="kc">null</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span>
</pre></table></code></div></div><div align="center"><img data-src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204171505952.jpeg" alt="img" style="zoom: 67%;" data-proofer-ignore></div><p><code class="language-plaintext highlighter-rouge">postoder</code> 和 <code class="language-plaintext highlighter-rouge">inorder</code> 对应的状态如下：</p><div align="center"><img data-src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204171615448.png" alt="image-20220417161545340" style="zoom:60%;" data-proofer-ignore></div><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">int</span><span class="p">,</span> <span class="n">int</span><span class="o">&gt;</span> <span class="n">map</span><span class="p">;</span>
    
    <span class="nc">TreeNode</span><span class="o">*</span> <span class="nf">buildTree</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&amp;</span> <span class="n">inorder</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&amp;</span> <span class="n">postorder</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">inorder</span><span class="mf">.</span><span class="nf">size</span><span class="p">();</span>
        <span class="c1">//遍历数组构造哈希表</span>
        <span class="k">for</span><span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="n">map</span><span class="p">[</span><span class="n">inorder</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nf">build</span><span class="p">(</span><span class="n">inorder</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">postorder</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">//定义：输入两个数组和区间左右端点，输入构造的二叉树的根节点</span>
    <span class="nc">TreeNode</span><span class="o">*</span> <span class="nf">build</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&amp;</span> <span class="n">inorder</span><span class="p">,</span> <span class="n">int</span> <span class="n">inStart</span><span class="p">,</span> <span class="n">int</span> <span class="n">inEnd</span><span class="p">,</span> 
                    <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&amp;</span> <span class="n">postorder</span><span class="p">,</span> <span class="n">int</span> <span class="n">postStart</span><span class="p">,</span> <span class="n">int</span> <span class="n">postEnd</span><span class="p">){</span>
    	<span class="k">if</span><span class="p">(</span><span class="n">postStart</span> <span class="o">&gt;</span> <span class="n">postEnd</span><span class="p">){</span>
            <span class="k">return</span> <span class="n">nullptr</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">//根节点的值</span>
        <span class="n">int</span> <span class="n">rootVal</span> <span class="o">=</span> <span class="n">postorder</span><span class="p">[</span><span class="n">postEnd</span><span class="p">];</span>
        <span class="c1">//利用哈希表查询到 rootVal 在 inorder 中的索引 index</span>
        <span class="n">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">map</span><span class="p">[</span><span class="n">rootVal</span><span class="p">];</span>
        
        <span class="n">int</span> <span class="n">leftSize</span> <span class="o">=</span> <span class="n">index</span> <span class="o">-</span> <span class="n">inStart</span><span class="p">;</span>
        
        <span class="nc">TreeNode</span><span class="o">*</span> <span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="n">rootVal</span><span class="p">);</span>
        <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="nf">build</span><span class="p">(</span><span class="n">inorder</span><span class="p">,</span> <span class="n">inStart</span><span class="p">,</span> <span class="n">index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> 
                          <span class="n">postorder</span><span class="p">,</span> <span class="n">postStart</span><span class="p">,</span> <span class="n">postStart</span> <span class="o">+</span> <span class="n">leftSize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    	<span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="nf">build</span><span class="p">(</span><span class="n">inorder</span><span class="p">,</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">inEnd</span><span class="p">,</span>
                           <span class="n">postorder</span><span class="p">,</span> <span class="n">postStart</span> <span class="o">+</span> <span class="n">leftSize</span><span class="p">,</span> <span class="n">postEnd</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    	<span class="k">return</span> <span class="n">root</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h2 id="889根据前序和后序遍历构造二叉树"><span class="mr-2">889、根据前序和后序遍历构造二叉树</span><a href="#889根据前序和后序遍历构造二叉树" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>给定两个整数数组，<code class="language-plaintext highlighter-rouge">preorder</code> 和 <code class="language-plaintext highlighter-rouge">postorder</code> ，其中 <code class="language-plaintext highlighter-rouge">preorder</code> 是一个具有 <strong>无重复</strong> 值的二叉树的前序遍历，<code class="language-plaintext highlighter-rouge">postorder</code> 是同一棵树的后序遍历，重构并返回二叉树。</p><p>如果存在多个答案，您可以返回其中 <strong>任何</strong> 一个。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">preorder</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">],</span> <span class="n">postorder</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="n">输出</span><span class="err">：</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span>
</pre></table></code></div></div><div align="center"><img data-src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204171628354.jpeg" alt="img" style="zoom:60%;" data-proofer-ignore></div><p>这道题和前两道题有一个本质的区别：</p><p><strong>通过前序中序，或者后序中序遍历结果可以确定一棵原始二叉树，但是通过前序后序遍历结果无法确定原始二叉树</strong>。这道题，你可以确定根节点，但是无法确切的知道左右子树有哪些节点，以下是一种构造方法：</p><p>1、首先把前序遍历结果的第一个元素或者后序遍历结果的最后一个元素确定为根节点的值。</p><p>2、然后把前序遍历结果的第二个元素作为左子树的根节点的值。</p><p>3、在后序遍历结果中寻找左子树根节点的值，从而确定了左子树的索引边界，进而确定右子树的索引边界，递归构造左右子树即可。</p><p>假设前序遍历的第二个元素是左子树的根节点，但实际上左子树有可能是空指针，那么这个元素就应该是右子树的根节点。由于这里无法确切进行判断，所以导致了最终答案的不唯一。</p><div align="center"><img data-src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204171639321.png" alt="image-20220417163947215" style="zoom:70%;" data-proofer-ignore></div><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">int</span><span class="p">,</span> <span class="n">int</span><span class="o">&gt;</span> <span class="n">map</span><span class="p">;</span>
    
    <span class="nc">TreeNode</span><span class="o">*</span> <span class="nf">constructFromPrePost</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&amp;</span> <span class="n">preorder</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&amp;</span> <span class="n">postorder</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">postorder</span><span class="mf">.</span><span class="nf">size</span><span class="p">();</span>
        <span class="c1">//遍历数组构造哈希表</span>
        <span class="k">for</span><span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="n">map</span><span class="p">[</span><span class="n">postorder</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nf">build</span><span class="p">(</span><span class="n">preorder</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">postorder</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="c1">//定义：输入两个数组和区间左右端点，输入构造的二叉树的根节点</span>
    <span class="nc">TreeNode</span><span class="o">*</span> <span class="nf">build</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&amp;</span> <span class="n">preorder</span><span class="p">,</span> <span class="n">int</span> <span class="n">preStart</span><span class="p">,</span> <span class="n">int</span> <span class="n">preEnd</span><span class="p">,</span> 
                    <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&amp;</span> <span class="n">postorder</span><span class="p">,</span> <span class="n">int</span> <span class="n">postStart</span><span class="p">,</span> <span class="n">int</span> <span class="n">postEnd</span><span class="p">){</span>
    	<span class="k">if</span><span class="p">(</span><span class="n">postStart</span> <span class="o">&gt;</span> <span class="n">postEnd</span><span class="p">){</span>
            <span class="k">return</span> <span class="n">nullptr</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span><span class="p">(</span><span class="n">postStart</span> <span class="o">==</span> <span class="n">postEnd</span><span class="p">){</span>
            <span class="k">return</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="n">postorder</span><span class="p">[</span><span class="n">postStart</span><span class="p">]);</span>
        <span class="p">}</span>
        <span class="c1">//根节点的值</span>
        <span class="n">int</span> <span class="n">rootVal</span> <span class="o">=</span> <span class="n">preorder</span><span class="p">[</span><span class="n">preStart</span><span class="p">];</span>
        <span class="n">int</span> <span class="n">leftRootVal</span> <span class="o">=</span> <span class="n">preorder</span><span class="p">[</span><span class="n">preStart</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
        <span class="c1">//利用哈希表查询到左子树根节点 leftRoot 在 postorder 中的索引 index</span>
        <span class="n">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">map</span><span class="p">[</span><span class="n">leftRootVal</span><span class="p">];</span>
        
        <span class="n">int</span> <span class="n">leftSize</span> <span class="o">=</span> <span class="n">index</span> <span class="o">-</span> <span class="n">postStart</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        
        <span class="nc">TreeNode</span><span class="o">*</span> <span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="n">rootVal</span><span class="p">);</span>
        <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="nf">build</span><span class="p">(</span><span class="n">preorder</span><span class="p">,</span> <span class="n">preStart</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">preStart</span> <span class="o">+</span> <span class="n">leftSize</span><span class="p">,</span> 
                          <span class="n">postorder</span><span class="p">,</span> <span class="n">postStart</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
    	<span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="nf">build</span><span class="p">(</span><span class="n">preorder</span><span class="p">,</span> <span class="n">preStart</span> <span class="o">+</span> <span class="n">leftSize</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">preEnd</span><span class="p">,</span>
                           <span class="n">postorder</span><span class="p">,</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">postEnd</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    	<span class="k">return</span> <span class="n">root</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h1 id="层序遍历">层序遍历</h1><h2 id="102二叉树的层序遍历"><span class="mr-2">102、二叉树的层序遍历</span><a href="#102二叉树的层序遍历" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p><div align="center"><img data-src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204181828285.png" alt="102.二叉树的层序遍历" style="zoom:50%;" data-proofer-ignore></div><p>需要借用一个辅助数据结构即<strong>队列</strong>来实现，队列<strong>先进先出</strong>，符合一层一层遍历的逻辑，而是用栈先进后出适合模拟深度优先遍历也就是递归的逻辑。而这种层序遍历方式就是图论中的广度优先遍历，只不过我们应用在二叉树上。</p><p>while循环用来从上到下遍历二叉树的每一层，for循环用来从左到右遍历每一层当中的节点。</p><div align="center"><img data-src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204181834096.png" alt="image-20220418183400018" style="zoom:50%;" data-proofer-ignore></div><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&gt;</span> <span class="nf">levelOrder</span><span class="p">(</span><span class="nc">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">queue</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">*&gt;</span> <span class="n">que</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">!=</span> <span class="kc">NULL</span><span class="p">)</span> <span class="n">que</span><span class="mf">.</span><span class="nf">push</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&gt;</span> <span class="n">result</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">que</span><span class="mf">.</span><span class="nb">empty</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">que</span><span class="mf">.</span><span class="nf">size</span><span class="p">();</span>
            <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">;</span>
            <span class="c1">// 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="nc">TreeNode</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">que</span><span class="mf">.</span><span class="nf">front</span><span class="p">();</span>
                <span class="n">que</span><span class="mf">.</span><span class="nf">pop</span><span class="p">();</span>
                <span class="n">vec</span><span class="mf">.</span><span class="nf">push_back</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="n">que</span><span class="mf">.</span><span class="nf">push</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span> <span class="n">que</span><span class="mf">.</span><span class="nf">push</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="n">result</span><span class="mf">.</span><span class="nf">push_back</span><span class="p">(</span><span class="n">vec</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h2 id="107二叉树的层次遍历ii"><span class="mr-2">107、二叉树的层次遍历II</span><a href="#107二叉树的层次遍历ii" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p><div align="center"><img data-src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204181838870.png" alt="107.二叉树的层次遍历II" style="zoom:55%;" data-proofer-ignore></div><p>相对于102.二叉树的层序遍历，就是最后把<code class="language-plaintext highlighter-rouge">result</code>数组反转一下就可以了。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&gt;</span> <span class="nf">levelOrderBottom</span><span class="p">(</span><span class="nc">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">queue</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">*&gt;</span> <span class="n">que</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">!=</span> <span class="kc">NULL</span><span class="p">)</span> <span class="n">que</span><span class="mf">.</span><span class="nf">push</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&gt;</span> <span class="n">result</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">que</span><span class="mf">.</span><span class="nb">empty</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">que</span><span class="mf">.</span><span class="nf">size</span><span class="p">();</span>
            <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="nc">TreeNode</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">que</span><span class="mf">.</span><span class="nf">front</span><span class="p">();</span>
                <span class="n">que</span><span class="mf">.</span><span class="nf">pop</span><span class="p">();</span>
                <span class="n">vec</span><span class="mf">.</span><span class="nf">push_back</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="n">que</span><span class="mf">.</span><span class="nf">push</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span> <span class="n">que</span><span class="mf">.</span><span class="nf">push</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="n">result</span><span class="mf">.</span><span class="nf">push_back</span><span class="p">(</span><span class="n">vec</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="nf">reverse</span><span class="p">(</span><span class="n">result</span><span class="mf">.</span><span class="nf">begin</span><span class="p">(),</span> <span class="n">result</span><span class="mf">.</span><span class="nb">end</span><span class="p">());</span> <span class="c1">// 在这里反转一下数组即可</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h2 id="103-二叉树的锯齿形层序遍历"><span class="mr-2">103、 二叉树的锯齿形层序遍历</span><a href="#103-二叉树的锯齿形层序遍历" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>给你二叉树的根节点 <code class="language-plaintext highlighter-rouge">root</code> ，返回其节点值的 <strong>锯齿形层序遍历</strong> 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p><p><strong>示例：</strong></p><p><img data-src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204251142392.jpeg" alt="img" style="zoom:60%;" data-proofer-ignore></p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">root</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="kc">null</span><span class="p">,</span><span class="kc">null</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span>
<span class="n">输出</span><span class="err">：</span><span class="p">[[</span><span class="mi">3</span><span class="p">],[</span><span class="mi">20</span><span class="p">,</span><span class="mi">9</span><span class="p">],[</span><span class="mi">15</span><span class="p">,</span><span class="mi">7</span><span class="p">]]</span>
</pre></table></code></div></div><p>这题和 ⌈<a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal">102. 二叉树的层序遍历</a>⌋ 类似，只是要控制遍历方向，另外使用<strong>双向队列</strong><code class="language-plaintext highlighter-rouge">deque</code>来记录遍历路径`path。</p><p><strong>解法一</strong>：使用数组的<strong>深度奇偶变化</strong>来控制遍历顺序</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&gt;</span> <span class="nf">zigzagLevelOrder</span><span class="p">(</span><span class="nc">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&gt;</span> <span class="n">res</span><span class="p">;</span>
        <span class="n">queue</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">*&gt;</span> <span class="n">que</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">root</span><span class="p">)</span> <span class="n">que</span><span class="mf">.</span><span class="nf">push</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
        <span class="n">int</span> <span class="n">depth</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">que</span><span class="mf">.</span><span class="nb">empty</span><span class="p">()){</span>
            <span class="n">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">que</span><span class="mf">.</span><span class="nf">size</span><span class="p">();</span>
            <span class="c1">// 双向队列记录遍历路径</span>
            <span class="n">deque</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span> <span class="n">path</span><span class="p">;</span>
            <span class="n">depth</span><span class="o">++</span><span class="p">;</span>
            <span class="k">for</span><span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
                <span class="nc">TreeNode</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">que</span><span class="mf">.</span><span class="nf">front</span><span class="p">();</span>
                <span class="n">que</span><span class="mf">.</span><span class="nf">pop</span><span class="p">();</span>
                <span class="c1">// 深度为奇数则从左到右</span>
                <span class="k">if</span><span class="p">(</span><span class="n">depth</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">path</span><span class="mf">.</span><span class="nf">push_back</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
                <span class="c1">// 深度为偶数则从右到左</span>
                <span class="k">else</span> <span class="n">path</span><span class="mf">.</span><span class="nf">push_front</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
                <span class="k">if</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="n">que</span><span class="mf">.</span><span class="nf">push</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
                <span class="k">if</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span> <span class="n">que</span><span class="mf">.</span><span class="nf">push</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="n">res</span><span class="mf">.</span><span class="nf">push_back</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span><span class="p">{</span><span class="n">path</span><span class="mf">.</span><span class="nf">begin</span><span class="p">(),</span> <span class="n">path</span><span class="mf">.</span><span class="nb">end</span><span class="p">()});</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><p><strong>解法二</strong>：用一个<strong>布尔变量</strong> <code class="language-plaintext highlighter-rouge">flag</code> 控制遍历方向</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&gt;</span> <span class="nf">zigzagLevelOrder</span><span class="p">(</span><span class="nc">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&gt;</span> <span class="n">res</span><span class="p">;</span>
        <span class="n">queue</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">*&gt;</span> <span class="n">que</span><span class="p">;</span>
        <span class="n">bool</span> <span class="n">flag</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">root</span><span class="p">)</span> <span class="n">que</span><span class="mf">.</span><span class="nf">push</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
        <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">que</span><span class="mf">.</span><span class="nb">empty</span><span class="p">()){</span>
            <span class="n">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">que</span><span class="mf">.</span><span class="nf">size</span><span class="p">();</span>
            <span class="c1">// 双向队列记录遍历路径</span>
            <span class="n">deque</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span> <span class="n">path</span><span class="p">;</span>
            <span class="k">for</span><span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
                <span class="nc">TreeNode</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">que</span><span class="mf">.</span><span class="nf">front</span><span class="p">();</span>
                <span class="n">que</span><span class="mf">.</span><span class="nf">pop</span><span class="p">();</span>
                <span class="c1">// flag为true则从左到右</span>
                <span class="k">if</span><span class="p">(</span><span class="n">flag</span> <span class="o">==</span> <span class="kc">true</span><span class="p">)</span> <span class="n">path</span><span class="mf">.</span><span class="nf">push_back</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
                <span class="c1">// flag为</span>
                <span class="k">else</span> <span class="n">path</span><span class="mf">.</span><span class="nf">push_front</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
                <span class="k">if</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="n">que</span><span class="mf">.</span><span class="nf">push</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
                <span class="k">if</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span> <span class="n">que</span><span class="mf">.</span><span class="nf">push</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="n">flag</span> <span class="o">=</span> <span class="o">!</span><span class="n">flag</span><span class="p">;</span>
            <span class="n">res</span><span class="mf">.</span><span class="nf">push_back</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span><span class="p">{</span><span class="n">path</span><span class="mf">.</span><span class="nf">begin</span><span class="p">(),</span> <span class="n">path</span><span class="mf">.</span><span class="nb">end</span><span class="p">()});</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h2 id="515在每个树行中找最大值"><span class="mr-2">515、在每个树行中找最大值</span><a href="#515在每个树行中找最大值" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>给定一棵二叉树的根节点 <code class="language-plaintext highlighter-rouge">root</code> ，请找出该二叉树中每一层的最大值。</p><div align="center"><img data-src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204190917513.png" alt="515.在每个树行中找最大值" style="zoom:60%;" data-proofer-ignore></div><p><strong>解法一</strong>：递归遍历二叉树</p><p>我们先来思考这样一个问题：如果把根节点看做第 1 层，如何打印出每一个节点所在的层数？</p><p><code class="language-plaintext highlighter-rouge">traverse</code>遍历函数的参数当中只包含<code class="language-plaintext highlighter-rouge">TreeNode* root </code>可以吗？<strong>不行！</strong>还要加上节点所在的层数<code class="language-plaintext highlighter-rouge">level</code>，因为在递归遍历的过程中，遍历左子树接着遍历右子树，层数leve并不是一直增加，同一层的节点level是一样的，所以不能定义全局变量，而是要放在<code class="language-plaintext highlighter-rouge">traverse</code>函数参数当中维护。</p><p><strong>如果要在遍历二叉树的过程中获取每个节点所在的层数，则要在<code class="language-plaintext highlighter-rouge">traverse</code>遍历函数的参数当中添加层数<code class="language-plaintext highlighter-rouge">level</code>。</strong></p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="c1">// 定义：二叉树遍历函数，输入一个节点和该节点所在的层数</span>
<span class="n">void</span> <span class="nf">traverse</span><span class="p">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="p">,</span> <span class="n">int</span> <span class="n">level</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 前序位置</span>
    <span class="nb">printf</span><span class="p">(</span><span class="s2">"节点 %s 在第 %d 层"</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">level</span><span class="p">);</span>
    <span class="c1">//注意如下代码中的 level + 1</span>
    <span class="nf">traverse</span><span class="p">(</span><span class="n">root</span><span class="mf">.</span><span class="n">left</span><span class="p">,</span> <span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="nf">traverse</span><span class="p">(</span><span class="n">root</span><span class="mf">.</span><span class="n">right</span><span class="p">,</span> <span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 人为设定根节点位于第1层</span>
<span class="nf">traverse</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</pre></table></code></div></div><p>回到本题当中，本质上是一个求节点最大值的问题，但问题是<strong>如何保证参与比大小求最值的节点来自于同一层呢</strong>？</p><p>🥳在遍历二叉树的过程中获取每一个节点所在的层数，比较层数就可以了呀，也就是说<strong>这是一个涉及二叉树层数的问题，要在<code class="language-plaintext highlighter-rouge">traverse</code>遍历函数的参数当中添加层数<code class="language-plaintext highlighter-rouge">level</code>。</strong></p><p>假设二叉树的层数从第0层开始算，res数组所以默认从0开始：</p><ul><li>假设数组遍历到二叉树第2层某节点，而res数组当中只有<strong>2</strong>个元素（已获取前两层的最大值），即<code class="language-plaintext highlighter-rouge">level == res.size()</code>，表示res数组当中无该层任何节点，<strong>将该节点添加到res数组中</strong>；</ul><div align="center"><img data-src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204191022409.png" alt="image-20220419102205366" style="zoom:60%;" data-proofer-ignore></div><ul><li>假设数组遍历到二叉树第2层某节点，而res数组当中只有<strong>3</strong>个元素（已获取前三层的最大值），表示该层已经有节点被访问了，则<strong>比大小取最值</strong>；</ul><div align="center"><img data-src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204191022406.png" alt="image-20220419102248364" style="zoom:60%;" data-proofer-ignore></div><p>所以也就是说，核心代码逻辑要使用<code class="language-plaintext highlighter-rouge">if</code>语句分以上两种情况讨论。</p><p>版本一：</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
	<span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">;</span>
    <span class="n">void</span> <span class="nf">traverse</span><span class="p">(</span><span class="nc">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span><span class="n">int</span> <span class="n">level</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">NULL</span><span class="p">){</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span><span class="p">(</span><span class="n">level</span> <span class="o">==</span> <span class="n">res</span><span class="mf">.</span><span class="nf">size</span><span class="p">()){</span><span class="c1">//每层第一个节点</span>
            <span class="n">res</span><span class="mf">.</span><span class="nf">push_back</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span><span class="p">{</span>					<span class="c1">//每层第一个节点之外的节点</span>
            <span class="n">res</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="n">level</span><span class="p">],</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
        <span class="p">}</span> 
        <span class="nf">traverse</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="nf">traverse</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span> <span class="nf">largestValues</span><span class="p">(</span><span class="nc">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">//二叉树层数从第0层开始算</span>
        <span class="nf">traverse</span><span class="p">(</span><span class="n">root</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><p>版本二：</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">;</span>
    <span class="n">int</span> <span class="n">depth</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span> <span class="nf">largestValues</span><span class="p">(</span><span class="nc">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">traverse</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">void</span> <span class="nf">traverse</span><span class="p">(</span><span class="nc">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">depth</span> <span class="o">==</span> <span class="n">res</span><span class="mf">.</span><span class="nf">size</span><span class="p">())</span> <span class="n">res</span><span class="mf">.</span><span class="nf">push_back</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
        <span class="k">else</span><span class="p">{</span>
            <span class="n">res</span><span class="p">[</span><span class="n">depth</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="n">depth</span><span class="p">],</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">depth</span><span class="o">++</span><span class="p">;</span>
        <span class="nf">traverse</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
        <span class="nf">traverse</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
        <span class="n">depth</span><span class="o">--</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><p><strong>注意</strong>：这个版本的代码会把根节点当成第一层，但是本题是要将根节点当作第0层，所以主要代码逻辑要写在<code class="language-plaintext highlighter-rouge">depth++;</code>前面，或者初始化<code class="language-plaintext highlighter-rouge">int depth = -1</code>。</p><p><strong>解法二</strong>：层序遍历</p><p>层序遍历，取每一层的最大值。</p><ul><li>while循环开始遍历每一层时，创建最大值<code class="language-plaintext highlighter-rouge">maxValue</code>；<li>for循环遍历该层每一个节点，顺便更新<code class="language-plaintext highlighter-rouge">maxValue</code>；<li>退出for循环，该层所有节点遍历完成，<code class="language-plaintext highlighter-rouge">maxValue</code>放入结果数据<code class="language-plaintext highlighter-rouge">result</code>中；</ul><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span> <span class="nf">largestValues</span><span class="p">(</span><span class="nc">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">queue</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">*&gt;</span> <span class="n">que</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">!=</span> <span class="kc">NULL</span><span class="p">)</span> <span class="n">que</span><span class="mf">.</span><span class="nf">push</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span> <span class="n">result</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">que</span><span class="mf">.</span><span class="nb">empty</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">que</span><span class="mf">.</span><span class="nf">size</span><span class="p">();</span>
            <span class="n">int</span> <span class="n">maxValue</span> <span class="o">=</span> <span class="no">INT_MIN</span><span class="p">;</span> <span class="c1">// 取每一层的最大值</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="nc">TreeNode</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">que</span><span class="mf">.</span><span class="nf">front</span><span class="p">();</span>
                <span class="n">que</span><span class="mf">.</span><span class="nf">pop</span><span class="p">();</span>
                <span class="n">maxValue</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">maxValue</span> <span class="o">?</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">:</span> <span class="n">maxValue</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="n">que</span><span class="mf">.</span><span class="nf">push</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span> <span class="n">que</span><span class="mf">.</span><span class="nf">push</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="n">result</span><span class="mf">.</span><span class="nf">push_back</span><span class="p">(</span><span class="n">maxValue</span><span class="p">);</span> <span class="c1">// 把最大值放进数组</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h2 id="199二叉树的右视图"><span class="mr-2">199、二叉树的右视图</span><a href="#199二叉树的右视图" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>给定一个二叉树的 <strong>根节点</strong> <code class="language-plaintext highlighter-rouge">root</code>，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p><div align="center"><img data-src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204191815468.png" alt="199.二叉树的右视图" style="zoom:55%;" data-proofer-ignore></div><p><strong>解法一</strong>：递归遍历</p><p>要找到每一层最右边的节点，涉及<strong>二叉树节点所在层数</strong>的问题，还是使用 ⌈<strong>515、在每个树行中找最大值</strong>⌋ 中的遍历框架。</p><p><strong>注意</strong>：由于本题是要找每层最右侧节点，所以<strong>先遍历右子树再遍历左子树</strong>，这样每层遍历时首先访问到的就是要求的节点。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">;</span>

    <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span> <span class="nf">rightSideView</span><span class="p">(</span><span class="nc">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">traverse</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">void</span> <span class="nf">traverse</span><span class="p">(</span><span class="nc">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="n">int</span> <span class="n">level</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
		<span class="c1">//这一层还没有记录值，说明 root 就是右侧视图的第一个节点</span>
        <span class="k">if</span><span class="p">(</span><span class="n">res</span><span class="mf">.</span><span class="nf">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">level</span><span class="p">){</span>
            <span class="n">res</span><span class="mf">.</span><span class="nf">push_back</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
        <span class="p">}</span>
		<span class="c1">// 注意，这里反过来，先遍历右子树再遍历左子树</span>
        <span class="c1">// 这样，首先遍历的一定是右侧节点</span>
        <span class="nf">traverse</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="nf">traverse</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><p>那如果是要求二叉树的<strong>左视图</strong>呢，那就<strong>先遍历左子树再遍历右子树</strong>呗，又AC了一题😜。</p><p><strong>解法二</strong>：层序遍历</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span> <span class="nf">rightSideView</span><span class="p">(</span><span class="nc">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">queue</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">*&gt;</span> <span class="n">que</span><span class="p">;</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">root</span><span class="p">)</span> <span class="n">que</span><span class="mf">.</span><span class="nf">push</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
        <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">que</span><span class="mf">.</span><span class="nb">empty</span><span class="p">()){</span>
            <span class="n">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">que</span><span class="mf">.</span><span class="nf">size</span><span class="p">();</span>
            <span class="k">for</span><span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
                <span class="nc">TreeNode</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">que</span><span class="mf">.</span><span class="nf">front</span><span class="p">();</span>
                <span class="n">que</span><span class="mf">.</span><span class="nf">pop</span><span class="p">();</span>
                <span class="k">if</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="p">(</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)){</span>
                    <span class="n">res</span><span class="mf">.</span><span class="nf">push_back</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
                <span class="p">}</span>
                <span class="k">if</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="n">que</span><span class="mf">.</span><span class="nf">push</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
                <span class="k">if</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span> <span class="n">que</span><span class="mf">.</span><span class="nf">push</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h2 id="637二叉树的层平均值"><span class="mr-2">637、二叉树的层平均值</span><a href="#637二叉树的层平均值" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>给定一个非空二叉树的根节点 <code class="language-plaintext highlighter-rouge">root</code> , 以数组的形式返回每一层节点的平均值。</p><p><strong>示例 ：</strong></p><div align="center"><img data-src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204201555469.jpeg" alt="img" style="zoom:60%;" data-proofer-ignore></div><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">root</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="kc">null</span><span class="p">,</span><span class="kc">null</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span>
<span class="n">输出</span><span class="err">：</span><span class="p">[</span><span class="mf">3.00000</span><span class="p">,</span><span class="mf">14.50000</span><span class="p">,</span><span class="mf">11.00000</span><span class="p">]</span>
</pre></table></code></div></div><p>层序遍历轻松完成，<strong>注意</strong>：先求一层所有节点的和，最后再作除法。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span> <span class="nf">averageOfLevels</span><span class="p">(</span><span class="nc">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">;</span>
        <span class="n">queue</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">*&gt;</span> <span class="n">que</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">root</span><span class="p">)</span> <span class="n">que</span><span class="mf">.</span><span class="nf">push</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
        <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">que</span><span class="mf">.</span><span class="nb">empty</span><span class="p">()){</span>
            <span class="n">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">que</span><span class="mf">.</span><span class="nf">size</span><span class="p">();</span>
            <span class="c1">// 记录当前层所有节点之和</span>
            <span class="n">double</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">for</span><span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
                <span class="nc">TreeNode</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">que</span><span class="mf">.</span><span class="nf">front</span><span class="p">();</span>
                <span class="n">que</span><span class="mf">.</span><span class="nf">pop</span><span class="p">();</span>
                <span class="n">sum</span> <span class="o">+=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span>
                <span class="k">if</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="n">que</span><span class="mf">.</span><span class="nf">push</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
                <span class="k">if</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span> <span class="n">que</span><span class="mf">.</span><span class="nf">push</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="c1">// 记录当前行的平均值</span>
            <span class="n">res</span><span class="mf">.</span><span class="nf">push_back</span><span class="p">(</span><span class="n">sum</span> <span class="o">/</span> <span class="n">size</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h2 id="二叉树的所有路径"><span class="mr-2">二叉树的所有路径</span><a href="#二叉树的所有路径" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><strong>257、二叉树的所有路径</strong></p><p>给你一个二叉树的根节点 <code class="language-plaintext highlighter-rouge">root</code> ，按 <strong>任意顺序</strong> ，返回所有从根节点到叶子节点的路径。</p><p><strong>叶子节点</strong> 是指没有子节点的节点。</p><p><strong>示例：</strong></p><div align="center"><img data-src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204202033263.jpeg" alt="img" style="zoom:50%;" data-proofer-ignore></div><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">root</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="kc">null</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="n">输出</span><span class="err">：</span><span class="p">[</span><span class="s2">"1-&gt;2-&gt;5"</span><span class="p">,</span><span class="s2">"1-&gt;3"</span><span class="p">]</span>
</pre></table></code></div></div><p>遍历二叉树，这道题和 ⌈<strong>515、在每个树行中找最大值</strong>⌋ 在思路上很相似——回溯，遍历函数 <code class="language-plaintext highlighter-rouge">traverse </code>的参数中还需要加入路径 <code class="language-plaintext highlighter-rouge">path</code>。再说的通俗一点儿就是，左右子树都需要对路径<code class="language-plaintext highlighter-rouge">path</code>进行操作，所以左子树操作完需要<strong>回溯</strong>，右子树才能再操作，不然右子树操作的就是左子树操作完的结果。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="c1">// 记录所有从根节点到叶子节点的路径</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">;</span>
	<span class="n">string</span> <span class="n">path</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="nf">binaryTreePaths</span><span class="p">(</span><span class="nc">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 记录 traverse 函数递归时的路径</span>
        <span class="nf">traverse</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="n">void</span> <span class="nf">traverse</span><span class="p">(</span><span class="nc">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="n">string</span> <span class="n">path</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
        <span class="n">path</span> <span class="o">+=</span> <span class="nf">to_string</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
        <span class="c1">//遍历到叶子节点，路径path加入res数组</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">){</span>
            <span class="n">res</span><span class="mf">.</span><span class="nf">push_back</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="nf">traverse</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">path</span> <span class="o">+</span> <span class="s2">"-&gt;"</span><span class="p">);</span>
        <span class="nf">traverse</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">path</span> <span class="o">+</span> <span class="s2">"-&gt;"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h1 id="最近公共祖先">最近公共祖先</h1><p>何为最近公共祖先呢？</p><p><strong>如果一个节点能够在它的左右子树中分别找到<code class="language-plaintext highlighter-rouge">p</code>和<code class="language-plaintext highlighter-rouge">q</code>，则该节点为<code class="language-plaintext highlighter-rouge">LCA</code>节点</strong>。</p><p>先来实现一个简单的算法：输入一棵<strong>没有重复元素</strong>的二叉树根节点<code class="language-plaintext highlighter-rouge">root</code>和目标值<code class="language-plaintext highlighter-rouge">val1</code>，<code class="language-plaintext highlighter-rouge">val2</code>，写一个函数寻找树中值为<code class="language-plaintext highlighter-rouge">val1</code><strong>或</strong><code class="language-plaintext highlighter-rouge">val2</code>的节点。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="c1">//定义：在以 root 为根的二叉树中寻找值为 val1 或 val2 的节点</span>
<span class="nc">TreeNode</span><span class="o">*</span> <span class="nf">find</span><span class="p">(</span><span class="nc">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="n">int</span> <span class="n">val1</span><span class="p">,</span> <span class="n">int</span> <span class="n">val2</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="k">return</span> <span class="n">nullptr</span><span class="p">;</span>
    <span class="c1">// 前序位置，在每一个节点处判断</span>
    <span class="k">if</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">==</span> <span class="n">val1</span> <span class="o">||</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">==</span> <span class="n">val2</span><span class="p">)</span> <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
    <span class="c1">//左右子树寻找</span>
    <span class="nc">TreeNode</span><span class="o">*</span> <span class="n">left</span> <span class="o">=</span> <span class="nf">find</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">val1</span><span class="p">,</span> <span class="n">val2</span><span class="p">);</span>
    <span class="nc">TreeNode</span><span class="o">*</span> <span class="n">right</span> <span class="o">=</span> <span class="nf">find</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">val1</span><span class="p">,</span> <span class="n">val2</span><span class="p">);</span>
    <span class="c1">// 后序位置，已经知道左右子树是否存在目标值</span>
	<span class="k">return</span> <span class="n">left</span> <span class="o">!=</span> <span class="n">nullptr</span> <span class="o">?</span> <span class="n">left</span> <span class="o">:</span> <span class="n">right</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p><strong>最近公共祖先系列问题的解法都是把这个函数作为框架的</strong>。</p><h2 id="236二叉树的最近公共祖先"><span class="mr-2">236、二叉树的最近公共祖先</span><a href="#236二叉树的最近公共祖先" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>给你输入一棵<strong>不含重复值</strong>的二叉树，以及<strong>存在于树中的</strong>两个节点<code class="language-plaintext highlighter-rouge">p</code>和<code class="language-plaintext highlighter-rouge">q</code>，请你计算<code class="language-plaintext highlighter-rouge">p</code>和<code class="language-plaintext highlighter-rouge">q</code>的最近公共祖先节点。</p><p>最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。</p><p><strong>示例：</strong></p><div align="center"><img data-src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204241139188.jpg" alt="640" style="zoom:40%;" data-proofer-ignore></div><div align="center"><img data-src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204241140957.jpg" alt="640 (1)" style="zoom:40%;" data-proofer-ignore></div><p>在<code class="language-plaintext highlighter-rouge">find</code>函数的后序位置，如果发现<code class="language-plaintext highlighter-rouge">left</code>和<code class="language-plaintext highlighter-rouge">right</code>都非空，就说明当前节点是<code class="language-plaintext highlighter-rouge">LCA</code>节点，即解决了第一种情况；</p><p>在<code class="language-plaintext highlighter-rouge">find</code>函数的前序位置，如果找到一个值为<code class="language-plaintext highlighter-rouge">val1</code>或<code class="language-plaintext highlighter-rouge">val2</code>的节点则直接返回，恰好解决了第二种情况。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="nc">TreeNode</span><span class="o">*</span> <span class="nf">lowestCommonAncestor</span><span class="p">(</span><span class="nc">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="nc">TreeNode</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="nc">TreeNode</span><span class="o">*</span> <span class="n">q</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nf">find</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">// 在二叉树中寻找 val1 和 val2 的最近公共祖先节点</span>
    <span class="nc">TreeNode</span><span class="o">*</span> <span class="nf">find</span><span class="p">(</span><span class="nc">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="n">int</span> <span class="n">val1</span><span class="p">,</span> <span class="n">int</span> <span class="n">val2</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="k">return</span> <span class="n">nullptr</span><span class="p">;</span>
        <span class="c1">// 前序位置，在每一个节点处判断，遇到目标值立即返回</span>
        <span class="k">if</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">==</span> <span class="n">val1</span> <span class="o">||</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">==</span> <span class="n">val2</span><span class="p">)</span> <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
        <span class="c1">//左右子树寻找</span>
        <span class="nc">TreeNode</span><span class="o">*</span> <span class="n">left</span> <span class="o">=</span> <span class="nf">find</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">val1</span><span class="p">,</span> <span class="n">val2</span><span class="p">);</span>
        <span class="nc">TreeNode</span><span class="o">*</span> <span class="n">right</span> <span class="o">=</span> <span class="nf">find</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">val1</span><span class="p">,</span> <span class="n">val2</span><span class="p">);</span>
        <span class="c1">// 后序位置，已经知道左右子树是否存在目标值</span>
        <span class="k">if</span><span class="p">(</span><span class="n">left</span> <span class="o">&amp;&amp;</span> <span class="n">right</span><span class="p">)</span> <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">left</span> <span class="o">!=</span> <span class="n">nullptr</span> <span class="o">?</span> <span class="n">left</span> <span class="o">:</span> <span class="n">right</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><p>因为题目说了<code class="language-plaintext highlighter-rouge">p</code>和<code class="language-plaintext highlighter-rouge">q</code>一定存在于二叉树中(这点很重要），所以即便我们遇到<code class="language-plaintext highlighter-rouge">q</code>就直接返回，根本没遍历到<code class="language-plaintext highlighter-rouge">p</code>，也依然可以断定<code class="language-plaintext highlighter-rouge">p</code>在<code class="language-plaintext highlighter-rouge">q</code>底下，<code class="language-plaintext highlighter-rouge">q</code>就是<code class="language-plaintext highlighter-rouge">LCA</code>节点。</p><h2 id="1676二叉树的最近公共祖先-iv"><span class="mr-2">1676、二叉树的最近公共祖先 IV</span><a href="#1676二叉树的最近公共祖先-iv" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>给定一棵<a href="https://so.csdn.net/so/search?q=二叉树&amp;spm=1001.2101.3001.7020">二叉树</a>的根节点 <code class="language-plaintext highlighter-rouge">root </code>和 TreeNode 类对象的数组（列表） <code class="language-plaintext highlighter-rouge">nodes</code>，返回 <code class="language-plaintext highlighter-rouge">nodes </code>中所有节点的最近公共祖先（LCA）。数组（列表）中所有节点都<strong>存在于该二叉树中</strong>，且二叉树中所有节点的值都是互不相同的。</p><p><strong>示例 3:</strong></p><div align="center"><img data-src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204241156790.png" alt="在这里插入图片描述" style="zoom:100%;" data-proofer-ignore></div><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="o">:</span> <span class="n">root</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="kc">null</span><span class="p">,</span><span class="kc">null</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="n">nodes</span> <span class="o">=</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="n">输出</span><span class="o">:</span> <span class="mi">5</span>
<span class="n">解释</span><span class="o">:</span> <span class="n">节点</span> <span class="mi">7</span><span class="err">、</span><span class="mi">6</span><span class="err">、</span><span class="mi">2</span> <span class="n">和</span> <span class="mi">4</span> <span class="n">的最近公共祖先节点是</span> <span class="mi">5</span><span class="err">。</span>
</pre></table></code></div></div><p>依然给你输入一棵不含重复值的二叉树，但这次不是给你输入<code class="language-plaintext highlighter-rouge">p</code>和<code class="language-plaintext highlighter-rouge">q</code>两个节点了，而是给你输入一个包含若干节点的列表<code class="language-plaintext highlighter-rouge">nodes</code>（这些节点都存在于二叉树中），其实换汤不换药，还是使用这个框架。</p><p>为了高效地查找数组<code class="language-plaintext highlighter-rouge">nodes</code>中的元素，使用<strong>哈希表</strong>来装载数组元素，<code class="language-plaintext highlighter-rouge">unordered_set</code> 来实现。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
	<span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span> <span class="n">set</span><span class="p">;</span> 
    <span class="nc">TreeNode</span><span class="o">*</span> <span class="nf">lowestCommonAncestor</span><span class="p">(</span><span class="nc">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">*&gt;</span> <span class="o">&amp;</span><span class="n">nodes</span><span class="p">)</span> <span class="p">{</span>
    	<span class="k">for</span><span class="p">(</span><span class="nc">TreeNode</span><span class="o">*</span> <span class="n">node</span><span class="o">:</span> <span class="n">nodes</span><span class="p">){</span>
            <span class="n">set</span><span class="mf">.</span><span class="nf">insert</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nf">find</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="c1">// 在二叉树中寻找 val 的最近公共祖先节点</span>
    <span class="nc">TreeNode</span><span class="o">*</span> <span class="nf">find</span><span class="p">(</span><span class="nc">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="k">return</span> <span class="n">nullptr</span><span class="p">;</span>
        <span class="c1">// 前序位置，在每一个节点处判断，遇到目标值立即返回</span>
        <span class="k">if</span><span class="p">(</span><span class="n">set</span><span class="mf">.</span><span class="nb">count</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">))</span> <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
        <span class="c1">//左右子树寻找</span>
        <span class="nc">TreeNode</span><span class="o">*</span> <span class="n">left</span> <span class="o">=</span> <span class="nf">find</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
        <span class="nc">TreeNode</span><span class="o">*</span> <span class="n">right</span> <span class="o">=</span> <span class="nf">find</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
        <span class="c1">// 后序位置，已经知道左右子树是否存在目标值</span>
        <span class="k">if</span><span class="p">(</span><span class="n">left</span> <span class="o">&amp;&amp;</span> <span class="n">right</span><span class="p">)</span> <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">left</span> <span class="o">!=</span> <span class="n">nullptr</span> <span class="o">?</span> <span class="n">left</span> <span class="o">:</span> <span class="n">right</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><p>不过需要注意的是，这两道题的题目都明确告诉我们<strong>这些节点必定存在于二叉树中</strong>，如果没有这个前提条件，就需要修改代码了。</p><h2 id="1644二叉树的最近公共祖先-ii"><span class="mr-2">1644、二叉树的最近公共祖先 II</span><a href="#1644二叉树的最近公共祖先-ii" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>给定一棵二叉树的根节点 root，返回给定节点 p 和 q 的最近公共祖先（LCA）节点。如果 p 或 q 之一<strong>不存在于该二叉树中</strong>，返回 null。树中的每个节点值都是互不相同的。</p><p>在解决标准的最近公共祖先问题时，我们在<code class="language-plaintext highlighter-rouge">find</code>函数的前序位置有这样一段代码：</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="c1">// 前序位置</span>
<span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="mf">.</span><span class="n">val</span> <span class="o">==</span> <span class="n">val1</span> <span class="o">||</span> <span class="n">root</span><span class="mf">.</span><span class="n">val</span> <span class="o">==</span> <span class="n">val2</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 如果遇到目标值，直接返回</span>
    <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>因为<code class="language-plaintext highlighter-rouge">p</code>和<code class="language-plaintext highlighter-rouge">q</code>都存在于树中，所以这段代码恰好可以解决最近公共祖先的第二种情况：</p><div align="center"><img data-src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204241140957.jpg" alt="640 (1)" style="zoom:40%;" data-proofer-ignore></div><p>但对于这道题来说，<code class="language-plaintext highlighter-rouge">p</code>和<code class="language-plaintext highlighter-rouge">q</code>不一定存在于树中，所以不能遇到一个目标值就直接返回，而应该对二叉树进行<strong>完全搜索</strong>（遍历每一个节点），如果发现<code class="language-plaintext highlighter-rouge">p</code>或<code class="language-plaintext highlighter-rouge">q</code>不存在于树中，那么是不存在<code class="language-plaintext highlighter-rouge">LCA</code>的。</p><p>哪种写法能够对二叉树进行完全搜索呢？只需要<strong>把前序位置的判断逻辑放到后序位置</strong>即可：</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="nc">TreeNode</span> <span class="nf">find</span><span class="p">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="p">,</span> <span class="n">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 先去左右子树寻找</span>
    <span class="nc">TreeNode</span> <span class="n">left</span> <span class="o">=</span> <span class="nf">find</span><span class="p">(</span><span class="n">root</span><span class="mf">.</span><span class="n">left</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
    <span class="nc">TreeNode</span> <span class="n">right</span> <span class="o">=</span> <span class="nf">find</span><span class="p">(</span><span class="n">root</span><span class="mf">.</span><span class="n">right</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
    <span class="c1">// 后序位置，判断 root 是不是目标节点</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="mf">.</span><span class="n">val</span> <span class="o">==</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// root 不是目标节点，再去看看哪边的子树找到了</span>
    <span class="k">return</span> <span class="n">left</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">?</span> <span class="n">left</span> <span class="o">:</span> <span class="n">right</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>同时还要使用<code class="language-plaintext highlighter-rouge">bool</code>变量记录一下<code class="language-plaintext highlighter-rouge">p</code> 和 <code class="language-plaintext highlighter-rouge">q </code>是否存在于二叉树中，若有一个不存在，则返回NULL；若两者都存在，则找到了<code class="language-plaintext highlighter-rouge">LCA</code>。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span><span class="p">{</span>
    <span class="c1">// 用于记录 p 和 q 是否存在于二叉树中</span>
    <span class="n">bool</span> <span class="n">findP</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
    <span class="n">bool</span> <span class="n">findQ</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
    <span class="nc">TreeNode</span><span class="o">*</span> <span class="nf">lowestCommonAncestor</span><span class="p">(</span><span class="nc">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="nc">TreeNode</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="nc">TreeNode</span><span class="o">*</span> <span class="n">q</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">findP</span> <span class="o">||</span> <span class="o">!</span><span class="n">findQ</span><span class="p">)</span> <span class="k">return</span> <span class="n">nullptr</span><span class="p">;</span>
        <span class="c1">// p 和 q 都存在二叉树中，才有公共祖先</span>
        <span class="k">return</span> <span class="nf">find</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
	<span class="p">}</span>
	
	<span class="c1">// 在二叉树中寻找 val1 和 val2 的最近公共祖先节点</span>
	<span class="nc">TreeNode</span><span class="o">*</span> <span class="nf">find</span><span class="p">(</span><span class="nc">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="n">int</span> <span class="n">val1</span><span class="p">,</span> <span class="n">int</span> <span class="n">val2</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="k">return</span> <span class="n">nullptr</span><span class="p">;</span>
        <span class="nc">TreeNode</span><span class="o">*</span> <span class="n">left</span> <span class="o">=</span> <span class="nf">find</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">val1</span><span class="p">,</span> <span class="n">val2</span><span class="p">);</span>
        <span class="nc">TreeNode</span><span class="o">*</span> <span class="n">right</span> <span class="o">=</span> <span class="nf">find</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">val1</span><span class="p">,</span> <span class="n">val2</span><span class="p">);</span>
		<span class="c1">// 后序位置，判断当前节点是不是 LCA 节点</span>
        <span class="k">if</span><span class="p">(</span><span class="n">left</span> <span class="o">&amp;&amp;</span> <span class="n">right</span><span class="p">)</span> <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
        <span class="c1">// 后序位置，判断当前节点是不是目标值</span>
        <span class="k">if</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">==</span> <span class="n">val1</span> <span class="o">||</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">==</span> <span class="n">val2</span><span class="p">){</span>
            <span class="k">if</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">==</span> <span class="n">val1</span><span class="p">)</span> <span class="n">findP</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
            <span class="k">if</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">==</span> <span class="n">val2</span><span class="p">)</span> <span class="n">findQ</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">left</span> <span class="o">!=</span> <span class="n">nullptr</span> <span class="o">?</span> <span class="n">left</span> <span class="o">:</span> <span class="n">right</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h2 id="235二叉搜索树的最近公共祖先"><span class="mr-2">235、二叉搜索树的最近公共祖先</span><a href="#235二叉搜索树的最近公共祖先" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>输入一棵不含重复值的<strong>二叉搜索树</strong>，以及<strong>存在于树中</strong>的两个节点<code class="language-plaintext highlighter-rouge">p</code>和<code class="language-plaintext highlighter-rouge">q</code>，请计算<code class="language-plaintext highlighter-rouge">p</code>和<code class="language-plaintext highlighter-rouge">q</code>的最近公共祖先节点。</p><p>把之前的解法代码复制过来肯定也可以解决这道题，但没有用到 BST「<strong>左小右大</strong>」的性质，显然效率不是最高的。</p><p>在标准的最近公共祖先问题中，我们要在<strong>后序位置</strong>通过左右子树的搜索结果来判断当前节点是不是<code class="language-plaintext highlighter-rouge">LCA</code>：</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="nc">TreeNode</span> <span class="n">left</span> <span class="o">=</span> <span class="nf">find</span><span class="p">(</span><span class="n">root</span><span class="mf">.</span><span class="n">left</span><span class="p">,</span> <span class="n">val1</span><span class="p">,</span> <span class="n">val2</span><span class="p">);</span>
<span class="nc">TreeNode</span> <span class="n">right</span> <span class="o">=</span> <span class="nf">find</span><span class="p">(</span><span class="n">root</span><span class="mf">.</span><span class="n">right</span><span class="p">,</span> <span class="n">val1</span><span class="p">,</span> <span class="n">val2</span><span class="p">);</span>

<span class="c1">// 后序位置，判断当前节点是不是 LCA 节点</span>
<span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>但对于 BST 来说，根本不需要老老实实去遍历子树，由于 BST 左小右大的性质，<strong>将当前节点的值与<code class="language-plaintext highlighter-rouge">val1</code>和<code class="language-plaintext highlighter-rouge">val2</code>作对比</strong>，即可判断当前节点是不是<code class="language-plaintext highlighter-rouge">LCA</code>：</p><ul><li><p>假设<code class="language-plaintext highlighter-rouge">val1 &lt; val2</code>，那么<code class="language-plaintext highlighter-rouge">val1 &lt;= root-&gt;val &lt;= val2</code>，则说明当前节点就是<code class="language-plaintext highlighter-rouge">LCA</code>；</p><li><p>若<code class="language-plaintext highlighter-rouge">root-&gt;val</code>比<code class="language-plaintext highlighter-rouge">val1</code>还小，则需要去值更大的右子树寻找<code class="language-plaintext highlighter-rouge">LCA</code>；</p><li><p>若<code class="language-plaintext highlighter-rouge">root-&gt;val</code>比<code class="language-plaintext highlighter-rouge">val2</code>还大，则需要去值更小的左子树寻找<code class="language-plaintext highlighter-rouge">LCA</code>。</p></ul><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="nc">TreeNode</span><span class="o">*</span> <span class="nf">lowestCommonAncestor</span><span class="p">(</span><span class="nc">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="nc">TreeNode</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="nc">TreeNode</span><span class="o">*</span> <span class="n">q</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 保证 val1 较小，val2 较大</span>
        <span class="n">int</span> <span class="n">val1</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
        <span class="n">int</span> <span class="n">val2</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
        <span class="k">return</span> <span class="nf">find</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">val1</span><span class="p">,</span> <span class="n">val2</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">// 在 BST 中寻找 val1 和 val2 的最近公共祖先节点</span>
	<span class="nc">TreeNode</span><span class="o">*</span> <span class="nf">find</span><span class="p">(</span><span class="nc">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="n">int</span> <span class="n">val1</span><span class="p">,</span> <span class="n">int</span> <span class="n">val2</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="k">return</span> <span class="n">nullptr</span><span class="p">;</span>
        <span class="c1">// 当前节点太大，去左子树找</span>
        <span class="k">if</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">val2</span><span class="p">)</span> <span class="k">return</span> <span class="nf">find</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">val1</span><span class="p">,</span> <span class="n">val2</span><span class="p">);</span>
        <span class="c1">// 当前节点太小，去右子树找</span>
        <span class="k">if</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">val1</span><span class="p">)</span> <span class="k">return</span> <span class="nf">find</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">val1</span><span class="p">,</span><span class="n">val2</span><span class="p">);</span>
        <span class="c1">// val1 &lt;= root.val &lt;= val2</span>
    	<span class="c1">// 则当前节点就是最近公共祖先</span>
        <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h2 id="1650二叉树的最近公共祖先-iii"><span class="mr-2">1650、二叉树的最近公共祖先 III</span><a href="#1650二叉树的最近公共祖先-iii" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>给定一棵二叉树中的两个节点 <code class="language-plaintext highlighter-rouge">p</code> 和 <code class="language-plaintext highlighter-rouge">q</code>，返回它们的最近公共祖先节点（LCA）。每个节点都包含其父节点的引用（指针），<code class="language-plaintext highlighter-rouge">Node </code>的定义如下：</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Node</span> <span class="p">{</span>
    <span class="n">int</span> <span class="n">val</span><span class="p">;</span>
    <span class="nc">Node</span><span class="o">*</span> <span class="n">left</span><span class="p">;</span>
    <span class="nc">Node</span><span class="o">*</span> <span class="n">right</span><span class="p">;</span>
    <span class="nc">Node</span><span class="o">*</span> <span class="k">parent</span><span class="p">;</span>
<span class="p">};</span>
</pre></table></code></div></div><p><strong>这道题其实不是公共祖先的问题，而是单链表相交的问题</strong>，你把<code class="language-plaintext highlighter-rouge">parent</code>指针想象成单链表的<code class="language-plaintext highlighter-rouge">next</code>指针，题目就变成了：给你输入两个单链表的头结点<code class="language-plaintext highlighter-rouge">p</code>和<code class="language-plaintext highlighter-rouge">q</code>，这两个单链表必然会相交，请你返回相交点。</p><div align="center"><img data-src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204241502457.png" alt="image-20220424150259400" style="zoom:60%;" data-proofer-ignore></div><p><strong>解法一</strong>：双指针法</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="nc">Node</span><span class="o">*</span> <span class="nf">lowestCommonAncestor</span><span class="p">(</span><span class="nc">Node</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="nc">Node</span> <span class="o">*</span> <span class="n">q</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// 链表双指针技巧</span>
    	<span class="n">node</span><span class="o">*</span> <span class="n">a</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
        <span class="n">node</span><span class="o">*</span> <span class="n">b</span> <span class="o">=</span> <span class="n">q</span><span class="p">;</span>
        <span class="k">while</span><span class="p">(</span><span class="n">a</span> <span class="o">!=</span> <span class="n">b</span><span class="p">){</span>
            <span class="c1">// a 走一步，如果走到根节点，转到 q 节点</span>
            <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">a</span><span class="p">)</span> <span class="n">a</span> <span class="o">=</span> <span class="n">q</span><span class="p">;</span>
            <span class="k">else</span> <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">-&gt;</span><span class="k">parent</span><span class="p">;</span>
            <span class="c1">// b 走一步，如果走到根节点，转到 p 节点</span>
            <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">b</span><span class="p">)</span> <span class="n">b</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
            <span class="k">else</span> <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="k">parent</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
    <span class="p">};</span>
</pre></table></code></div></div><p><strong>解法二</strong>：哈希表</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="nc">Node</span><span class="o">*</span> <span class="nf">lowestCommonAncestor</span><span class="p">(</span><span class="nc">Node</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="nc">Node</span> <span class="o">*</span> <span class="n">q</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span> <span class="n">sign</span><span class="p">;</span>
        <span class="c1">// 将节点p的元素存入哈希表</span>
        <span class="k">while</span><span class="p">(</span><span class="n">p</span><span class="o">!=</span><span class="kc">NULL</span><span class="p">){</span>
            <span class="n">sign</span><span class="mf">.</span><span class="nf">insert</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
            <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="k">parent</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// 节点q的元素在哈希表中查询，第一次出现的即LCA</span>
        <span class="k">while</span><span class="p">(</span><span class="n">q</span><span class="o">!=</span><span class="kc">NULL</span><span class="p">){</span>
            <span class="k">if</span><span class="p">(</span><span class="n">sign</span><span class="mf">.</span><span class="nb">count</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">)){</span>
                <span class="k">return</span> <span class="n">q</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">q</span><span class="o">=</span><span class="n">q</span><span class="o">-&gt;</span><span class="k">parent</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="kc">NULL</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h1 id="二叉搜索树">二叉搜索树</h1><p>二叉搜索树（Binary Search Tree，后文简写 BST）有如下特性：</p><p>1、对于 BST 的每一个节点 <code class="language-plaintext highlighter-rouge">node</code>，左子树节点的值都比 <code class="language-plaintext highlighter-rouge">node</code> 的值要小，右子树节点的值都比 <code class="language-plaintext highlighter-rouge">node</code> 的值大。</p><p>2、对于 BST 的每一个节点 <code class="language-plaintext highlighter-rouge">node</code>，它的左侧子树和右侧子树都是 BST。</p><p>二叉搜索树并不算复杂，它可以算是数据结构领域的半壁江山，直接基于 BST 的数据结构有<strong>AVL 树</strong>，<strong>红黑树</strong>等等，拥有了自平衡性质，可以提供 <strong>logN</strong>级别的增删查改效率；还有 <strong>B+</strong> 树，线段树等结构都是基于 BST 的思想来设计的。</p><p>从做算法题的角度来看 BST，除了它的定义，还有一个重要的性质：<strong>BST 的中序遍历结果是有序的（升序）</strong>。</p><p>也就是说，如果输入一棵 BST，以下代码可以将 BST 中每个节点的值升序打印出来：</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="n">void</span> <span class="nf">traverse</span><span class="p">(</span><span class="nc">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
    <span class="nf">traverse</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
    <span class="c1">// 这里添加中序遍历代码</span>
    <span class="nf">traverse</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>那么根据这个性质，我们来做两道算法题。</p><p>BST 相关的问题，要么利用 <strong>BST 左小右大</strong>的特性提升算法效率，要么利用<strong>中序遍历</strong>的特性满足题目的要求。</p><h2 id="230-二叉搜索树中第k小的元素"><span class="mr-2">230. 二叉搜索树中第K小的元素</span><a href="#230-二叉搜索树中第k小的元素" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>给定一个二叉搜索树的根节点 <code class="language-plaintext highlighter-rouge">root</code> ，和一个整数 <code class="language-plaintext highlighter-rouge">k</code> ，请你设计一个算法查找其中第 <code class="language-plaintext highlighter-rouge">k</code> 个最小元素（从 1 开始计数）。</p><p><strong>示例：</strong></p><div align="center"><img data-src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204251501802.jpeg" alt="img" style="zoom:50%;" data-proofer-ignore></div><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">root</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="kc">null</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">1</span>
</pre></table></code></div></div><p>最直接的思路就是<strong>升序排序</strong>，然后找第 <code class="language-plaintext highlighter-rouge">k</code> 个元素，BST 的中序遍历其实就是升序排序的结果。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="c1">// 记录当前元素的排名</span>
    <span class="n">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">int</span> <span class="n">res</span><span class="p">;</span>
    <span class="n">int</span> <span class="nf">kthSmallest</span><span class="p">(</span><span class="nc">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="n">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 利用 BST 的中序遍历特性</span>
        <span class="nf">traverse</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">void</span> <span class="nf">traverse</span><span class="p">(</span><span class="nc">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="n">int</span> <span class="n">k</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
        <span class="nf">traverse</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>
        <span class="cm">/* 中序遍历代码位置 */</span>
        <span class="n">count</span><span class="o">++</span><span class="p">;</span>
        <span class="c1">// 找到第 k 小的元素</span>
        <span class="k">if</span><span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="n">k</span><span class="p">){</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="nf">traverse</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h2 id="538-把二叉搜索树转换为累加树"><span class="mr-2">538. 把二叉搜索树转换为累加树</span><a href="#538-把二叉搜索树转换为累加树" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>给出二叉 <strong>搜索</strong> 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 <code class="language-plaintext highlighter-rouge">node</code> 的新值等于原树中大于或等于 <code class="language-plaintext highlighter-rouge">node.val</code> 的值之和。</p><p><strong>示例：</strong></p><div align="center"><img data-src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204251517895.png" alt="img" style="zoom:50%;" data-proofer-ignore></div><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="kc">null</span><span class="p">,</span><span class="kc">null</span><span class="p">,</span><span class="kc">null</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="kc">null</span><span class="p">,</span><span class="kc">null</span><span class="p">,</span><span class="kc">null</span><span class="p">,</span><span class="mi">8</span><span class="p">]</span>
<span class="n">输出</span><span class="err">：</span><span class="p">[</span><span class="mi">30</span><span class="p">,</span><span class="mi">36</span><span class="p">,</span><span class="mi">21</span><span class="p">,</span><span class="mi">36</span><span class="p">,</span><span class="mi">35</span><span class="p">,</span><span class="mi">26</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="kc">null</span><span class="p">,</span><span class="kc">null</span><span class="p">,</span><span class="kc">null</span><span class="p">,</span><span class="mi">33</span><span class="p">,</span><span class="kc">null</span><span class="p">,</span><span class="kc">null</span><span class="p">,</span><span class="kc">null</span><span class="p">,</span><span class="mi">8</span><span class="p">]</span>
</pre></table></code></div></div><p>BST 的中序遍历代码可以升序打印节点的值，那降序打印节点的值怎么办呢？</p><p>只要把递归顺序改一下就行了：</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="n">void</span> <span class="nf">traverse</span><span class="p">(</span><span class="nc">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
    <span class="nf">traverse</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
    <span class="c1">// 这里添加中序遍历代码</span>
    <span class="nf">traverse</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>这段代码可以降序打印 BST 节点的值，如果维护一个外部累加变量 <code class="language-plaintext highlighter-rouge">sum</code>，然后把 <code class="language-plaintext highlighter-rouge">sum</code> 赋值给 BST 中的每一个节点，不就将 BST 转化成累加树了吗？</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="c1">//记录累加和</span>
    <span class="n">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="nc">TreeNode</span><span class="o">*</span> <span class="nf">convertBST</span><span class="p">(</span><span class="nc">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">traverse</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">void</span> <span class="nf">traverse</span><span class="p">(</span><span class="nc">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
        <span class="nf">traverse</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
        <span class="c1">// 维护累加和</span>
        <span class="n">sum</span> <span class="o">+=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span>
        <span class="c1">// 将 BST 转化成累加树</span>
        <span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">=</span> <span class="n">sum</span><span class="p">;</span>
        <span class="nf">traverse</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h2 id="530-二叉搜索树的最小绝对差"><span class="mr-2">530. 二叉搜索树的最小绝对差</span><a href="#530-二叉搜索树的最小绝对差" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>给你一个二叉搜索树的根节点 <code class="language-plaintext highlighter-rouge">root</code> ，返回 <strong>树中任意两不同节点值之间的最小差值</strong> 。</p><p>差值是一个正数，其数值等于两值之差的绝对值。</p><p><strong>示例：</strong></p><div align="center"><img data-src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204271647211.jpeg" alt="img" style="zoom:50%;" data-proofer-ignore></div><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">root</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">1</span>
</pre></table></code></div></div><p>中序遍历会有序遍历 BST 的节点，遍历过程中计算最小差值即可。因为要做差，所以需要维护一个<code class="language-plaintext highlighter-rouge">pre</code>指针来记录上一个节点。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">int</span> <span class="n">res</span> <span class="o">=</span> <span class="no">INT_MAX</span><span class="p">;</span>
    <span class="nc">TreeNode</span><span class="o">*</span> <span class="n">pre</span> <span class="o">=</span> <span class="n">nullptr</span><span class="p">;</span>
    <span class="n">int</span> <span class="nf">getMinimumDifference</span><span class="p">(</span><span class="nc">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">traverse</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">void</span> <span class="nf">traverse</span><span class="p">(</span><span class="nc">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
        <span class="nf">traverse</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
        <span class="c1">//这里的if(pre)判断条件不能掉</span>
        <span class="k">if</span><span class="p">(</span><span class="n">pre</span><span class="p">)</span> <span class="n">res</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">-</span> <span class="n">pre</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
        <span class="n">pre</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
        <span class="nf">traverse</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h2 id="501-二叉搜索树中的众数"><span class="mr-2">501. 二叉搜索树中的众数</span><a href="#501-二叉搜索树中的众数" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>给你一个含重复值的二叉搜索树（BST）的根节点 <code class="language-plaintext highlighter-rouge">root</code> ，找出并返回 BST 中的所有众数（即出现频率最高的元素）。</p><p>如果树中有不止一个众数，可以按 <strong>任意顺序</strong> 返回。</p><p><strong>示例：</strong></p><div align="center"><img data-src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204271843086.jpeg" alt="img" style="zoom:50%;" data-proofer-ignore></div><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">root</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="kc">null</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="n">输出</span><span class="err">：</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
</pre></table></code></div></div><p>首先，需要统计节点出现的频率，维护一个<code class="language-plaintext highlighter-rouge">pre</code>指针：</p><ul><li>若<code class="language-plaintext highlighter-rouge">pre</code>为空，则为第一个节点；<li>若<code class="language-plaintext highlighter-rouge">pre-&gt;val == root-&gt;val</code>，则频率加1；<li>若<code class="language-plaintext highlighter-rouge">pre-&gt;val != root-&gt;val</code>，则出现新的节点，频率为1；</ul><p>然后，与最大频率作比较：</p><ul><li>若频率等于最大频率，节点加入数组；<li>若频率大于最大频率，则更新最大数值，清空数组后加入该节点；</ul><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">int</span> <span class="n">maxCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="nc">TreeNode</span><span class="o">*</span> <span class="n">pre</span> <span class="o">=</span> <span class="n">nullptr</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">;</span>

    <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span> <span class="nf">findMode</span><span class="p">(</span><span class="nc">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">traverse</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">void</span> <span class="nf">traverse</span><span class="p">(</span><span class="nc">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
        <span class="nf">traverse</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
        <span class="c1">// 统计root节点出现的频率</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">pre</span><span class="p">)</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>						<span class="c1">//第一个节点</span>
        <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">pre</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">==</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">)</span> <span class="n">count</span><span class="o">++</span><span class="p">;</span>	<span class="c1">//与前一个节点值相等</span>
        <span class="k">else</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>							<span class="c1">//与前一个节点值不等</span>
        <span class="n">pre</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
        
        <span class="c1">// 和最大频率作比较，判断是否加入数组</span>
        <span class="k">if</span><span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="n">maxCount</span><span class="p">)</span> <span class="n">res</span><span class="mf">.</span><span class="nf">push_back</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
        <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">maxCount</span><span class="p">){</span>
            <span class="n">maxCount</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
            <span class="n">res</span><span class="mf">.</span><span class="nf">clear</span><span class="p">();</span>
            <span class="n">res</span><span class="mf">.</span><span class="nf">push_back</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="nf">traverse</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h2 id="剑指-offer-36-二叉搜索树与双向链表"><span class="mr-2">剑指 Offer 36. 二叉搜索树与双向链表</span><a href="#剑指-offer-36-二叉搜索树与双向链表" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。</p><p>以下面的二叉搜索树为例：</p><div align="center"><img data-src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204301207350.png" alt="img" style="zoom:40%;" data-proofer-ignore></div><p>我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。</p><p>下图展示了上面的二叉搜索树转化成的链表。“head” 表示指向链表中有最小元素的节点。</p><p><img data-src="https://assets.leetcode.com/uploads/2018/10/12/bstdllreturndll.png" alt="img" data-proofer-ignore></p><p>特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。</p><ol><li><strong>排序链表：</strong> 节点应从小到大排序，因此应使用 <strong>中序遍历</strong> “从小到大”访问树的节点。<li><strong>双向链表：</strong> 在构建相邻节点的引用关系时，设前驱节点 <code class="language-plaintext highlighter-rouge">pre</code> 和当前节点 <code class="language-plaintext highlighter-rouge">cur</code> ，不仅应构建 <code class="language-plaintext highlighter-rouge">pre-&gt;right = cur</code> ，也应构建 <code class="language-plaintext highlighter-rouge">cur-&gt;left = pre</code> 。<li><strong>循环链表：</strong> 设链表头节点 <code class="language-plaintext highlighter-rouge">head</code> 和尾节点 <code class="language-plaintext highlighter-rouge">tail</code> ，则应构建 <code class="language-plaintext highlighter-rouge">head-&gt;left = tail</code> 和 <code class="language-plaintext highlighter-rouge">tail-&gt;right = head</code> 。</ol><div align="center"><img data-src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204301210130.png" alt="Picture1.png" style="zoom:50%;" data-proofer-ignore></div><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="nc">Node</span><span class="o">*</span> <span class="n">head</span> <span class="o">=</span> <span class="kc">NULL</span><span class="p">;</span>
    <span class="nc">Node</span><span class="o">*</span> <span class="n">pre</span> <span class="o">=</span> <span class="kc">NULL</span><span class="p">;</span>
    <span class="nc">Node</span><span class="o">*</span> <span class="nf">treeToDoublyList</span><span class="p">(</span><span class="nc">Node</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="k">return</span> <span class="n">head</span><span class="p">;</span>
        <span class="nf">traverse</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
        <span class="n">head</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">pre</span><span class="p">;</span>
        <span class="n">pre</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">head</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">void</span> <span class="nf">traverse</span><span class="p">(</span><span class="nc">Node</span><span class="o">*</span> <span class="n">root</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
        <span class="nf">traverse</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span><span class="n">pre</span><span class="p">){</span>
            <span class="n">pre</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
            <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">pre</span><span class="p">;</span>
        <span class="p">}</span><span class="k">else</span><span class="p">{</span>
            <span class="n">head</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">pre</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
        <span class="nf">traverse</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><hr /><p>BST 的完整定义如下：</p><p>1、BST 中任意一个节点的左子树所有节点的值都小于该节点的值，右子树所有节点的值都大于该节点的值。</p><p>2、BST 中任意一个节点的左右子树都是 BST。</p><p>有了 BST 的这种特性，就可以在二叉树中做类似<strong>二分搜索</strong>的操作，搜索一个元素的效率很高。</p><p>比如下面这就是一棵合法的二叉树：</p><div align="center"><img data-src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204251601659.png" alt="img" style="zoom:18%;" data-proofer-ignore></div><p>对于 BST 相关的问题，经常会看到类似下面这样的代码逻辑：</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="n">void</span> <span class="nf">BST</span><span class="p">(</span><span class="nc">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="n">int</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">==</span> <span class="n">target</span><span class="p">)</span>
        <span class="c1">// 找到目标，做点什么</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">target</span><span class="p">)</span> 
        <span class="nf">BST</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">target</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">target</span><span class="p">)</span>
        <span class="nf">BST</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">target</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>这个代码框架其实和二叉树的遍历框架差不多，无非就是利用了 BST <strong>左小右大</strong>的特性而已。</p><h2 id="98-验证二叉搜索树"><span class="mr-2">98. 验证二叉搜索树</span><a href="#98-验证二叉搜索树" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>给你一个二叉树的根节点 <code class="language-plaintext highlighter-rouge">root</code> ，判断其是否是一个有效的二叉搜索树。</p><p><strong>示例：</strong></p><div align="center"><img data-src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204251606314.jpeg" alt="img" style="zoom:50%;" data-proofer-ignore></div><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">root</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="n">输出</span><span class="err">：</span><span class="kc">true</span>
</pre></table></code></div></div><p><strong>解法一</strong>：中序遍历，需要比较节点和上一个节点的大小关系，所以引入指针<code class="language-plaintext highlighter-rouge">pre</code>。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="nc">TreeNode</span><span class="o">*</span> <span class="n">pre</span> <span class="o">=</span> <span class="n">nullptr</span><span class="p">;</span> <span class="c1">//记录前一个节点</span>
    <span class="n">bool</span> <span class="nf">isValidBST</span><span class="p">(</span><span class="nc">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 二叉搜索树也可以为空</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
        <span class="n">bool</span> <span class="n">left</span> <span class="o">=</span> <span class="nf">isValidBST</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span><span class="n">pre</span> <span class="o">&amp;&amp;</span> <span class="n">pre</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&gt;=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">)</span> <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
        <span class="n">pre</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
        <span class="n">bool</span> <span class="n">right</span> <span class="o">=</span> <span class="nf">isValidBST</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">left</span> <span class="o">&amp;&amp;</span> <span class="n">right</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><p><strong>解法二</strong>：二叉树定义，左小右大</p><p>这里有一个陷阱：BST 不是左小右大么，那我只要检查 <code class="language-plaintext highlighter-rouge">root-&gt;val &gt; root-&gt;left-&gt;val</code> 且 <code class="language-plaintext highlighter-rouge">root-&gt;val &lt; root-&gt;right-&gt;val</code> 不就行了？</p><p>这样是<strong>错误</strong>的，因为 BST<strong>左小右大</strong>的特性是指 <code class="language-plaintext highlighter-rouge">root-&gt;val</code> 要比左子树的所有节点都更大，要比右子树的所有节点都小，只检查左右两个子节点当然是不够的。</p><p><strong>正确解法</strong>是通过使用辅助函数，增加函数参数列表，在参数中携带额外信息，将这种约束传递给子树的所有节点，这也是二叉搜索树算法的一个小技巧吧。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">bool</span> <span class="nf">isValidBST</span><span class="p">(</span><span class="nc">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nf">valid</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">nullptr</span><span class="p">,</span> <span class="n">nullptr</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">bool</span> <span class="nf">valid</span><span class="p">(</span><span class="nc">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="nc">TreeNode</span><span class="o">*</span> <span class="n">min</span><span class="p">,</span> <span class="nc">TreeNode</span><span class="o">*</span> <span class="n">max</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">min</span> <span class="o">&amp;&amp;</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&lt;=</span> <span class="n">min</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">)</span> <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">max</span> <span class="o">&amp;&amp;</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&gt;=</span> <span class="n">max</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">)</span> <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
        <span class="k">return</span> <span class="nf">valid</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">min</span><span class="p">,</span> <span class="n">root</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nf">valid</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">max</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h2 id="669-修剪二叉搜索树"><span class="mr-2">669. 修剪二叉搜索树</span><a href="#669-修剪二叉搜索树" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>给你二叉搜索树的根节点 <code class="language-plaintext highlighter-rouge">root</code> ，同时给定最小边界<code class="language-plaintext highlighter-rouge">low</code> 和最大边界 <code class="language-plaintext highlighter-rouge">high</code>。通过修剪二叉搜索树，使得所有节点的值在<code class="language-plaintext highlighter-rouge">[low, high]</code>中。修剪树 <strong>不应该</strong> 改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。</p><p><strong>示例：</strong></p><div align="center"><img data-src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204271918176.jpeg" alt="img" style="zoom:40%;" data-proofer-ignore></div><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">root</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">low</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">high</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">输出</span><span class="err">：</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="kc">null</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
</pre></table></code></div></div><p>明确了递归函数的定义之后进行思考，如果一个节点的值没有落在 <code class="language-plaintext highlighter-rouge">[lo, hi]</code> 中，有两种情况：</p><p>1、<code class="language-plaintext highlighter-rouge">root.val &lt; lo</code>，这种情况下 <code class="language-plaintext highlighter-rouge">root</code> 节点本身和 <code class="language-plaintext highlighter-rouge">root</code> 的左子树全都是小于 <code class="language-plaintext highlighter-rouge">lo</code> 的，都需要被剪掉，返回<code class="language-plaintext highlighter-rouge">root</code> 的右子树；</p><p>2、<code class="language-plaintext highlighter-rouge">root.val &gt; hi</code>，这种情况下 <code class="language-plaintext highlighter-rouge">root</code> 节点本身和 <code class="language-plaintext highlighter-rouge">root</code> 的右子树全都是大于 <code class="language-plaintext highlighter-rouge">hi</code> 的，都需要被剪掉， 返回<code class="language-plaintext highlighter-rouge">root</code> 的左子树；</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="c1">// 定义：删除 BST 中小于 low 和大于 high 的所有节点，返回结果 BST</span>
    <span class="nc">TreeNode</span><span class="o">*</span> <span class="nf">trimBST</span><span class="p">(</span><span class="nc">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="n">int</span> <span class="n">low</span><span class="p">,</span> <span class="n">int</span> <span class="n">high</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
        <span class="c1">// 直接返回 root.right，等于删除 root 以及 root 的左子树</span>
        <span class="k">if</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">low</span><span class="p">)</span> <span class="k">return</span> <span class="nf">trimBST</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span><span class="n">high</span><span class="p">);</span>
        <span class="c1">// 直接返回 root.left，等于删除 root 以及 root 的右子树</span>
        <span class="k">if</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">high</span><span class="p">)</span> <span class="k">return</span> <span class="nf">trimBST</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">);</span>
        <span class="c1">// 闭区间 [lo, hi] 内的节点什么都不做</span>
        <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="nf">trimBST</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">);</span>
        <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="nf">trimBST</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h2 id="700-二叉搜索树中的搜索"><span class="mr-2">700. 二叉搜索树中的搜索</span><a href="#700-二叉搜索树中的搜索" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>给定二叉搜索树（BST）的根节点 <code class="language-plaintext highlighter-rouge">root</code> 和一个整数值 <code class="language-plaintext highlighter-rouge">val</code>。</p><p>你需要在 BST 中找到节点值等于 <code class="language-plaintext highlighter-rouge">val</code> 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 <code class="language-plaintext highlighter-rouge">null</code> 。</p><p><strong>示例：</strong></p><div align="center"><img data-src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204270954033.jpeg" alt="img" style="zoom:50%;" data-proofer-ignore></div><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">root</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">输出</span><span class="err">：</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
</pre></table></code></div></div><p>解法一：二叉树定义，左小右大</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="nc">TreeNode</span><span class="o">*</span> <span class="nf">searchBST</span><span class="p">(</span><span class="nc">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="n">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
        <span class="c1">//比目标值大，到左子树寻找</span>
        <span class="k">if</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">val</span><span class="p">)</span> <span class="k">return</span> <span class="nf">searchBST</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
        <span class="c1">//比目标值小，到右子树找</span>
        <span class="k">if</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">val</span><span class="p">)</span> <span class="k">return</span> <span class="nf">searchBST</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
        <span class="c1">//等于目标值，返回节点</span>
        <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><p>解法二：中序遍历</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="nc">TreeNode</span><span class="o">*</span> <span class="n">res</span><span class="p">;</span>
    <span class="nc">TreeNode</span><span class="o">*</span> <span class="nf">searchBST</span><span class="p">(</span><span class="nc">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="n">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">traverse</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">void</span> <span class="nf">traverse</span><span class="p">(</span><span class="nc">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="n">int</span> <span class="n">val</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
        <span class="nf">traverse</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">==</span> <span class="n">val</span><span class="p">){</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="nf">traverse</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h2 id="701-二叉搜索树中的插入操作"><span class="mr-2">701. 二叉搜索树中的插入操作</span><a href="#701-二叉搜索树中的插入操作" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>给定二叉搜索树（BST）的根节点 <code class="language-plaintext highlighter-rouge">root</code> 和要插入树中的值 <code class="language-plaintext highlighter-rouge">value</code> ，将值插入二叉搜索树，返回插入后二叉搜索树的根节点。 输入数据 <strong>保证</strong>新值和原始二叉搜索树中的任意节点值都不同。</p><p><strong>注意</strong>，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 <strong>任意有效的结果</strong> 。</p><p><strong>示例：</strong></p><div align="center"><img data-src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204271015149.jpeg" alt="img" style="zoom:50%;" data-proofer-ignore></div><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">root</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">输出</span><span class="err">：</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
</pre></table></code></div></div><p>如果要递归地插入或者删除二叉树节点，递归函数一定要有返回值，而且返回值要被正确的接收。</p><p>插入的过程可以分两部分：</p><p>1、寻找正确的插入位置，类似 <a href="https://leetcode-cn.com/problems/search-in-a-binary-search-tree">700. 二叉搜索树中的搜索</a>。</p><p>2、把元素插进去，这就要把新节点以返回值的方式接到父节点上。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="nc">TreeNode</span><span class="o">*</span> <span class="nf">insertIntoBST</span><span class="p">(</span><span class="nc">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="n">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 找到空位置插入新节点</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="k">return</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">val</span><span class="p">)</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="nf">insertIntoBST</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">val</span><span class="p">)</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="nf">insertIntoBST</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h2 id="450-删除二叉搜索树中的节点"><span class="mr-2">450. 删除二叉搜索树中的节点</span><a href="#450-删除二叉搜索树中的节点" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>给定一个二叉搜索树的根节点 <strong>root</strong> 和一个值 <strong>key</strong>，删除二叉搜索树中的 <strong>key</strong> 对应的节点，并保证二叉搜索树的性质不变，返回二叉搜索树（有可能被更新）的根节点的引用。</p><p>跟插入操作类似，先「找」再「改」，先把框架写出来：</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="nc">TreeNode</span><span class="o">*</span> <span class="nf">deleteNode</span><span class="p">(</span><span class="nc">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="n">int</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">==</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 找到啦，进行删除</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 去左子树找</span>
        <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="nf">deleteNode</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="mf">.</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 去右子树找</span>
        <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="nf">deleteNode</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>删除比插入和搜索都要复杂一些，分三种情况：</p><p><strong>情况 1</strong>：<code class="language-plaintext highlighter-rouge">A</code> 恰好是末端节点，两个子节点都为空，那么直接删除：</p><div align="center"><img data-src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204271044120.png" alt="img" style="zoom:25%;" data-proofer-ignore></div><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span>
    <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
</pre></table></code></div></div><p><strong>情况 2</strong>：<code class="language-plaintext highlighter-rouge">A</code> 只有一个非空子节点，那么它要让这个孩子接替自己的位置。</p><div align="center"><img data-src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204271044561.png" alt="img" style="zoom:48%;" data-proofer-ignore></div><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="c1">// 排除了情况 1 之后</span>
<span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="k">return</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="k">return</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
</pre></table></code></div></div><p><strong>情况 3</strong>：<code class="language-plaintext highlighter-rouge">A</code> 有两个子节点，麻烦了，为了不破坏 BST 的性质，<code class="language-plaintext highlighter-rouge">A</code> 必须找到<strong>左子树中最大的那个节点</strong>，或者<strong>右子树中最小的那个节点</strong>来接替自己，下列为第二种方式。</p><p><img data-src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204271046754.png" alt="img" data-proofer-ignore></p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 找到右子树的最小节点</span>
    <span class="nc">TreeNode</span><span class="o">*</span> <span class="n">minNode</span> <span class="o">=</span> <span class="nf">getMin</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
    <span class="c1">// 把 root 改成 minNode</span>
    <span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">=</span> <span class="n">minNode</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span>
    <span class="c1">// 转而去删除 minNode</span>
    <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="nf">deleteNode</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">minNode</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>三种情况分析完毕，填入框架，简化一下代码：</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="nc">TreeNode</span><span class="o">*</span> <span class="nf">deleteNode</span><span class="p">(</span><span class="nc">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="n">int</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">==</span> <span class="n">key</span><span class="p">){</span>
        	<span class="c1">// 这两个 if 把情况 1 和 2 都正确处理了</span>
            <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="k">return</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
            <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span> <span class="k">return</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
        	<span class="c1">// 处理情况 3</span>
        	<span class="c1">// 获得右子树最小的节点</span>
            <span class="nc">TreeNode</span><span class="o">*</span> <span class="n">minNode</span> <span class="o">=</span> <span class="nf">getMin</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
            <span class="c1">// 删除右子树最小的节点</span>
            <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="nf">deleteNode</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">minNode</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
            <span class="c1">// 用右子树最小的节点替换 root 节点</span>
            <span class="n">minNode</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
            <span class="n">minNode</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
            <span class="n">root</span> <span class="o">=</span> <span class="n">minNode</span><span class="p">;</span>
        <span class="p">}</span><span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">key</span><span class="p">){</span>
            <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="nf">deleteNode</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
        <span class="p">}</span><span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">key</span><span class="p">){</span>
            <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="nf">deleteNode</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nc">TreeNode</span><span class="o">*</span> <span class="nf">getMin</span><span class="p">(</span><span class="nc">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">){</span>
        <span class="c1">// BST 最左边的就是最小的</span>
        <span class="k">while</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h2 id="96-不同的二叉搜索树"><span class="mr-2">96. 不同的二叉搜索树</span><a href="#96-不同的二叉搜索树" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>给你一个整数 <code class="language-plaintext highlighter-rouge">n</code> ，求恰由 <code class="language-plaintext highlighter-rouge">n</code> 个节点组成且节点值从 <code class="language-plaintext highlighter-rouge">1</code> 到 <code class="language-plaintext highlighter-rouge">n</code> 互不相同的 <strong>二叉搜索树</strong> 有多少种？返回满足题意的二叉搜索树的种数。</p><p><strong>示例：</strong></p><div align="center"><img data-src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204271115456.jpeg" alt="img" style="zoom:50%;" data-proofer-ignore></div><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">n</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">5</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">dp[i]</code>：1到<code class="language-plaintext highlighter-rouge">i</code>为节点组成的二叉搜索树的个数为<code class="language-plaintext highlighter-rouge">dp[i]</code>，也可以理解是<code class="language-plaintext highlighter-rouge">i</code>的不同元素节点组成的二叉搜索树的个数为<code class="language-plaintext highlighter-rouge">dp[i]</code>，都是一样的。</p><p><code class="language-plaintext highlighter-rouge">dp[i] += dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量]</code>，<code class="language-plaintext highlighter-rouge">j</code>相当于是头结点的元素，从1遍历到<code class="language-plaintext highlighter-rouge">i</code>为止。所以递推公式：<code class="language-plaintext highlighter-rouge">dp[i] += dp[j - 1] * dp[i - j]</code>，<code class="language-plaintext highlighter-rouge">j - 1</code> 为<code class="language-plaintext highlighter-rouge">j</code>为头结点的左子树节点数量，<code class="language-plaintext highlighter-rouge">i - j</code> 为以<code class="language-plaintext highlighter-rouge">j</code>为头结点的右子树节点数量。</p><p>初始化：从定义上来讲，空节点也是一棵二叉树，也是一棵二叉搜索树，所以初始化<code class="language-plaintext highlighter-rouge">dp[0] = 1</code>。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre> <span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
     <span class="n">int</span> <span class="nf">numTrees</span><span class="p">(</span><span class="n">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
         <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span> <span class="nf">dp</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
         <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
         <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
             <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                 <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dp</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">j</span><span class="p">];</span>
             <span class="p">}</span>
         <span class="p">}</span>
         <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
     <span class="p">}</span>
 <span class="p">};</span>
</pre></table></code></div></div><h2 id="95-不同的二叉搜索树-ii"><span class="mr-2">95. 不同的二叉搜索树 II</span><a href="#95-不同的二叉搜索树-ii" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>给你一个整数 <code class="language-plaintext highlighter-rouge">n</code> ，请你生成并返回所有由 <code class="language-plaintext highlighter-rouge">n</code> 个节点组成且节点值从 <code class="language-plaintext highlighter-rouge">1</code> 到 <code class="language-plaintext highlighter-rouge">n</code> 互不相同的不同 <strong>二叉搜索树</strong> ，可以按 <strong>任意顺序</strong> 返回答案。</p><p><strong>示例：</strong></p><div align="center"><img data-src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204271559371.jpeg" alt="img" style="zoom:50%;" data-proofer-ignore></div><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">n</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">输出</span><span class="err">：</span><span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="kc">null</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="kc">null</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="kc">null</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="kc">null</span><span class="p">,</span><span class="kc">null</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="kc">null</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span>
</pre></table></code></div></div><p>想要构造出所有合法 BST，分以下三步：</p><p>1、穷举 <code class="language-plaintext highlighter-rouge">root</code> 节点的所有可能；</p><p>2、递归构造出左右子树的所有合法 BST；</p><p>3、给 <code class="language-plaintext highlighter-rouge">root</code> 节点穷举所有左右子树的组合。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">*&gt;</span> <span class="nf">generateTrees</span><span class="p">(</span><span class="n">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="p">{};</span>
        <span class="k">return</span> <span class="nf">build</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">//定义：构造闭区间 [lo, hi] 组成的 BST</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">*&gt;</span> <span class="nf">build</span><span class="p">(</span><span class="n">int</span> <span class="n">lo</span><span class="p">,</span> <span class="n">int</span> <span class="n">hi</span><span class="p">){</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">*&gt;</span> <span class="n">res</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">lo</span> <span class="o">&gt;</span> <span class="n">hi</span><span class="p">){</span>
            <span class="n">res</span><span class="mf">.</span><span class="nf">push_back</span><span class="p">(</span><span class="n">nullptr</span><span class="p">);</span>
            <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">//1、穷举root节点所有可能</span>
        <span class="k">for</span><span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">lo</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">hi</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="c1">// 2、递归构造出左右子树的所有合法 BST</span>
            <span class="n">vector</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">*&gt;</span> <span class="n">leftTree</span> <span class="o">=</span> <span class="nf">build</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
            <span class="n">vector</span><span class="o">&lt;</span><span class="nc">TreeNode</span><span class="o">*&gt;</span> <span class="n">rightTree</span> <span class="o">=</span> <span class="nf">build</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">hi</span><span class="p">);</span>
            <span class="c1">// 3、给 root 节点穷举所有左右子树的组合</span>
            <span class="k">for</span><span class="p">(</span><span class="nc">TreeNode</span><span class="o">*</span> <span class="n">left</span><span class="o">:</span> <span class="n">leftTree</span><span class="p">){</span>
                <span class="k">for</span><span class="p">(</span><span class="nc">TreeNode</span><span class="o">*</span> <span class="n">right</span><span class="o">:</span> <span class="n">rightTree</span><span class="p">){</span>
                    <span class="c1">// i 作为根节点 root 的值</span>
                    <span class="nc">TreeNode</span><span class="o">*</span> <span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
                    <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span>
                    <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span><span class="p">;</span>
                    <span class="n">res</span><span class="mf">.</span><span class="nf">push_back</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h2 id="108-将有序数组转换为二叉搜索树"><span class="mr-2">108. 将有序数组转换为二叉搜索树</span><a href="#108-将有序数组转换为二叉搜索树" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>给你一个整数数组 <code class="language-plaintext highlighter-rouge">nums</code> ，其中元素已经按 <strong>升序</strong> 排列，请你将其转换为一棵 <strong>高度平衡</strong> 二叉搜索树。</p><p><strong>高度平衡</strong> 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。</p><p><strong>示例：</strong></p><div align="center"><img data-src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204271942183.jpeg" alt="img" style="zoom:50%;" data-proofer-ignore></div><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">nums</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">9</span><span class="p">]</span>
<span class="n">输出</span><span class="err">：</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span><span class="kc">null</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
</pre></table></code></div></div><p>二叉树的构建问题很简单，说白了就是：构造根节点，然后构建左右子树。</p><p>一个有序数组对于 BST 来说就是<strong>中序遍历</strong>结果，根节点在数组中心，数组左侧是左子树元素，右侧是右子树元素。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="nc">TreeNode</span><span class="o">*</span> <span class="nf">sortedArrayToBST</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nf">build</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">nums</span><span class="mf">.</span><span class="nf">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="nc">TreeNode</span><span class="o">*</span> <span class="nf">build</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="n">int</span> <span class="n">left</span><span class="p">,</span> <span class="n">int</span> <span class="n">right</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="n">left</span> <span class="o">&gt;</span> <span class="n">right</span><span class="p">)</span> <span class="k">return</span> <span class="n">nullptr</span><span class="p">;</span>
        <span class="n">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">left</span> <span class="o">+</span> <span class="n">right</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
        <span class="nc">TreeNode</span><span class="o">*</span> <span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">]);</span>
        <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="nf">build</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="nf">build</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">right</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h2 id="109有序链表转换二叉搜索树"><span class="mr-2">109、有序链表转换二叉搜索树</span><a href="#109有序链表转换二叉搜索树" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>给定一个单链表的头节点 <code class="language-plaintext highlighter-rouge">head</code> ，其中的元素 <strong>按升序排序</strong> ，将其转换为高度平衡的二叉搜索树。</p><p>本题中，一个高度平衡二叉树是指一个二叉树<em>每个节点</em> 的左右两个子树的高度差不超过 1。</p><p><strong>示例:</strong></p><div align="center"><img data-src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204301023724.jpeg" alt="img" style="zoom:40%;" data-proofer-ignore></div><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="o">:</span> <span class="n">head</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">9</span><span class="p">]</span>
<span class="n">输出</span><span class="o">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span><span class="kc">null</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
</pre></table></code></div></div><p>链表和数组相比的一个关键差异是无法通过索引快速访问元素，所以这题有几个思路：</p><p>1、把链表转化成数组，然后直接复用 <a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree">108. 将有序数组转换为二叉搜索树</a> 的解法。</p><p>2、稍微改写 <a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree">108. 将有序数组转换为二叉搜索树</a> 的解法，用 <a href="https://labuladong.github.io/article/fname.html?fname=链表技巧">单链表的六大解题套路</a> 说到的双指针方法获取链表的中点，时间复杂度略高一些。</p><p>3、如果深刻理解二叉树算法，可以利用中序遍历的特点写出最优化的解法。</p><p><strong>解法一</strong>：中序遍历，分冶的思想</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="nc">TreeNode</span><span class="o">*</span> <span class="nf">buildTree</span><span class="p">(</span><span class="nc">ListNode</span><span class="o">*</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">int</span> <span class="n">left</span><span class="p">,</span> <span class="n">int</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">&gt;</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">nullptr</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">left</span> <span class="o">+</span> <span class="n">right</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
        <span class="nc">TreeNode</span><span class="o">*</span> <span class="n">leftTree</span> <span class="o">=</span> <span class="nf">buildTree</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
        <span class="nc">TreeNode</span><span class="o">*</span> <span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="nc">TreeNode</span><span class="o">*</span> <span class="n">rightTree</span> <span class="o">=</span> <span class="nf">buildTree</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">right</span><span class="p">);</span>
        <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">leftTree</span><span class="p">;</span>
        <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">rightTree</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nc">TreeNode</span><span class="o">*</span> <span class="nf">sortedListToBST</span><span class="p">(</span><span class="nc">ListNode</span><span class="o">*</span> <span class="n">head</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="nc">ListNode</span><span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span> <span class="n">ptr</span> <span class="o">!=</span> <span class="n">nullptr</span><span class="p">;</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">){</span>
            <span class="n">len</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nf">buildTree</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><p><strong>解法二</strong>：<strong>双指针</strong>获取链表的中点</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="nc">TreeNode</span><span class="o">*</span> <span class="nf">sortedListToBST</span><span class="p">(</span><span class="nc">ListNode</span><span class="o">*</span> <span class="n">head</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nf">build</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">nullptr</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 把链表左闭右开区间 [begin, end) 的节点构造成 BST</span>
    <span class="nc">TreeNode</span><span class="o">*</span> <span class="nf">build</span><span class="p">(</span><span class="nc">ListNode</span><span class="o">*</span> <span class="n">begin</span><span class="p">,</span> <span class="nc">ListNode</span><span class="o">*</span> <span class="n">end</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="n">begin</span> <span class="o">==</span> <span class="n">end</span><span class="p">)</span> <span class="k">return</span> <span class="n">nullptr</span><span class="p">;</span>
        <span class="nc">ListNode</span><span class="o">*</span> <span class="n">mid</span> <span class="o">=</span> <span class="nf">getMid</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
        <span class="nc">TreeNode</span><span class="o">*</span> <span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="n">mid</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
        <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="nf">build</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="n">mid</span><span class="p">);</span>
        <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="nf">build</span><span class="p">(</span><span class="n">mid</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 获取链表左闭右开区间 [begin, end) 的中心节点</span>
    <span class="nc">ListNode</span><span class="o">*</span> <span class="nf">getMid</span><span class="p">(</span><span class="nc">ListNode</span><span class="o">*</span> <span class="n">begin</span><span class="p">,</span> <span class="nc">ListNode</span><span class="o">*</span> <span class="n">end</span><span class="p">){</span>
        <span class="nc">ListNode</span><span class="o">*</span> <span class="n">slow</span> <span class="o">=</span> <span class="n">begin</span><span class="p">;</span>
        <span class="nc">ListNode</span><span class="o">*</span> <span class="n">fast</span> <span class="o">=</span> <span class="n">begin</span><span class="p">;</span>
        <span class="k">while</span><span class="p">(</span><span class="n">fast</span> <span class="o">!=</span> <span class="n">end</span> <span class="o">&amp;&amp;</span> <span class="n">fast</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">!=</span> <span class="n">end</span><span class="p">){</span>
            <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">slow</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h2 id="剑指-offer-33-二叉搜索树的后序遍历序列"><span class="mr-2">剑指 Offer 33. 二叉搜索树的后序遍历序列</span><a href="#剑指-offer-33-二叉搜索树的后序遍历序列" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 <code class="language-plaintext highlighter-rouge">true</code>，否则返回 <code class="language-plaintext highlighter-rouge">false</code>。假设输入的数组的任意两个数字都互不相同。</p><p>参考以下这颗二叉搜索树：</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>     5
    / \
   2   6
  / \
 1   3
</pre></table></code></div></div><p><strong>示例：</strong></p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="o">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="n">输出</span><span class="o">:</span> <span class="kc">false</span>
</pre></table></code></div></div><ul><li><p>利用二叉搜索树<strong>左大右小</strong>的性质划分左右子树：</p><p>遍历后序遍历的<code class="language-plaintext highlighter-rouge">[start, end]</code>区间的元素，寻找第一个大于根节点的节点，索引记为 <code class="language-plaintext highlighter-rouge">midIndex </code>。此时，可划分出左子树区间 <code class="language-plaintext highlighter-rouge">[start, midIndex - 1]</code>，右子树区间<code class="language-plaintext highlighter-rouge"> [midIndex, end - 1] </code>、根节点索引 <code class="language-plaintext highlighter-rouge">end</code>。</p><li><p>判断是否为二叉搜索树： 左子树区间 <code class="language-plaintext highlighter-rouge">[start, midIndex - 1]</code>内的所有节点都应 <code class="language-plaintext highlighter-rouge">&lt; postorder[end]</code> 。而第 1.划分左右子树 步骤已经保证左子树区间的正确性，因此只需要判断右子树区间即可。 右子树区间 ` [midIndex, end - 1] ` 内的所有节点都应 <code class="language-plaintext highlighter-rouge">&gt; postorder[j]</code> 。实现方式为遍历，当遇到 <code class="language-plaintext highlighter-rouge">≤postorder[j]</code>的节点则跳出；则可通过<code class="language-plaintext highlighter-rouge">index == end</code>判断是否为二叉搜索树。</p><li><p>返回值：</p><p>所有子树都需正确才可判定正确，因此使用 与逻辑符 &amp;&amp; 连接。</p></ul><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">bool</span> <span class="nf">traversal</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&amp;</span> <span class="n">postorder</span><span class="p">,</span> <span class="n">int</span> <span class="n">start</span><span class="p">,</span> <span class="n">int</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* 递归终止条件 */</span>
        <span class="k">if</span><span class="p">(</span><span class="n">start</span> <span class="o">&gt;</span> <span class="n">end</span><span class="p">)</span> <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
        <span class="n">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
        <span class="cm">/* 中间处理逻辑 */</span>
        <span class="k">while</span><span class="p">(</span><span class="n">postorder</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">postorder</span><span class="p">[</span><span class="n">end</span><span class="p">])</span> <span class="n">index</span><span class="o">++</span><span class="p">;</span>
        <span class="cm">/* 记录分割点 */</span>
       <span class="n">int</span> <span class="n">midIndex</span> <span class="o">=</span> <span class="n">index</span><span class="p">;</span>
        <span class="k">while</span><span class="p">(</span><span class="n">postorder</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">postorder</span><span class="p">[</span><span class="n">end</span><span class="p">])</span> <span class="n">index</span><span class="o">++</span><span class="p">;</span>
        <span class="cm">/* 递归左右子树 */</span>
        <span class="n">bool</span> <span class="n">left</span> <span class="o">=</span> <span class="nf">traversal</span><span class="p">(</span><span class="n">postorder</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">midIndex</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">bool</span> <span class="n">right</span> <span class="o">=</span> <span class="nf">traversal</span><span class="p">(</span><span class="n">postorder</span><span class="p">,</span> <span class="n">midIndex</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">index</span> <span class="o">==</span> <span class="n">end</span> <span class="o">&amp;&amp;</span> <span class="n">left</span> <span class="o">&amp;&amp;</span> <span class="n">right</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">bool</span> <span class="nf">verifyPostorder</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&amp;</span> <span class="n">postorder</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nf">traversal</span><span class="p">(</span><span class="n">postorder</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">postorder</span><span class="mf">.</span><span class="nf">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h1 id="参考资料">参考资料</h1><p><a href="https://labuladong.github.io/algo/">labuladong 的算法小抄 :: labuladong的算法小抄</a></p><p><a href="https://programmercarl.com/">代码随想录 (programmercarl.com)</a></p><p><a href="https://leetcode-cn.com/problemset/all/">题库 - 力扣 (LeetCode) 全球极客挚爱的技术成长平台 (leetcode-cn.com)</a></p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/'>算法刷题</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/%E7%AE%97%E6%B3%95/" class="post-tag no-text-decoration" >算法</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 本文由作者按照 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 进行授权</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">分享</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=%E4%B8%80%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91+-+%E5%8D%A1%E5%8D%A1%E6%88%90%E9%95%BF%E6%B1%87%E8%81%9A%E9%98%BF%E8%B1%B9&url=%2Fposts%2F%25E4%25B8%2580-%25E4%25BA%258C%25E5%258F%2589%25E6%25A0%2591%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=%E4%B8%80%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91+-+%E5%8D%A1%E5%8D%A1%E6%88%90%E9%95%BF%E6%B1%87%E8%81%9A%E9%98%BF%E8%B1%B9&u=%2Fposts%2F%25E4%25B8%2580-%25E4%25BA%258C%25E5%258F%2589%25E6%25A0%2591%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=%2Fposts%2F%25E4%25B8%2580-%25E4%25BA%258C%25E5%258F%2589%25E6%25A0%2591%2F&text=%E4%B8%80%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91+-+%E5%8D%A1%E5%8D%A1%E6%88%90%E9%95%BF%E6%B1%87%E8%81%9A%E9%98%BF%E8%B1%B9" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="分享链接" data-title-succeed="链接已复制！"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">最近更新</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/%E5%85%B3%E6%B3%A8/">关注</a><li><a href="/posts/%E4%B8%83-%E8%A1%A5%E5%85%85/">七、补充</a><li><a href="/posts/%E5%85%AD-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/">六、贪心算法</a><li><a href="/posts/%E4%BA%94-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">五、动态规划</a><li><a href="/posts/%E5%9B%9B-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/">四、回溯算法</a></ul></div><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/%E7%AE%97%E6%B3%95/">算法</a> <a class="post-tag" href="/tags/%E8%B5%84%E6%BA%90/">资源</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">文章内容</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>相关文章</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/%E4%B8%83-%E8%A1%A5%E5%85%85/"><div class="card-body"> <em class="small" data-ts="1655865240" data-df="YYYY-MM-DD" > 2022-06-22 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>七、补充</h3><div class="text-muted small"><p> 7. 整数反转 给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。如果反转后整数超过 32 位的有符号整数的范围 [−231, 231 − 1] ，就返回 0。假设环境不允许存储 64 位整数（有符号或无符号）。 输入：x = 123 输出：321 class Solution { public: int reverse(int x) { ...</p></div></div></a></div><div class="card"> <a href="/posts/%E5%85%AD-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"><div class="card-body"> <em class="small" data-ts="1655951640" data-df="YYYY-MM-DD" > 2022-06-23 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>六、贪心算法</h3><div class="text-muted small"><p> 435. 无重叠区间 给定一个区间的集合 intervals ，其中 intervals[i] = [starti, endi] ，返回需要移除区间的最小数量，使剩余区间互不重叠 。 输入: intervals = [[1,2],[2,3],[3,4],[1,3]] 输出: 1 解释: 移除 [1,3] 后，剩下的区间没有重叠。 右边界排序，从左向右记录非交叉区间的个数，最后用区间总...</p></div></div></a></div><div class="card"> <a href="/posts/%E4%BA%94-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"><div class="card-body"> <em class="small" data-ts="1656124440" data-df="YYYY-MM-DD" > 2022-06-25 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>五、动态规划</h3><div class="text-muted small"><p> 动态规划是什么？解决动态规划问题有什么技巧？如何学习动态规划？ 首先，动态规划问题的一般形式就是求最值。动态规划其实是运筹学的一种最优化方法，只不过在计算机问题上应用比较多，比如说让你求最长递增子序列呀，最小编辑距离呀等等。 既然是要求最值，核心问题是什么呢？求解动态规划的核心问题是穷举。因为要求最值，肯定要把所有可行的答案穷举出来，然后在其中找最值呗。 首先，虽然动态规划的核心思想就...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/%E4%BA%8C-%E9%93%BE%E8%A1%A8/" class="btn btn-outline-primary" prompt="上一篇"><p>二、链表</p></a> <a href="/posts/%E5%85%B3%E6%B3%A8/" class="btn btn-outline-primary" prompt="下一篇"><p>关注</p></a></div></div></div><footer class="row pl-3 pr-3"><div class="col-12 d-flex justify-content-between align-items-center text-muted pl-0 pr-0"><div class="footer-left"><p class="mb-0"> © 2022 <a href="https://twitter.com/username">CARLOSGP2021</a>. <span data-toggle="tooltip" data-placement="top" title="除非另有说明，本网站上的博客文章均由作者按照知识共享署名 4.0 国际 (CC BY 4.0) 许可协议进行授权。">保留部分权利。</span></p></div><div class="footer-right"><p class="mb-0"> 本站由 <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> 生成，采用 <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> 主题。</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/%E7%AE%97%E6%B3%95/">算法</a> <a class="post-tag" href="/tags/%E8%B5%84%E6%BA%90/">资源</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><script src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js"></script> <script> $(function() { function updateMermaid(event) { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { const mode = event.data.message; if (typeof mermaid === "undefined") { return; } let expectedTheme = (mode === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* Re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } let initTheme = "default"; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches ) ) { initTheme = "dark"; } let mermaidConf = { theme: initTheme /* <default|dark|forest|neutral> */ }; /* Markdown converts to HTML */ $("pre").has("code.language-mermaid").each(function() { let svgCode = $(this).children().html(); $(this).addClass("unloaded"); $(this).after(`<div class=\"mermaid\">${svgCode}</div>`); }); mermaid.initialize(mermaidConf); window.addEventListener("message", updateMermaid); }); </script><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a><div id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-animation="true" data-autohide="false"><div class="toast-header"> <button type="button" class="ml-2 ml-auto close" data-dismiss="toast" aria-label="Close"> <span aria-hidden="true">&times;</span> </button></div><div class="toast-body text-center pt-0"><p class="pl-2 pr-2 mb-3"></p><button type="button" class="btn btn-primary" aria-label="Update"> </button></div></div><script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">搜索结果为空</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/asia/shanghai.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script>
