<!DOCTYPE html><html lang="zh-CN" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="prefer-datetime-locale" content="Asia/Shanghai"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="五、动态规划" /><meta name="author" content="卡卡成长汇聚阿豹" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="动态规划是什么？解决动态规划问题有什么技巧？如何学习动态规划？" /><meta property="og:description" content="动态规划是什么？解决动态规划问题有什么技巧？如何学习动态规划？" /><link rel="canonical" href="/posts/%E4%BA%94-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" /><meta property="og:url" content="/posts/%E4%BA%94-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" /><meta property="og:site_name" content="卡卡成长汇聚阿豹" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-06-25T02:34:00+00:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="五、动态规划" /><meta name="twitter:site" content="@twitter_username" /><meta name="twitter:creator" content="@卡卡成长汇聚阿豹" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"卡卡成长汇聚阿豹"},"dateModified":"2022-06-27T07:10:18+00:00","datePublished":"2022-06-25T02:34:00+00:00","description":"动态规划是什么？解决动态规划问题有什么技巧？如何学习动态规划？","headline":"五、动态规划","mainEntityOfPage":{"@type":"WebPage","@id":"/posts/%E4%BA%94-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},"url":"/posts/%E4%BA%94-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}</script><title>五、动态规划 | 卡卡成长汇聚阿豹</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="卡卡成长汇聚阿豹"><meta name="application-name" content="卡卡成长汇聚阿豹"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="/assets/config/kaka.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">卡卡成长汇聚阿豹</a></div><div class="site-subtitle font-italic">微信公众号：卡卡成长汇聚</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>首页</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>分类</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>标签</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>归档</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>关于</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/CARLOSGP2021" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/twitter_username" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['example','doamin.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> 首页 </a> </span> <span>五、动态规划</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> 文章</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="搜索..."> </span> <span id="search-cancel" >取消</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>五、动态规划</h1><div class="post-meta text-muted"> <span> 发表于 <em class="" data-ts="1656124440" data-df="YYYY-MM-DD" data-toggle="tooltip" data-placement="bottom"> 2022-06-25 </em> </span> <span> 更新于 <em class="" data-ts="1656313818" data-df="YYYY-MM-DD" data-toggle="tooltip" data-placement="bottom"> 2022-06-27 </em> </span><div class="d-flex justify-content-between"> <span> 作者 <em> CARLOSGP2021 </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="26448 字"> <em>146 分钟</em>阅读</span></div></div></div><div class="post-content"><p>动态规划是什么？解决动态规划问题有什么技巧？如何学习动态规划？</p><p>首先，<strong>动态规划问题的一般形式就是求最值</strong>。动态规划其实是运筹学的一种最优化方法，只不过在计算机问题上应用比较多，比如说让你求最长递增子序列呀，最小编辑距离呀等等。</p><p>既然是要求最值，核心问题是什么呢？<strong>求解动态规划的核心问题是穷举</strong>。因为要求最值，肯定要把所有可行的答案穷举出来，然后在其中找最值呗。</p><p>首先，虽然动态规划的核心思想就是穷举求最值，但是问题可以千变万化，穷举所有可行解其实并不是一件容易的事，需要你熟练掌握递归思维，只有列出<strong>正确的「状态转移方程」</strong>，才能正确地穷举。而且，你需要判断算法问题是否<strong>具备「最优子结构」</strong>，是否能够通过子问题的最值得到原问题的最值。另外，动态规划问题<strong>存在「重叠子问题」</strong>，如果暴力穷举的话效率会很低，所以需要你使用「备忘录」或者「DP table」来优化穷举过程，避免不必要的计算。</p><p>以上提到的重叠子问题、最优子结构、状态转移方程就是动态规划三要素。在实际的算法问题中，写出状态转移方程是最困难的，这也就是为什么很多朋友觉得动态规划问题困难的原因。总结的一个思维框架，来辅助思考状态转移方程：</p><p><strong>明确 base case -&gt; 明确「状态」-&gt; 明确「选择」 -&gt; 定义 <code class="language-plaintext highlighter-rouge">dp</code> 数组/函数的含义</strong>。</p><p>按上面的套路走，最后的解法代码就会是如下的框架：</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="c1"># 自顶向下递归的动态规划</span>
<span class="n">def</span> <span class="nf">dp</span><span class="p">(</span><span class="n">状态1</span><span class="p">,</span> <span class="n">状态2</span><span class="p">,</span> <span class="mf">...</span><span class="p">)</span><span class="o">:</span>
    <span class="k">for</span> <span class="n">选择</span> <span class="n">in</span> <span class="n">所有可能的选择</span><span class="o">:</span>
        <span class="c1"># 此时的状态已经因为做了选择而改变</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nf">求最值</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="nf">dp</span><span class="p">(</span><span class="n">状态1</span><span class="p">,</span> <span class="n">状态2</span><span class="p">,</span> <span class="mf">...</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">result</span>

<span class="c1"># 自底向上迭代的动态规划</span>
<span class="c1"># 初始化 base case</span>
<span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mf">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">base</span> <span class="k">case</span>
<span class="c1"># 进行状态转移</span>
<span class="k">for</span> <span class="n">状态1</span> <span class="n">in</span> <span class="n">状态1的所有取值</span><span class="err">：</span>
    <span class="k">for</span> <span class="n">状态2</span> <span class="n">in</span> <span class="n">状态2的所有取值</span><span class="err">：</span>
        <span class="k">for</span> <span class="mf">...</span>
            <span class="n">dp</span><span class="p">[</span><span class="n">状态1</span><span class="p">][</span><span class="n">状态2</span><span class="p">][</span><span class="mf">...</span><span class="p">]</span> <span class="o">=</span> <span class="nf">求最值</span><span class="p">(</span><span class="n">选择1</span><span class="err">，</span><span class="n">选择2</span><span class="mf">...</span><span class="p">)</span>
</pre></table></code></div></div><p>下面通过斐波那契数列问题和凑零钱问题来详解动态规划的基本原理。前者主要是让你明白什么是<strong>重叠子问题</strong>（斐波那契数列没有求最值，所以严格来说不是动态规划问题），后者主要举集中于如何列出<strong>状态转移方程</strong>。</p><h2 id="拆分"><span class="mr-2">拆分</span><a href="#拆分" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="343-整数拆分"><span class="mr-2">343. 整数拆分</span><a href="#343-整数拆分" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>给定一个正整数 <code class="language-plaintext highlighter-rouge">n</code> ，将其拆分为 <code class="language-plaintext highlighter-rouge">k</code> 个 <strong>正整数</strong> 的和（ <code class="language-plaintext highlighter-rouge">k &gt;= 2</code> ），并使这些整数的乘积最大化。返回你可以获得的最大乘积。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="o">:</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">输出</span><span class="o">:</span> <span class="mi">1</span>
<span class="n">解释</span><span class="o">:</span> <span class="mi">2</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span> <span class="err">×</span> <span class="mi">1</span> <span class="o">=</span> <span class="mi">1</span><span class="err">。</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">dp[i]</code>：拆分数字<code class="language-plaintext highlighter-rouge">i</code>，可以得到的最大乘积为<code class="language-plaintext highlighter-rouge">dp[i]</code>。</p><p><code class="language-plaintext highlighter-rouge">dp[i]</code>最大乘积是怎么得到的呢？其实可以从1遍历<code class="language-plaintext highlighter-rouge">j</code>，然后有两种渠道得到<code class="language-plaintext highlighter-rouge">dp[i]</code>：一个是<code class="language-plaintext highlighter-rouge">j * (i - j) </code>直接相乘；一个是<code class="language-plaintext highlighter-rouge">j * dp[i - j]</code>，相当于是拆分<code class="language-plaintext highlighter-rouge">(i - j)</code>。递推公式：<code class="language-plaintext highlighter-rouge">dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j))</code>。</p><p>也可以这么理解，<code class="language-plaintext highlighter-rouge">j * (i - j)</code> 是单纯的把整数拆分为两个数相乘，而<code class="language-plaintext highlighter-rouge">j * dp[i - j]</code>是拆分成两个以及两个以上的个数相乘。</p><p>初始化：可以只初始化<code class="language-plaintext highlighter-rouge">dp[2] = 1</code>，从<code class="language-plaintext highlighter-rouge">dp[i]</code>的定义来说，拆分数字2，得到的最大乘积是1。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">int</span> <span class="nf">integerBreak</span><span class="p">(</span><span class="n">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span> <span class="nf">dp</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">dp</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">max</span><span class="p">((</span><span class="n">i</span> <span class="o">-</span> <span class="n">j</span><span class="p">)</span> <span class="o">*</span> <span class="n">j</span><span class="p">,</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">j</span><span class="p">));</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h3 id="96-不同的二叉搜索树"><span class="mr-2">96. 不同的二叉搜索树</span><a href="#96-不同的二叉搜索树" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>给你一个整数 <code class="language-plaintext highlighter-rouge">n</code> ，求恰由 <code class="language-plaintext highlighter-rouge">n</code> 个节点组成且节点值从 <code class="language-plaintext highlighter-rouge">1</code> 到 <code class="language-plaintext highlighter-rouge">n</code> 互不相同的 <strong>二叉搜索树</strong> 有多少种？返回满足题意的二叉搜索树的种数。</p><p><strong>示例：</strong></p><div align="center"><img data-src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202204271115456.jpeg" alt="img" style="zoom:50%;" data-proofer-ignore></div><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">n</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">5</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">dp[i]</code>：1到<code class="language-plaintext highlighter-rouge">i</code>为节点组成的二叉搜索树的个数为<code class="language-plaintext highlighter-rouge">dp[i]</code>，也可以理解是<code class="language-plaintext highlighter-rouge">i</code>的不同元素节点组成的二叉搜索树的个数为<code class="language-plaintext highlighter-rouge">dp[i]</code>，都是一样的。</p><p><code class="language-plaintext highlighter-rouge">dp[i] += dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量]</code>，<code class="language-plaintext highlighter-rouge">j</code>相当于是头结点的元素，从1遍历到<code class="language-plaintext highlighter-rouge">i</code>为止。所以递推公式：<code class="language-plaintext highlighter-rouge">dp[i] += dp[j - 1] * dp[i - j]</code>，<code class="language-plaintext highlighter-rouge">j - 1</code> 为<code class="language-plaintext highlighter-rouge">j</code>为头结点的左子树节点数量，<code class="language-plaintext highlighter-rouge">i - j</code> 为以<code class="language-plaintext highlighter-rouge">j</code>为头结点的右子树节点数量。</p><p>初始化：从定义上来讲，空节点也是一棵二叉树，也是一棵二叉搜索树，所以初始化<code class="language-plaintext highlighter-rouge">dp[0] = 1</code>。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">int</span> <span class="nf">numTrees</span><span class="p">(</span><span class="n">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span> <span class="nf">dp</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dp</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">j</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h2 id="爬楼梯"><span class="mr-2">爬楼梯</span><a href="#爬楼梯" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="509波那契数"><span class="mr-2">509.波那契数</span><a href="#509波那契数" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><strong>斐波那契数</strong> （通常用 <code class="language-plaintext highlighter-rouge">F(n)</code> 表示）形成的序列称为 <strong>斐波那契数列</strong> 。该数列由 <code class="language-plaintext highlighter-rouge">0</code> 和 <code class="language-plaintext highlighter-rouge">1</code> 开始，后面的每一项数字都是前面两项数字的和。也就是：</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nf">F</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="err">，</span><span class="nf">F</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span>
<span class="nf">F</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">=</span> <span class="nf">F</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="nf">F</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span><span class="err">，</span><span class="n">其中</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">1</span>
</pre></table></code></div></div><p>给定 <code class="language-plaintext highlighter-rouge">n</code> ，请计算 <code class="language-plaintext highlighter-rouge">F(n)</code> 。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">n</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">1</span>
<span class="n">解释</span><span class="err">：</span><span class="nf">F</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">=</span> <span class="nf">F</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="nf">F</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">0</span> <span class="o">=</span> <span class="mi">1</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">dp</code> 数组的迭代（递推）解法：</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">int</span> <span class="nf">fib</span><span class="p">(</span><span class="n">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="n">n</span><span class="p">;</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span> <span class="nf">dq</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">dq</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">dq</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="n">dq</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">dq</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">dq</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">dq</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><p>当然可以发现，我们只需要维护两个数值就可以了，不需要记录整个序列。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">int</span> <span class="nf">fib</span><span class="p">(</span><span class="n">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="n">n</span><span class="p">;</span>
        <span class="n">int</span> <span class="n">d0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">d1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="n">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">d0</span> <span class="o">+</span> <span class="n">d1</span><span class="p">;</span>
            <span class="n">d0</span> <span class="o">=</span> <span class="n">d1</span><span class="p">;</span>
            <span class="n">d1</span> <span class="o">=</span> <span class="n">sum</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">d1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h3 id="70-爬楼梯"><span class="mr-2">70. 爬楼梯</span><a href="#70-爬楼梯" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>假设你正在爬楼梯。需要 <code class="language-plaintext highlighter-rouge">n</code> 阶你才能到达楼顶。每次你可以爬 <code class="language-plaintext highlighter-rouge">1</code> 或 <code class="language-plaintext highlighter-rouge">2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">n</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">2</span>
<span class="n">解释</span><span class="err">：</span><span class="n">有两种方法可以爬到楼顶</span><span class="err">。</span>
<span class="mf">1.</span> <span class="mi">1</span> <span class="n">阶</span> <span class="o">+</span> <span class="mi">1</span> <span class="n">阶</span>
<span class="mf">2.</span> <span class="mi">2</span> <span class="n">阶</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">dp[i]</code>： 爬到第<code class="language-plaintext highlighter-rouge">i</code>层楼梯，有<code class="language-plaintext highlighter-rouge">dp[i]</code>种方法。</p><p>dp[i] 可以有两个方向推出来：</p><p>首先是dp[i - 1]，上i-1层楼梯，有dp[i - 1]种方法，那么再一步跳一个台阶就是dp[i]。还有就是dp[i - 2]，上i-2层楼梯，有dp[i - 2]种方法，那么再一步跳两个台阶就是dp[i]。那么dp[i]就是 dp[i - 1]与dp[i - 2]之和，所以<code class="language-plaintext highlighter-rouge">dp[i] = dp[i - 1] + dp[i - 2]</code> 。</p><p>不考虑dp[0]如果初始化，只初始化<code class="language-plaintext highlighter-rouge">dp[1] = 1</code>，<code class="language-plaintext highlighter-rouge">dp[2] = 2</code>，然后从i = 3开始递推，这样才符合dp[i]的定义。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">int</span> <span class="nf">climbStairs</span><span class="p">(</span><span class="n">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">)</span> <span class="k">return</span> <span class="n">n</span><span class="p">;</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span> <span class="nf">dp</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">dp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">dp</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 注意i是从3开始的</span>
            <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><p>优化一下空间复杂度：</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">int</span> <span class="nf">climbStairs</span><span class="p">(</span><span class="n">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">)</span> <span class="k">return</span> <span class="n">n</span><span class="p">;</span>
        <span class="n">int</span> <span class="n">d1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">d2</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="n">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">d1</span> <span class="o">+</span> <span class="n">d2</span><span class="p">;</span>
            <span class="n">d1</span> <span class="o">=</span> <span class="n">d2</span><span class="p">;</span>
            <span class="n">d2</span> <span class="o">=</span> <span class="n">sum</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">d2</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h3 id="746-使用最小花费爬楼梯"><span class="mr-2">746. 使用最小花费爬楼梯</span><a href="#746-使用最小花费爬楼梯" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>给你一个整数数组 <code class="language-plaintext highlighter-rouge">cost</code> ，其中 <code class="language-plaintext highlighter-rouge">cost[i]</code> 是从楼梯第 <code class="language-plaintext highlighter-rouge">i</code> 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。你可以选择从下标为 <code class="language-plaintext highlighter-rouge">0</code> 或下标为 <code class="language-plaintext highlighter-rouge">1</code> 的台阶开始爬楼梯。请你计算并返回达到楼梯顶部的最低花费。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">cost</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">20</span><span class="p">]</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">15</span>
<span class="n">解释</span><span class="err">：</span><span class="n">你将从下标为</span> <span class="mi">1</span> <span class="n">的台阶开始</span><span class="err">。</span><span class="n">支付</span> <span class="mi">15</span> <span class="err">，</span><span class="n">向上爬两个台阶</span><span class="err">，</span><span class="n">到达楼梯顶部</span><span class="err">。</span><span class="n">总花费为</span> <span class="mi">15</span> <span class="err">。</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">dp[i]</code>：到达第<code class="language-plaintext highlighter-rouge">i</code>个台阶的最低花费为<code class="language-plaintext highlighter-rouge">dp[i]</code>。（注意：这里认为第一步一定是要花费的）</p><p>两个途径得到<code class="language-plaintext highlighter-rouge">dp[i]</code>，一个是<code class="language-plaintext highlighter-rouge">dp[i-1]</code> 一个是<code class="language-plaintext highlighter-rouge">dp[i-2]</code>。一定是选最小的，所以<code class="language-plaintext highlighter-rouge">dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i]</code>。</p><p><strong>初始化</strong>：看一下递归公式，dp[i]由dp[i-1]，dp[i-2]推出，既然初始化所有的dp[i]是不可能的，那么只初始化<code class="language-plaintext highlighter-rouge">dp[0]</code>和<code class="language-plaintext highlighter-rouge">dp[1]</code>就够了，其他的最终都是dp[0]和dp[1]推出的。<code class="language-plaintext highlighter-rouge">dp[0] = cost[0]</code>，<code class="language-plaintext highlighter-rouge">dp[1] = cost[1]</code>。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">int</span> <span class="nf">minCostClimbingStairs</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&amp;</span> <span class="n">cost</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">cost</span><span class="mf">.</span><span class="nf">size</span><span class="p">();</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span> <span class="nf">d</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
        <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cost</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cost</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
        <span class="k">for</span><span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="p">])</span> <span class="o">+</span> <span class="n">cost</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="c1">// 注意最后一步可以理解为不用花费，所以取倒数第一步，第二步的最少值</span>
        <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">d</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]);</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><p>优化空间复杂度：</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">int</span> <span class="nf">minCostClimbingStairs</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&amp;</span> <span class="n">cost</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">int</span> <span class="n">dp0</span> <span class="o">=</span> <span class="n">cost</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="n">int</span> <span class="n">dp1</span> <span class="o">=</span> <span class="n">cost</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cost</span><span class="mf">.</span><span class="nf">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">int</span> <span class="n">dpi</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">dp0</span><span class="p">,</span> <span class="n">dp1</span><span class="p">)</span> <span class="o">+</span> <span class="n">cost</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="n">dp0</span> <span class="o">=</span> <span class="n">dp1</span><span class="p">;</span>
            <span class="n">dp1</span> <span class="o">=</span> <span class="n">dpi</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">dp0</span><span class="p">,</span> <span class="n">dp1</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h2 id="不同路径"><span class="mr-2">不同路径</span><a href="#不同路径" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="62-不同路径"><span class="mr-2">62. 不同路径</span><a href="#62-不同路径" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>一个机器人位于一个 <code class="language-plaintext highlighter-rouge">m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。问总共有多少条不同的路径？</p><p><img data-src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205311640706.png" alt="img" data-proofer-ignore></p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">m</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">7</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">28</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">dp[i][j]</code>：表示从<code class="language-plaintext highlighter-rouge">(0, 0)</code> 出发，到 <code class="language-plaintext highlighter-rouge">(i, j)</code> 有<code class="language-plaintext highlighter-rouge">dp[i][j]</code>条不同的路径。</p><p>想要求<code class="language-plaintext highlighter-rouge">dp[i][j]</code>，只能有两个方向来推导出来，即<code class="language-plaintext highlighter-rouge">dp[i - 1][j] </code>和 <code class="language-plaintext highlighter-rouge">dp[i][j - 1]</code>。<code class="language-plaintext highlighter-rouge">dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</code>，因为<code class="language-plaintext highlighter-rouge">dp[i][j]</code>只有这两个方向过来。</p><p>初始化：首先<code class="language-plaintext highlighter-rouge">dp[i][0]</code>一定都是1，因为从(0, 0)的位置到(i, 0)的路径只有一条，那么<code class="language-plaintext highlighter-rouge">dp[0][j]</code>也同理。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">int</span> <span class="nf">uniquePaths</span><span class="p">(</span><span class="n">int</span> <span class="n">m</span><span class="p">,</span> <span class="n">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&gt;</span> <span class="nf">dp</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h3 id="63-不同路径-ii"><span class="mr-2">63. 不同路径 II</span><a href="#63-不同路径-ii" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>一个机器人位于一个 <code class="language-plaintext highlighter-rouge">m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。现在考虑网格中有障碍物，那么从左上角到右下角将会有多少条不同的路径？网格中的障碍物和空位置分别用 <code class="language-plaintext highlighter-rouge">1</code> 和 <code class="language-plaintext highlighter-rouge">0</code> 来表示。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">obstacleGrid</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]]</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">2</span>
<span class="n">解释</span><span class="err">：</span><span class="mi">3</span><span class="n">x3</span> <span class="n">网格的正中间有一个障碍物</span><span class="err">。</span>
<span class="n">从左上角到右下角一共有</span> <span class="mi">2</span> <span class="n">条不同的路径</span><span class="err">：</span>
<span class="mf">1.</span> <span class="n">向右</span> <span class="o">-&gt;</span> <span class="n">向右</span> <span class="o">-&gt;</span> <span class="n">向下</span> <span class="o">-&gt;</span> <span class="n">向下</span>
<span class="mf">2.</span> <span class="n">向下</span> <span class="o">-&gt;</span> <span class="n">向下</span> <span class="o">-&gt;</span> <span class="n">向右</span> <span class="o">-&gt;</span> <span class="n">向右</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">dp[i][j]</code>：表示从<code class="language-plaintext highlighter-rouge">(0, 0)</code> 出发，到 <code class="language-plaintext highlighter-rouge">(i, j)</code> 有<code class="language-plaintext highlighter-rouge">dp[i][j]</code>条不同的路径。</p><p>想要求<code class="language-plaintext highlighter-rouge">dp[i][j]</code>，只能有两个方向来推导出来，即<code class="language-plaintext highlighter-rouge">dp[i - 1][j] </code>和 <code class="language-plaintext highlighter-rouge">dp[i][j - 1]</code>。<code class="language-plaintext highlighter-rouge">dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</code>，因为<code class="language-plaintext highlighter-rouge">dp[i][j]</code>只有这两个方向过来。但这里需要注意一点，因为有了障碍，(<code class="language-plaintext highlighter-rouge">i, j)</code>如果就是障碍的话应该就保持初始状态（初始状态为0）。</p><p>初始化：如果(i, 0) 这条边有了障碍之后，障碍之后（包括障碍）都是走不到的位置了，所以障碍之后的<code class="language-plaintext highlighter-rouge">dp[i][0]</code>应该还是初始值0。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">int</span> <span class="nf">uniquePathsWithObstacles</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">obstacleGrid</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">obstacleGrid</span><span class="mf">.</span><span class="nf">size</span><span class="p">(),</span> <span class="n">n</span> <span class="o">=</span> <span class="n">obstacleGrid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="mf">.</span><span class="nf">size</span><span class="p">();</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&gt;</span> <span class="nf">dp</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span> <span class="o">&amp;&amp;</span> <span class="n">obstacleGrid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">obstacleGrid</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">obstacleGrid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span> <span class="c1">// 跳过障碍物</span>
                <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h3 id="64-最小路径和"><span class="mr-2">64. 最小路径和</span><a href="#64-最小路径和" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>给定一个包含非负整数的<code class="language-plaintext highlighter-rouge">m x n</code>网格 <code class="language-plaintext highlighter-rouge">grid</code> ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。<strong>说明：</strong>每次只能向下或者向右移动一步。</p><p><img data-src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205312040325.png" alt="image-20220531204021142" data-proofer-ignore></p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">grid</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">7</span>
<span class="n">解释</span><span class="err">：</span><span class="n">因为路径</span> <span class="mi">1</span><span class="err">→</span><span class="mi">3</span><span class="err">→</span><span class="mi">1</span><span class="err">→</span><span class="mi">1</span><span class="err">→</span><span class="mi">1</span> <span class="n">的总和最小</span><span class="err">。</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">dp[i][j]</code>：表示从<code class="language-plaintext highlighter-rouge">(0, 0)</code> 出发，到 <code class="language-plaintext highlighter-rouge">(i, j)</code> 路径上的数字总和最小为<code class="language-plaintext highlighter-rouge">dp[i][j]</code>。</p><p>想要求<code class="language-plaintext highlighter-rouge">dp[i][j]</code>，只能有两个方向来推导出来，即<code class="language-plaintext highlighter-rouge">dp[i - 1][j] </code>和 <code class="language-plaintext highlighter-rouge">dp[i][j - 1]</code>，取最小值。递推公式：<code class="language-plaintext highlighter-rouge">dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid(i)</code>。</p><p>初始化：根据定义有<code class="language-plaintext highlighter-rouge">d[0][0] = grid[0][0]</code>，而<code class="language-plaintext highlighter-rouge">d[i][0]</code>表示从原点一直往右走，数字总和逐渐增加<code class="language-plaintext highlighter-rouge">grid[i][0]</code>，<code class="language-plaintext highlighter-rouge">d[0][j]</code>同理。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">int</span> <span class="nf">minPathSum</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">grid</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">grid</span><span class="mf">.</span><span class="nf">size</span><span class="p">(),</span> <span class="n">n</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="mf">.</span><span class="nf">size</span><span class="p">();</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&gt;</span> <span class="nf">d</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
        <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
        <span class="k">for</span><span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="k">for</span><span class="p">(</span><span class="n">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">){</span>
            <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="k">for</span><span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="k">for</span><span class="p">(</span><span class="n">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">){</span>
                <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">d</span><span class="p">[</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h2 id="递增子序列"><span class="mr-2">递增子序列</span><a href="#递增子序列" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="300-最长递增子序列lis"><span class="mr-2">300. 最长递增子序列(LIS)</span><a href="#300-最长递增子序列lis" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>给你一个整数数组 <code class="language-plaintext highlighter-rouge">nums</code> ，找到其中最长严格递增子序列的长度。子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">nums</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">101</span><span class="p">,</span><span class="mi">18</span><span class="p">]</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">4</span>
<span class="n">解释</span><span class="err">：</span><span class="n">最长递增子序列是</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">101</span><span class="p">]</span><span class="err">，</span><span class="n">因此长度为</span> <span class="mi">4</span> <span class="err">。</span>
</pre></table></code></div></div><p><strong>数组<code class="language-plaintext highlighter-rouge">dp[i]</code> 表示以 <code class="language-plaintext highlighter-rouge">nums[i]</code> 这个数结尾（下标i之前，包括i）的最长递增子序列的长度，<code class="language-plaintext highlighter-rouge">dp</code> 数组中最大的那个值就是最长的递增子序列长度</strong>。</p><p>位置<code class="language-plaintext highlighter-rouge">i</code>的最长升序子序列等于<code class="language-plaintext highlighter-rouge">j</code>从<code class="language-plaintext highlighter-rouge">0</code>到<code class="language-plaintext highlighter-rouge">i-1</code>各个位置的最长升序子序列 + 1 的最大值，所以：<code class="language-plaintext highlighter-rouge">if (nums[i] &gt; nums[j]) dp[i] = max(dp[i], dp[j] + 1)</code>。<strong>注意这里不是要dp[i] 与 dp[j] + 1进行比较，而是要取dp[j] + 1的最大值</strong>。</p><p>根据这个定义可以推出 <strong>base case</strong>：<code class="language-plaintext highlighter-rouge">dp[i]</code> 初始值为 1，因为以 <code class="language-plaintext highlighter-rouge">nums[i]</code> 结尾的最长递增子序列起码要包含它自己。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">int</span> <span class="nf">lengthOfLIS</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// base case：dp 数组全都初始化为 1</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span> <span class="nf">dp</span><span class="p">(</span><span class="n">nums</span><span class="mf">.</span><span class="nf">size</span><span class="p">(),</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="mf">.</span><span class="nf">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="k">for</span><span class="p">(</span><span class="n">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">){</span>
                <span class="c1">// 寻找 nums[0..j-1] 中比 nums[i] 小的元素</span>
                <span class="k">if</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]){</span>
                    <span class="c1">// 把 nums[i] 接在后面，即可形成长度为 dp[j] + 1，</span>
                    <span class="c1">// 且以 nums[i] 为结尾的递增子序列</span>
                    <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="c1">// dp数组中的最大值即为最长的递增子序列长度</span>
            <span class="n">res</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h3 id="354-俄罗斯套娃信封问题"><span class="mr-2">354. 俄罗斯套娃信封问题</span><a href="#354-俄罗斯套娃信封问题" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>给你一个二维整数数组 envelopes ，其中 <code class="language-plaintext highlighter-rouge">envelopes[i] = [wi, hi]</code> ，表示第 <code class="language-plaintext highlighter-rouge">i </code>个信封的宽度和高度。当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。请计算<strong>最多</strong>能有多少个信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。注意：不允许旋转信封。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">envelopes</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]]</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">3</span>
<span class="n">解释</span><span class="err">：</span><span class="n">最多信封的个数为</span> <span class="mi">3</span><span class="p">,</span> <span class="n">组合为</span><span class="o">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span><span class="err">。</span>
</pre></table></code></div></div><p>这道题目其实是最长递增子序列的一个变种，因为每次合法的嵌套是大的套小的，相当于在二维平面中找一个最长递增的子序列，其长度就是最多能嵌套的信封个数。前面说的标准 LIS 算法只能在<strong>一维数组</strong>中寻找最长子序列，而我们的信封是由 <code class="language-plaintext highlighter-rouge">(w, h)</code> 这样的二维数对形式表示的，如何把 LIS 算法运用过来呢？</p><p><strong>先对宽度 <code class="language-plaintext highlighter-rouge">w</code> 进行升序排序，如果遇到 <code class="language-plaintext highlighter-rouge">w</code> 相同的情况，则按照高度 <code class="language-plaintext highlighter-rouge">h</code> 降序排序；之后把所有的 <code class="language-plaintext highlighter-rouge">h</code> 作为一个数组，在这个数组上计算 LIS 的长度就是答案</strong>。</p><p>首先，对宽度 <code class="language-plaintext highlighter-rouge">w</code> 从小到大排序，确保了 <code class="language-plaintext highlighter-rouge">w</code> 这个维度可以互相嵌套，所以我们只需要专注高度 <code class="language-plaintext highlighter-rouge">h</code> 这个维度能够互相嵌套即可。</p><p>其次，两个 <code class="language-plaintext highlighter-rouge">w</code> 相同的信封不能相互包含，<strong>所以对于宽度 <code class="language-plaintext highlighter-rouge">w</code> 相同的信封，对高度 <code class="language-plaintext highlighter-rouge">h</code> 进行降序排序</strong>，保证 LIS 中不存在多个 <code class="language-plaintext highlighter-rouge">w</code> 相同的信封（因为题目说了长宽相同也无法嵌套）。</p><p>画个图理解一下，先对这些数对进行排序，然后在 <code class="language-plaintext highlighter-rouge">h</code> 上寻找最长递增子序列，这个子序列就是最优的嵌套方案：</p><div align="center"><img data-src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205221612129.png" alt="image-20220522161215045" style="zoom:70%;" data-proofer-ignore></div><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">static</span> <span class="n">bool</span> <span class="nf">comp</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span> <span class="n">e1</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span> <span class="n">e2</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="n">e1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">e2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">return</span> <span class="n">e1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">e2</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
        <span class="k">else</span> <span class="k">return</span> <span class="n">e1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">e2</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="n">int</span> <span class="nf">maxEnvelopes</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">envelopes</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">envelopes</span><span class="mf">.</span><span class="nf">size</span><span class="p">();</span>
        <span class="nb">sort</span><span class="p">(</span><span class="n">envelopes</span><span class="mf">.</span><span class="nf">begin</span><span class="p">(),</span> <span class="n">envelopes</span><span class="mf">.</span><span class="nb">end</span><span class="p">(),</span> <span class="n">comp</span><span class="p">);</span>
        <span class="n">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span> <span class="nf">dp</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
        <span class="k">for</span><span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="k">for</span><span class="p">(</span><span class="n">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">){</span>
                <span class="k">if</span><span class="p">(</span><span class="n">envelopes</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">envelopes</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]){</span>
                    <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="n">res</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h3 id="674-最长连续递增序列"><span class="mr-2">674. 最长连续递增序列</span><a href="#674-最长连续递增序列" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>给定一个未经排序的整数数组，找到最长且<strong>连续递增</strong>的子序列，并返回该序列的长度。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">nums</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">3</span>
</pre></table></code></div></div><p>本题相对于<strong>300.最长递增子序列</strong>最大的区别在于“连续”，本题要求的是最长连续递增序列。</p><p><strong>数组<code class="language-plaintext highlighter-rouge">dp[i]</code>表示</strong>以下标<code class="language-plaintext highlighter-rouge">i</code>为结尾的数组的连续递增子序列长度为<code class="language-plaintext highlighter-rouge">dp[i]</code>。注意这里的定义，一定是以下标<code class="language-plaintext highlighter-rouge">i</code>为结尾，并不是说一定以下标0为起始位置。</p><p>如果 <code class="language-plaintext highlighter-rouge">nums[i + 1] &gt; nums[i]</code>，那么以 <code class="language-plaintext highlighter-rouge">i+1</code> 为结尾的数组的连续递增的子序列长度一定等于以<code class="language-plaintext highlighter-rouge">i</code>为结尾的数组的连续递增的子序列长度 + 1，即<code class="language-plaintext highlighter-rouge">dp[i + 1] = dp[i] + 1</code>（和<strong>300.最长递增子序列</strong>的不同之处），只需要一层for循环。</p><p><strong>初始化</strong>：以下标<code class="language-plaintext highlighter-rouge">i</code>为结尾的数组的连续递增的子序列长度最少也应该是1，即<code class="language-plaintext highlighter-rouge">nums[i]</code>这一个元素，所以<code class="language-plaintext highlighter-rouge">dp[i]</code>应该初始化为1;</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre> <span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
     <span class="n">int</span> <span class="nf">findLengthOfLCIS</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
         <span class="n">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="mf">.</span><span class="nf">size</span><span class="p">(),</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
         <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span> <span class="nf">d</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
         <span class="k">for</span><span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
             <span class="k">if</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]){</span>
                 <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
             <span class="p">}</span>
             <span class="n">res</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">res</span><span class="p">);</span>
         <span class="p">}</span>
         <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
     <span class="p">}</span>
 <span class="p">};</span>
</pre></table></code></div></div><h3 id="53-最大子数组和"><span class="mr-2">53. 最大子数组和</span><a href="#53-最大子数组和" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>给你一个整数数组 <code class="language-plaintext highlighter-rouge">nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。<strong>子数组</strong> 是数组中的一个连续部分。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">nums</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">6</span>
<span class="n">解释</span><span class="err">：</span><span class="n">连续子数组</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="n">的和最大</span><span class="err">，</span><span class="n">为</span> <span class="mi">6</span> <span class="err">。</span>
</pre></table></code></div></div><p>这道题不能用滑动窗口算法，因为数组中的数字可以是负数。</p><p><strong>定义 <code class="language-plaintext highlighter-rouge">dp</code> 数组：以 <code class="language-plaintext highlighter-rouge">nums[i]</code> 为结尾（下标i之前，包括i）的最大子数组和</strong>。</p><p><code class="language-plaintext highlighter-rouge">dp[i]</code> 有两种「选择」，要么与前面的相邻子数组连接，形成一个和更大的子数组；要么不与前面的子数组连接，自成一派，自己作为一个子数组。既然要求「最大子数组和」，当然选择结果更大的那个。</p><p>dp[i]只有两个方向可以推出来：</p><ul><li><code class="language-plaintext highlighter-rouge">dp[i - 1] + nums[i]</code>，即<code class="language-plaintext highlighter-rouge">nums[i]</code>加入当前连续子序列和；<li><code class="language-plaintext highlighter-rouge">nums[i]</code>，即从头开始计算当前连续子数组和；</ul><p>一定是取最大的，所以<code class="language-plaintext highlighter-rouge">dp[i] = max(dp[i - 1] + nums[i], nums[i])</code>。</p><p><strong>初始化</strong>：从递推公式可以看出来<code class="language-plaintext highlighter-rouge">dp[i]</code>是依赖于<code class="language-plaintext highlighter-rouge">dp[i - 1]</code>的状态的，<code class="language-plaintext highlighter-rouge">dp[0]</code>就是递推公式的基础。根据<code class="language-plaintext highlighter-rouge">dp[i]</code>的定义，很明显<code class="language-plaintext highlighter-rouge">dp[0]</code>应为<code class="language-plaintext highlighter-rouge">nums[0]</code>，即<code class="language-plaintext highlighter-rouge">dp[0] = nums[0]</code>。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">int</span> <span class="nf">maxSubArray</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">nums</span><span class="mf">.</span><span class="nf">size</span><span class="p">();</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span> <span class="nf">dp</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
        <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="n">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="k">for</span><span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span>
            <span class="n">res</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h3 id="718-最长重复子数组"><span class="mr-2">718. 最长重复子数组</span><a href="#718-最长重复子数组" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>给两个整数数组 <code class="language-plaintext highlighter-rouge">nums1</code> 和 <code class="language-plaintext highlighter-rouge">nums2</code> ，返回两个数组中公共的 、长度最长的子数组的长度。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">nums1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">nums2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">3</span>
<span class="n">解释</span><span class="err">：</span><span class="n">长度最长的公共子数组是</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="err">。</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">dp[i][j]</code>代表以下标<code class="language-plaintext highlighter-rouge">i - 1</code>为结尾的<code class="language-plaintext highlighter-rouge">nums1</code>，和以下标<code class="language-plaintext highlighter-rouge">j - 1</code>为结尾的<code class="language-plaintext highlighter-rouge">nums2</code>，最长重复子数组长度为<code class="language-plaintext highlighter-rouge">dp[i][j]</code>。</p><p>当<code class="language-plaintext highlighter-rouge">nums1[i - 1]</code> 和<code class="language-plaintext highlighter-rouge">nums2[j - 1]</code>相等的时候，<code class="language-plaintext highlighter-rouge">dp[i][j] = dp[i - 1][j - 1] + 1</code>。</p><p><strong>初始化</strong>：</p><p>根据<code class="language-plaintext highlighter-rouge">dp[i][j]</code>的定义，<code class="language-plaintext highlighter-rouge">dp[i][0]</code> 和<code class="language-plaintext highlighter-rouge">dp[0][j]</code>其实都是没有意义的！但<code class="language-plaintext highlighter-rouge">dp[i][0]</code> 和<code class="language-plaintext highlighter-rouge">dp[0][j]</code>要有初始值，因为为了方便递归公式<code class="language-plaintext highlighter-rouge">dp[i][j] = dp[i - 1][j - 1] + 1</code>，所以<code class="language-plaintext highlighter-rouge">dp[i][0]</code> 和<code class="language-plaintext highlighter-rouge">dp[0][j]</code>初始化为0。</p><blockquote><p>举个例子：nums1[0]如果和nums2[0]相同的话，<code class="language-plaintext highlighter-rouge">dp[1][1] = dp[0][0] + 1</code>，只有<code class="language-plaintext highlighter-rouge">dp[0][0]</code>初始为0，正好符合递推公式逐步累加起来。</p></blockquote><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">int</span> <span class="nf">findLength</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&amp;</span> <span class="n">nums1</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&amp;</span> <span class="n">nums2</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">nums1</span><span class="mf">.</span><span class="nf">size</span><span class="p">(),</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums2</span><span class="mf">.</span><span class="nf">size</span><span class="p">(),</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&gt;</span> <span class="nf">d</span><span class="p">(</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
        <span class="k">for</span><span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="k">for</span><span class="p">(</span><span class="n">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">){</span>
                <span class="k">if</span><span class="p">(</span><span class="n">nums1</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">nums2</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]){</span>
                    <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
                <span class="p">}</span>
                <span class="n">res</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h2 id="子序列问题"><span class="mr-2">子序列问题</span><a href="#子序列问题" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="392-判断子序列"><span class="mr-2">392. 判断子序列</span><a href="#392-判断子序列" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>给定字符串 <strong>s</strong> 和 <strong>t</strong> ，判断 <strong>s</strong> 是否为 <strong>t</strong> 的子序列。字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">s</span> <span class="o">=</span> <span class="s2">"abc"</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="s2">"ahbgdc"</span>
<span class="n">输出</span><span class="err">：</span><span class="kc">true</span>
</pre></table></code></div></div><p><strong>数组<code class="language-plaintext highlighter-rouge">dp[i][j] </code>表示</strong>以下标<code class="language-plaintext highlighter-rouge">i-1</code>为结尾的字符串<code class="language-plaintext highlighter-rouge">s</code>，和以下标<code class="language-plaintext highlighter-rouge">j-1</code>为结尾的字符串<code class="language-plaintext highlighter-rouge">t</code>，相同子序列的长度为<code class="language-plaintext highlighter-rouge">dp[i][j]</code>。</p><p>注意这里是判断s是否为t的子序列，即t的长度是大于等于s的。</p><p>两种情况：</p><ul><li><code class="language-plaintext highlighter-rouge">if (s[i - 1] == t[j - 1])</code>，t中找到了一个字符在s中也出现了，<code class="language-plaintext highlighter-rouge">dp[i][j] = dp[i - 1][j - 1] + 1</code>；<li><code class="language-plaintext highlighter-rouge">if (s[i - 1] != t[j - 1])</code>，相当于t要删除元素，继续匹配，<code class="language-plaintext highlighter-rouge">dp[i][j] = dp[i][j - 1]</code>；</ul><p><strong>初始化</strong>：其实这里只初始化<code class="language-plaintext highlighter-rouge">dp[i][0]</code>就够了，但一起初始化也方便，所以就一起操作了。</p><p>如果<code class="language-plaintext highlighter-rouge">dp[m][n]</code> 与 字符串<code class="language-plaintext highlighter-rouge">s</code>的长度相同，则说明s与t的最长相同子序列就是s，那么s 就是 t 的子序列，返回true，否则返回false。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">bool</span> <span class="nf">isSubsequence</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">,</span> <span class="n">string</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">s</span><span class="mf">.</span><span class="nf">size</span><span class="p">(),</span> <span class="n">n</span> <span class="o">=</span> <span class="n">t</span><span class="mf">.</span><span class="nf">size</span><span class="p">();</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&gt;</span> <span class="nf">d</span><span class="p">(</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
        <span class="k">for</span><span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="k">for</span><span class="p">(</span><span class="n">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">){</span>
                <span class="k">if</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">t</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]){</span>
                    <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
                <span class="p">}</span><span class="k">else</span><span class="p">{</span>
                    <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">if</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">n</span><span class="p">]</span> <span class="o">==</span> <span class="n">m</span><span class="p">)</span> <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
        <span class="k">else</span> <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h3 id="115-不同的子序列"><span class="mr-2">115. 不同的子序列</span><a href="#115-不同的子序列" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>给定一个字符串 <code class="language-plaintext highlighter-rouge">s</code> 和一个字符串 <code class="language-plaintext highlighter-rouge">t</code> ，计算在 <code class="language-plaintext highlighter-rouge">s</code> 的子序列中 <code class="language-plaintext highlighter-rouge">t</code> 出现的个数。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">s</span> <span class="o">=</span> <span class="s2">"rabbbit"</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="s2">"rabbit"</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">3</span>
</pre></table></code></div></div><p><strong>数组<code class="language-plaintext highlighter-rouge">dp[i][j]</code>表示</strong>以<code class="language-plaintext highlighter-rouge">i-1</code>为结尾的<code class="language-plaintext highlighter-rouge">s</code>子序列中出现以<code class="language-plaintext highlighter-rouge">j-1</code>为结尾的<code class="language-plaintext highlighter-rouge">t</code>的个数为<code class="language-plaintext highlighter-rouge">dp[i][j]</code>。</p><p>分析两种情况：</p><p>当<code class="language-plaintext highlighter-rouge">s[i - 1]</code> 与 <code class="language-plaintext highlighter-rouge">t[j - 1]</code><strong>相等</strong>时，<code class="language-plaintext highlighter-rouge">dp[i][j]</code>由两部分组成：一部分是用<code class="language-plaintext highlighter-rouge">s[i - 1]</code>来匹配，那么个数为<code class="language-plaintext highlighter-rouge">dp[i - 1][j - 1]</code>，一部分是不用<code class="language-plaintext highlighter-rouge">s[i - 1]</code>来匹配，个数为<code class="language-plaintext highlighter-rouge">dp[i - 1][j]</code>。所以当<code class="language-plaintext highlighter-rouge">s[i - 1]</code> 与 <code class="language-plaintext highlighter-rouge">t[j - 1]</code>相等时，<code class="language-plaintext highlighter-rouge">dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]</code>；</p><blockquote><p>为什么还要考虑 不用s[i - 1]来匹配，都相同了指定要匹配啊。</p><p>例如： s：bagg 和 t：bag ，s[3] 和 t[2]是相同的，但是字符串s也可以不用s[3]来匹配，即用s[0]s[1]s[2]组成的bag。当然也可以用s[3]来匹配，即：s[0]s[1]s[3]组成的bag。</p></blockquote><p>当<code class="language-plaintext highlighter-rouge">s[i - 1]</code> 与 <code class="language-plaintext highlighter-rouge">t[j - 1]</code>不相等时，<code class="language-plaintext highlighter-rouge">dp[i][j]</code>只由一部分组成，不用<code class="language-plaintext highlighter-rouge">s[i - 1]</code>来匹配，即<code class="language-plaintext highlighter-rouge">dp[i - 1][j]</code>，所以递推公式为<code class="language-plaintext highlighter-rouge">dp[i][j] = dp[i - 1][j]</code>。</p><p><strong>初始化</strong>：</p><p><code class="language-plaintext highlighter-rouge">dp[i][0]</code> 表示以<code class="language-plaintext highlighter-rouge">i-1</code>为结尾的<code class="language-plaintext highlighter-rouge">s</code>可以随便删除元素，出现空字符串的个数。那么<code class="language-plaintext highlighter-rouge">dp[i][0]</code>一定都是1，因为把以<code class="language-plaintext highlighter-rouge">i-1</code>为结尾的s，删除所有元素，出现空字符串的个数就是1。</p><p><code class="language-plaintext highlighter-rouge">dp[0][j]</code>表示空字符串s可以随便删除元素，出现以<code class="language-plaintext highlighter-rouge">j-1</code>为结尾的字符串t的个数。那么<code class="language-plaintext highlighter-rouge">dp[0][j]</code>一定都是0，s如论如何也变成不了t。</p><p><code class="language-plaintext highlighter-rouge">dp[0][0]</code>应该是1，空字符串s，可以删除0个元素，变成空字符串t。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">int</span> <span class="nf">numDistinct</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">,</span> <span class="n">string</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">s</span><span class="mf">.</span><span class="nf">size</span><span class="p">(),</span> <span class="n">n</span> <span class="o">=</span> <span class="n">t</span><span class="mf">.</span><span class="nf">size</span><span class="p">();</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">uint64_t</span><span class="o">&gt;&gt;</span> <span class="nf">d</span><span class="p">(</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">uint64_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
        <span class="c1">// base case</span>
        <span class="k">for</span><span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">for</span><span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="k">for</span><span class="p">(</span><span class="n">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">){</span>
                <span class="k">if</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">t</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]){</span>
                    <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
                <span class="p">}</span><span class="k">else</span><span class="p">{</span>
                    <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">d</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">n</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h3 id="1143-最长公共子序列"><span class="mr-2">1143. 最长公共子序列</span><a href="#1143-最长公共子序列" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>给定两个字符串 <code class="language-plaintext highlighter-rouge">text1 </code>和 <code class="language-plaintext highlighter-rouge">text2</code>，返回这两个字符串的<strong>最长公共子序列</strong>的长度。如果不存在公共子序列 ，返回 0 。</p><blockquote><p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。</p></blockquote><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">text1</span> <span class="o">=</span> <span class="s2">"abcde"</span><span class="p">,</span> <span class="n">text2</span> <span class="o">=</span> <span class="s2">"ace"</span> 
<span class="n">输出</span><span class="err">：</span><span class="mi">3</span>  
<span class="n">解释</span><span class="err">：</span><span class="n">最长公子序列是</span> <span class="s2">"ace"</span> <span class="err">，</span><span class="n">它的长度为</span> <span class="mi">3</span> <span class="err">。</span>
</pre></table></code></div></div><p><strong>数组<code class="language-plaintext highlighter-rouge">dp[i][j]</code> 表示</strong>索引范围为<code class="language-plaintext highlighter-rouge">[0, i - 1]</code>的字符串<code class="language-plaintext highlighter-rouge">text1</code>与索引范围为<code class="language-plaintext highlighter-rouge">[0, j - 1]</code>的字符串<code class="language-plaintext highlighter-rouge">text2</code>的最长公共子序列为<code class="language-plaintext highlighter-rouge">dp[i][j]</code>。</p><p>有两种情况：</p><p>如果<code class="language-plaintext highlighter-rouge">text1[i - 1]</code> 与<code class="language-plaintext highlighter-rouge"> text2[j - 1]</code><strong>相同</strong>，那么找到了一个公共元素，所以<code class="language-plaintext highlighter-rouge">dp[i][j] = dp[i - 1][j - 1] + 1</code>；</p><p>如果<code class="language-plaintext highlighter-rouge">text1[i - 1] </code>与<code class="language-plaintext highlighter-rouge"> text2[j - 1]</code><strong>不相同</strong>，那就看看<code class="language-plaintext highlighter-rouge">text1[0, i - 2]</code>与<code class="language-plaintext highlighter-rouge">text2[0, j - 1]</code>的最长公共子序列和 <code class="language-plaintext highlighter-rouge">text1[0, i - 1]</code>与<code class="language-plaintext highlighter-rouge">text2[0, j - 2]</code>的最长公共子序列，取最大的，即<code class="language-plaintext highlighter-rouge">dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])</code>。</p><p><strong>初始化</strong>：<code class="language-plaintext highlighter-rouge">test1[0, i-1]</code>和空串的最长公共子序列自然是0，所以<code class="language-plaintext highlighter-rouge">dp[i][0] = 0</code>，同理<code class="language-plaintext highlighter-rouge">dp[0][j]</code>也是0。其他下标都是随着递推公式逐步覆盖，初始为多少都可以，那么就统一初始为0。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">int</span> <span class="nf">longestCommonSubsequence</span><span class="p">(</span><span class="n">string</span> <span class="n">text1</span><span class="p">,</span> <span class="n">string</span> <span class="n">text2</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">text1</span><span class="mf">.</span><span class="nf">size</span><span class="p">(),</span> <span class="n">n</span> <span class="o">=</span> <span class="n">text2</span><span class="mf">.</span><span class="nf">size</span><span class="p">();</span>
        <span class="c1">// base case: dp[0][..] = dp[..][0] = 0</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&gt;</span> <span class="nf">dp</span><span class="p">(</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
        <span class="k">for</span><span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="k">for</span><span class="p">(</span><span class="n">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">){</span>
                <span class="c1">// 现在 i 和 j 从 1 开始，所以要减一</span>
                <span class="k">if</span><span class="p">(</span><span class="n">text1</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">text2</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]){</span>
                    <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
                <span class="p">}</span><span class="k">else</span><span class="p">{</span>
                    <span class="c1">// s1[i-1] 和 s2[j-1] 至少有一个不在 lcs 中</span>
                    <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]);</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">n</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h3 id="1035-不相交的线"><span class="mr-2">1035. 不相交的线</span><a href="#1035-不相交的线" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>在两条独立的水平线上按给定的顺序写下<code class="language-plaintext highlighter-rouge"> nums1</code> 和 <code class="language-plaintext highlighter-rouge">nums2 </code>中的整数。现在，可以绘制一些连接两个数字 <code class="language-plaintext highlighter-rouge">nums1[i] </code>和 <code class="language-plaintext highlighter-rouge">nums2[j]</code> 的直线，这些直线需要同时满足满足： <code class="language-plaintext highlighter-rouge">nums1[i] == nums2[j]</code>且绘制的直线不与任何其他连线（非水平线）相交。</p><p>请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。以这种方法绘制线条，并返回可以绘制的最大连线数。</p><div align="center"><img data-src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205242018036.png" alt="image-20220524201854963" style="zoom:70%;" data-proofer-ignore></div><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">nums1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">nums2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">2</span>
</pre></table></code></div></div><p>直线不能相交，这就是说明在字符串A中 找到一个与字符串B相同的子序列，且<strong>这个子序列不能改变相对顺序</strong>，只要相对顺序不改变，链接相同数字的直线就不会相交。<strong>本题说是求绘制的最大连线数，其实就是求两个字符串的最长公共子序列的长度！</strong></p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">int</span> <span class="nf">maxUncrossedLines</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&amp;</span> <span class="n">nums1</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&amp;</span> <span class="n">nums2</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">nums1</span><span class="mf">.</span><span class="nf">size</span><span class="p">(),</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums2</span><span class="mf">.</span><span class="nf">size</span><span class="p">();</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&gt;</span> <span class="nf">d</span><span class="p">(</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
        <span class="k">for</span><span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="k">for</span><span class="p">(</span><span class="n">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">){</span>
                <span class="k">if</span><span class="p">(</span><span class="n">nums1</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">nums2</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]){</span>
                    <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
                <span class="p">}</span><span class="k">else</span><span class="p">{</span>
                    <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">d</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">n</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h3 id="583-两个字符串的删除操作"><span class="mr-2">583. 两个字符串的删除操作</span><a href="#583-两个字符串的删除操作" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>给定两个单词 <code class="language-plaintext highlighter-rouge">word1</code> 和 <code class="language-plaintext highlighter-rouge">word2</code> ，返回使得 <code class="language-plaintext highlighter-rouge">word1</code> 和 <code class="language-plaintext highlighter-rouge">word2</code> <strong>相同</strong>所需的<strong>最小步数</strong>。<strong>每步</strong> 可以删除任意一个字符串中的一个字符。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="o">:</span> <span class="n">word1</span> <span class="o">=</span> <span class="s2">"sea"</span><span class="p">,</span> <span class="n">word2</span> <span class="o">=</span> <span class="s2">"eat"</span>
<span class="n">输出</span><span class="o">:</span> <span class="mi">2</span>
<span class="n">解释</span><span class="o">:</span> <span class="n">第一步将</span> <span class="s2">"sea"</span> <span class="n">变为</span> <span class="s2">"ea"</span> <span class="err">，</span><span class="n">第二步将</span> <span class="s2">"eat "</span><span class="n">变为</span> <span class="s2">"ea"</span>
</pre></table></code></div></div><p>删除的结果不就是它俩的最长公共子序列嘛！要计算删除的次数，就可以通过<strong>最长公共子序列</strong>的长度推导出来。只要求出两个字符串的最长公共子序列长度即可，除了最长公共子序列之外的字符都是必须删除的，最后用两个字符串的总长度减去两个最长公共子序列的长度就是删除的最少步数。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">int</span> <span class="nf">minDistance</span><span class="p">(</span><span class="n">string</span> <span class="n">word1</span><span class="p">,</span> <span class="n">string</span> <span class="n">word2</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">word1</span><span class="mf">.</span><span class="nf">size</span><span class="p">(),</span> <span class="n">n</span> <span class="o">=</span> <span class="n">word2</span><span class="mf">.</span><span class="nf">size</span><span class="p">();</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&gt;</span> <span class="nf">dp</span><span class="p">(</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
        <span class="k">for</span><span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="k">for</span><span class="p">(</span><span class="n">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">){</span>
                <span class="k">if</span><span class="p">(</span><span class="n">word1</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">word2</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]){</span>
                    <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
                <span class="p">}</span><span class="k">else</span><span class="p">{</span>
                    <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]);</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">m</span> <span class="o">+</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">dp</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">n</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h3 id="712-两个字符串的最小ascii删除和"><span class="mr-2">712. 两个字符串的最小ASCII删除和</span><a href="#712-两个字符串的最小ascii删除和" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>给定两个字符串<code class="language-plaintext highlighter-rouge">s1</code> 和 <code class="language-plaintext highlighter-rouge">s2</code>，返回使两个字符串相等所需删除字符的 <strong>ASCII</strong> 值的最小和 。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="o">:</span> <span class="n">s1</span> <span class="o">=</span> <span class="s2">"sea"</span><span class="p">,</span> <span class="n">s2</span> <span class="o">=</span> <span class="s2">"eat"</span>
<span class="n">输出</span><span class="o">:</span> <span class="mi">231</span>
<span class="n">解释</span><span class="o">:</span> <span class="n">在</span> <span class="s2">"sea"</span> <span class="n">中删除</span> <span class="s2">"s"</span> <span class="n">并将</span> <span class="s2">"s"</span> <span class="nf">的值</span><span class="p">(</span><span class="mi">115</span><span class="p">)</span><span class="n">加入总和</span><span class="err">。</span>
<span class="n">在</span> <span class="s2">"eat"</span> <span class="n">中删除</span> <span class="s2">"t"</span> <span class="n">并将</span> <span class="mi">116</span> <span class="n">加入总和</span><span class="err">。</span>
<span class="n">结束时</span><span class="err">，</span><span class="n">两个字符串相等</span><span class="err">，</span><span class="mi">115</span> <span class="o">+</span> <span class="mi">116</span> <span class="o">=</span> <span class="mi">231</span> <span class="n">就是符合条件的最小和</span><span class="err">。</span>
</pre></table></code></div></div><p>删除的 ascii 最小，那么保留的公共子串 ascii 最大，<strong>问题转化为：求最大ascii公共子串</strong>。</p><p><strong>数组 <code class="language-plaintext highlighter-rouge">dp[i][j] </code>表示</strong> 索引范围为<code class="language-plaintext highlighter-rouge">[0, i - 1]</code>的字符串<code class="language-plaintext highlighter-rouge">s1</code>与索引范围为<code class="language-plaintext highlighter-rouge">[0, j - 1]</code>的字符串<code class="language-plaintext highlighter-rouge">s2</code>的最大ascii公共子串的ascii值。</p><p>有两种情况：</p><p>如果<code class="language-plaintext highlighter-rouge">s1[i - 1]</code> 与<code class="language-plaintext highlighter-rouge"> s2[j - 1]</code><strong>相同</strong>，那么找到了一个公共元素，所以<code class="language-plaintext highlighter-rouge">dp[i][j] = dp[i - 1][j - 1] + s1[i - 1]</code>；</p><p>如果<code class="language-plaintext highlighter-rouge">s1[i - 1] </code>与<code class="language-plaintext highlighter-rouge"> s2[j - 1]</code><strong>不相同</strong>，那就看看<code class="language-plaintext highlighter-rouge">s1[0, i - 2]</code>与<code class="language-plaintext highlighter-rouge">s2[0, j - 1]</code>的最大ascii公共子串的ascii值和 <code class="language-plaintext highlighter-rouge">s1[0, i - 1]</code>与<code class="language-plaintext highlighter-rouge">s2[0, j - 2]</code>的最大ascii公共子串的ascii值，取最大的，即<code class="language-plaintext highlighter-rouge">dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])</code>。</p><p><strong>初始化</strong>：当<code class="language-plaintext highlighter-rouge">i</code>或<code class="language-plaintext highlighter-rouge">j</code>为0时，没有公共子串，此时状态为0。</p><p><strong>初始化</strong>：<code class="language-plaintext highlighter-rouge">s1[0, i-1]</code>和空串的最大ascii公共子串的ascii值自然是0，所以<code class="language-plaintext highlighter-rouge">dp[i][0] = 0</code>，同理<code class="language-plaintext highlighter-rouge">dp[0][j]</code>也是0。其他下标都是随着递推公式逐步覆盖，初始为多少都可以，那么就统一初始为0。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">int</span> <span class="nf">minimumDeleteSum</span><span class="p">(</span><span class="n">string</span> <span class="n">s1</span><span class="p">,</span> <span class="n">string</span> <span class="n">s2</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">s1</span><span class="mf">.</span><span class="nf">size</span><span class="p">(),</span> <span class="n">n</span> <span class="o">=</span> <span class="n">s2</span><span class="mf">.</span><span class="nf">size</span><span class="p">();</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&gt;</span> <span class="nf">dp</span><span class="p">(</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
        <span class="k">for</span><span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="k">for</span><span class="p">(</span><span class="n">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">){</span>
                <span class="k">if</span><span class="p">(</span><span class="n">s1</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">s2</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]){</span>
                    <span class="c1">// i - 1位的ascii与[0 ~ i - 1]最小ascii之和</span>
                    <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">s1</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
                <span class="p">}</span><span class="k">else</span><span class="p">{</span>
                    <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]);</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="c1">//计算s1和s2总的ascii</span>
        <span class="n">int</span> <span class="n">ascii1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ascii2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="n">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">s1</span><span class="p">)</span> <span class="n">acsii1</span> <span class="o">+=</span> <span class="n">c</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="n">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">s2</span><span class="p">)</span> <span class="n">acsii2</span> <span class="o">+=</span> <span class="n">c</span><span class="p">;</span>
        <span class="c1">// 总的ascii减去最大ascii公共子串的ascii值即为所求</span>
        <span class="k">return</span> <span class="n">ascii1</span> <span class="o">-</span> <span class="n">dp</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="n">ascii2</span> <span class="o">-</span> <span class="n">dp</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">n</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h3 id="72-编辑距离"><span class="mr-2">72. 编辑距离</span><a href="#72-编辑距离" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>给你两个单词 <code class="language-plaintext highlighter-rouge">word1 </code>和 <code class="language-plaintext highlighter-rouge">word2</code>， 请返回将 <code class="language-plaintext highlighter-rouge">word1 </code>转换成 <code class="language-plaintext highlighter-rouge">word2 </code>所使用的最少操作数。你可以对一个单词进行如下三种操作：插入一个字符、删除一个字符、替换一个字符。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">word1</span> <span class="o">=</span> <span class="s2">"horse"</span><span class="p">,</span> <span class="n">word2</span> <span class="o">=</span> <span class="s2">"ros"</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">3</span>
<span class="n">解释</span><span class="err">：</span>
<span class="n">horse</span> <span class="o">-&gt;</span> <span class="nf">rorse</span> <span class="p">(</span><span class="n">将</span> <span class="s1">'h'</span> <span class="n">替换为</span> <span class="s1">'r'</span><span class="p">)</span>
<span class="n">rorse</span> <span class="o">-&gt;</span> <span class="nf">rose</span> <span class="p">(</span><span class="n">删除</span> <span class="s1">'r'</span><span class="p">)</span>
<span class="n">rose</span> <span class="o">-&gt;</span> <span class="nf">ros</span> <span class="p">(</span><span class="n">删除</span> <span class="s1">'e'</span><span class="p">)</span>
</pre></table></code></div></div><p><strong>数组<code class="language-plaintext highlighter-rouge">dp[i][j]</code> 表示</strong>以下标<code class="language-plaintext highlighter-rouge">i-1</code>为结尾的字符串<code class="language-plaintext highlighter-rouge">word1</code>，和以下标<code class="language-plaintext highlighter-rouge">j-1</code>为结尾的字符串<code class="language-plaintext highlighter-rouge">word2</code>，最近编辑距离为<code class="language-plaintext highlighter-rouge">dp[i][j]</code>。</p><p>在确定递推公式的时候，首先要考虑清楚编辑的几种操作，整理如下：</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">if</span> <span class="p">(</span><span class="n">word1</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">word2</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
    <span class="n">不操作</span>
<span class="k">if</span> <span class="p">(</span><span class="n">word1</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">word2</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
    <span class="n">增</span>
    <span class="n">删</span>
    <span class="n">换</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">if (word1[i - 1] == word2[j - 1])</code> 那么说明不用任何编辑，<code class="language-plaintext highlighter-rouge">dp[i][j]</code> 就应该是 <code class="language-plaintext highlighter-rouge">dp[i - 1][j - 1]</code>，即<code class="language-plaintext highlighter-rouge">dp[i][j] = dp[i - 1][j - 1]</code>；</p><p><code class="language-plaintext highlighter-rouge">if (word1[i - 1] != word2[j - 1])</code>，此时就需要编辑了，如何编辑呢？</p><p><strong>操作一</strong>：word1删除一个元素，那么就是以下标<code class="language-plaintext highlighter-rouge">i - 2</code>为结尾的word1 与<code class="language-plaintext highlighter-rouge"> j-1</code>为结尾的word2的最近编辑距离 再加上一个操作，即 <code class="language-plaintext highlighter-rouge">dp[i][j] = dp[i - 1][j] + 1;</code></p><p><strong>操作二</strong>：word2删除一个元素，那么就是以下标<code class="language-plaintext highlighter-rouge">i - 1</code>为结尾的word1 与<code class="language-plaintext highlighter-rouge"> j-2</code>为结尾的word2的最近编辑距离 再加上一个操作，即 <code class="language-plaintext highlighter-rouge">dp[i][j] = dp[i][j - 1] + 1;</code></p><p>怎么都是删除元素，添加元素去哪了？<strong>word2添加一个元素，相当于word1删除一个元素</strong>，例如 <code class="language-plaintext highlighter-rouge">word1 = "ad" ，word2 = "a"</code>，<code class="language-plaintext highlighter-rouge">word1</code>删除元素<code class="language-plaintext highlighter-rouge">'d'</code> 和 <code class="language-plaintext highlighter-rouge">word2</code>添加一个元素<code class="language-plaintext highlighter-rouge">'d'</code>，变成<code class="language-plaintext highlighter-rouge">word1="a", word2="ad"</code>， 最终的操作数是一样！</p><p><strong>操作三</strong>：替换元素，<code class="language-plaintext highlighter-rouge">word1</code>替换<code class="language-plaintext highlighter-rouge">word1[i - 1]</code>，使其与<code class="language-plaintext highlighter-rouge">word2[j - 1]</code>相同，此时不用增加元素，那么以下标<code class="language-plaintext highlighter-rouge">i-2</code>为结尾的<code class="language-plaintext highlighter-rouge">word1</code> 与 <code class="language-plaintext highlighter-rouge">j-2</code>为结尾的<code class="language-plaintext highlighter-rouge">word2</code>的最近编辑距离 加上一个替换元素的操作，即 <code class="language-plaintext highlighter-rouge">dp[i][j] = dp[i - 1][j - 1] + 1;</code></p><p>综上，当 <code class="language-plaintext highlighter-rouge">if (word1[i - 1] != word2[j - 1])</code> 时取最小的，即<code class="language-plaintext highlighter-rouge">dp[i][j] = min({dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]}) + 1;</code></p><p><strong>初始化</strong>：<code class="language-plaintext highlighter-rouge">dp[i][0]</code>是<code class="language-plaintext highlighter-rouge">i</code>，对word1里的元素全部做删除操作，即：<code class="language-plaintext highlighter-rouge">dp[i][0] = i</code>，同理<code class="language-plaintext highlighter-rouge">dp[0][j] = j</code>。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">int</span> <span class="nf">minDistance</span><span class="p">(</span><span class="n">string</span> <span class="n">word1</span><span class="p">,</span> <span class="n">string</span> <span class="n">word2</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">word1</span><span class="mf">.</span><span class="nf">size</span><span class="p">(),</span> <span class="n">n</span> <span class="o">=</span> <span class="n">word2</span><span class="mf">.</span><span class="nf">size</span><span class="p">();</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&gt;</span> <span class="nf">d</span><span class="p">(</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
        <span class="c1">// base case</span>
        <span class="c1">// dp[i][0] = i，对word1里的元素全部做删除操作        </span>
        <span class="k">for</span><span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">for</span><span class="p">(</span><span class="n">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">){</span>
            <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">for</span><span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="k">for</span><span class="p">(</span><span class="n">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">){</span>
                <span class="k">if</span><span class="p">(</span><span class="n">word1</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">word2</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]){</span>
                    <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
                <span class="p">}</span><span class="k">else</span><span class="p">{</span>
                    <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">min</span><span class="p">({</span><span class="n">d</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]});</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">d</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">n</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h2 id="回文序列"><span class="mr-2">回文序列</span><a href="#回文序列" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="516-最长回文子序列"><span class="mr-2">516. 最长回文子序列</span><a href="#516-最长回文子序列" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>给你一个字符串 <code class="language-plaintext highlighter-rouge">s</code> ，找出其中最长的回文子序列，并返回该序列的长度。子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre> <span class="n">输入</span><span class="err">：</span><span class="n">s</span> <span class="o">=</span> <span class="s2">"bbbab"</span>
 <span class="n">输出</span><span class="err">：</span><span class="mi">4</span>
 <span class="n">解释</span><span class="err">：</span><span class="n">一个可能的最长回文子序列为</span> <span class="s2">"bbbb"</span> <span class="err">。</span>
</pre></table></code></div></div><p><strong>数组<code class="language-plaintext highlighter-rouge">dp[i][j]</code>表示</strong>字符串<code class="language-plaintext highlighter-rouge">s</code>在<code class="language-plaintext highlighter-rouge">[i, j]</code>范围内的最长回文子序列的长度为<code class="language-plaintext highlighter-rouge">dp[i][j]</code>。</p><p><strong>如果<code class="language-plaintext highlighter-rouge">s[i]</code>与<code class="language-plaintext highlighter-rouge">s[j]</code>相同</strong>，那么<code class="language-plaintext highlighter-rouge">dp[i][j] = dp[i + 1][j - 1] + 2</code>，即加上 <code class="language-plaintext highlighter-rouge">s[i+1..j-1]</code> 中的最长回文子序列就是 <code class="language-plaintext highlighter-rouge">s[i..j]</code> 的最长回文子序列。</p><p><strong>如果<code class="language-plaintext highlighter-rouge">s[i]</code>与<code class="language-plaintext highlighter-rouge">s[j]</code>不相同</strong>，说明<code class="language-plaintext highlighter-rouge">s[i]</code>和<code class="language-plaintext highlighter-rouge">s[j]</code>同时加入并不能增加<code class="language-plaintext highlighter-rouge">[i,j]</code>区间内回文子串的长度，那么<code class="language-plaintext highlighter-rouge">dp[i + 1][j - 1]</code>分别加入<code class="language-plaintext highlighter-rouge">s[i]</code>、<code class="language-plaintext highlighter-rouge">s[j]</code>看看哪一个可以组成最长的回文子序列。加入<code class="language-plaintext highlighter-rouge">s[j]</code>的回文子序列长度为<code class="language-plaintext highlighter-rouge">dp[i + 1][j]</code>，加入<code class="language-plaintext highlighter-rouge">s[i]</code>的回文子序列长度为<code class="language-plaintext highlighter-rouge">dp[i][j - 1]</code>，那么<code class="language-plaintext highlighter-rouge">dp[i][j]</code>一定是取最大的，即：<code class="language-plaintext highlighter-rouge">dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])</code>。</p><p><strong>初始化</strong>：</p><p>首先要考虑当<code class="language-plaintext highlighter-rouge">i</code> 和<code class="language-plaintext highlighter-rouge">j</code> 相同的情况，从递推公式<code class="language-plaintext highlighter-rouge">dp[i][j] = dp[i + 1][j - 1] + 2</code> 可以看出递推公式是计算不到<code class="language-plaintext highlighter-rouge"> i </code>和<code class="language-plaintext highlighter-rouge">j</code>相同时候的情况，所以需要手动初始化一下。</p><p>当<code class="language-plaintext highlighter-rouge">i</code>与<code class="language-plaintext highlighter-rouge">j</code>相同，那么<code class="language-plaintext highlighter-rouge">dp[i][j]</code>一定是等于1的，即一个字符的回文子序列长度就是1。其他情况<code class="language-plaintext highlighter-rouge">dp[i][j]</code>初始为0就行，这样递推公式<code class="language-plaintext highlighter-rouge">dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]) </code>中<code class="language-plaintext highlighter-rouge">dp[i][j]</code>才不会被初始值覆盖。</p><p><strong>遍历顺序</strong>：</p><p>从递推公式<code class="language-plaintext highlighter-rouge">dp[i][j] = dp[i + 1][j - 1] + 2</code> 和 <code class="language-plaintext highlighter-rouge">dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]) </code>可以看出，<code class="language-plaintext highlighter-rouge">dp[i][j]</code>是依赖于<code class="language-plaintext highlighter-rouge">dp[i + 1][j - 1] </code>和 <code class="language-plaintext highlighter-rouge">dp[i + 1][j]</code>，也就是从矩阵的角度来说，<code class="language-plaintext highlighter-rouge">dp[i][j] </code>下一行的数据。 <strong>所以遍历i的时候一定要从下到上遍历，这样才能保证，下一行的数据是经过计算的</strong>。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">int</span> <span class="nf">longestPalindromeSubseq</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="mf">.</span><span class="nf">size</span><span class="p">();</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&gt;</span> <span class="nf">dp</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">n</span><span class="p">));</span>
        <span class="c1">// base case</span>
        <span class="k">for</span><span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// 反着遍历保证正确的状态转移</span>
        <span class="k">for</span><span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">){</span>
            <span class="k">for</span><span class="p">(</span><span class="n">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">){</span>
                <span class="k">if</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">]){</span>
                    <span class="c1">// 它俩一定在最长回文子序列中</span>
                    <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
                <span class="p">}</span><span class="k">else</span><span class="p">{</span>
                    <span class="c1">// s[i+1..j] 和 s[i..j-1] 谁的回文子序列更长?</span>
                    <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="c1">// 整个 s 的最长回文子串长度</span>
        <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h3 id="647-回文子串"><span class="mr-2">647. 回文子串</span><a href="#647-回文子串" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>给你一个字符串 <code class="language-plaintext highlighter-rouge">s</code> ，请你统计并返回这个字符串中<strong>回文子串</strong> 的数目。</p><p>回文字符串是正着读和倒过来读一样的字符串，子字符串 是字符串中的由连续字符组成的一个序列。具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">s</span> <span class="o">=</span> <span class="s2">"abc"</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">3</span>
<span class="n">解释</span><span class="err">：</span><span class="n">三个回文子串</span><span class="o">:</span> <span class="s2">"a"</span><span class="p">,</span> <span class="s2">"b"</span><span class="p">,</span> <span class="s2">"c"</span>
<span class="n">输入</span><span class="err">：</span><span class="n">s</span> <span class="o">=</span> <span class="s2">"aaa"</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">6</span>
<span class="n">解释</span><span class="err">：</span><span class="mi">6</span><span class="n">个回文子串</span><span class="o">:</span> <span class="s2">"a"</span><span class="p">,</span> <span class="s2">"a"</span><span class="p">,</span> <span class="s2">"a"</span><span class="p">,</span> <span class="s2">"aa"</span><span class="p">,</span> <span class="s2">"aa"</span><span class="p">,</span> <span class="s2">"aaa"</span>
</pre></table></code></div></div><p><strong>布尔类型的<code class="language-plaintext highlighter-rouge">dp[i][j]</code>表示</strong>区间范围<code class="language-plaintext highlighter-rouge">[i,j] </code>（注意是左闭右闭）的子串是否是回文子串，如果是<code class="language-plaintext highlighter-rouge">dp[i][j]</code>为true，否则为false。</p><p>当<code class="language-plaintext highlighter-rouge">s[i]</code>与<code class="language-plaintext highlighter-rouge">s[j]</code>不相等，<code class="language-plaintext highlighter-rouge">dp[i][j]</code>一定是false；当<code class="language-plaintext highlighter-rouge">s[i]</code>与<code class="language-plaintext highlighter-rouge">s[j]</code>相等时，有如下三种情况：</p><ul><li>情况一：下标<code class="language-plaintext highlighter-rouge">i</code> 与 <code class="language-plaintext highlighter-rouge">j</code>相同，同一个字符例如<code class="language-plaintext highlighter-rouge">a</code>，当然是回文子串<li>情况二：下标<code class="language-plaintext highlighter-rouge">i</code> 与 <code class="language-plaintext highlighter-rouge">j</code>相差为1，例如<code class="language-plaintext highlighter-rouge">aa</code>，也是回文子串<li>情况三：下标：<code class="language-plaintext highlighter-rouge">i</code> 与 <code class="language-plaintext highlighter-rouge">j</code>相差大于1的时候，例如<code class="language-plaintext highlighter-rouge">cabac</code>，此时<code class="language-plaintext highlighter-rouge">s[i]</code>与<code class="language-plaintext highlighter-rouge">s[j]</code>已经相同了，我们看<code class="language-plaintext highlighter-rouge">i</code>到<code class="language-plaintext highlighter-rouge">j</code>区间是不是回文子串就看<code class="language-plaintext highlighter-rouge">aba</code>是不是回文就可以了。<code class="language-plaintext highlighter-rouge">aba</code>的区间就是<code class="language-plaintext highlighter-rouge"> i+1 </code>与<code class="language-plaintext highlighter-rouge"> j-1</code>区间，这个区间是不是回文就看<code class="language-plaintext highlighter-rouge">dp[i + 1][j - 1]</code>是否为true。</ul><p><strong>初始化</strong>：<code class="language-plaintext highlighter-rouge">dp[i][j]</code>初始化为false。</p><p><strong>遍历顺序</strong>：首先从递推公式中可以看出，情况三是根据<code class="language-plaintext highlighter-rouge">dp[i + 1][j - 1]</code>是否为true，再对<code class="language-plaintext highlighter-rouge">dp[i][j]</code>进行赋值true的。所以一定要从下到上，从左到右遍历，这样保证<code class="language-plaintext highlighter-rouge">dp[i + 1][j - 1]</code>都是经过计算的。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">int</span> <span class="nf">countSubstrings</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">bool</span><span class="o">&gt;&gt;</span> <span class="nf">dp</span><span class="p">(</span><span class="n">s</span><span class="mf">.</span><span class="nf">size</span><span class="p">(),</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">bool</span><span class="o">&gt;</span><span class="p">(</span><span class="n">s</span><span class="mf">.</span><span class="nf">size</span><span class="p">(),</span> <span class="kc">false</span><span class="p">));</span>
        <span class="n">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="mf">.</span><span class="nf">size</span><span class="p">();</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// 三种情况全部包含</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]))</span> <span class="p">{</span>
                    <span class="n">res</span><span class="o">++</span><span class="p">;</span>
                    <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h3 id="1312-让字符串成为回文串的最少插入次数"><span class="mr-2">1312. 让字符串成为回文串的最少插入次数</span><a href="#1312-让字符串成为回文串的最少插入次数" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>给你一个字符串 <code class="language-plaintext highlighter-rouge">s</code> ，每一次操作你都可以在字符串的任意位置插入任意字符，请你返回让 <code class="language-plaintext highlighter-rouge">s</code> 成为回文串的 最少操作次数 。「回文串」是正读和反读都相同的字符串。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">s</span> <span class="o">=</span> <span class="s2">"zzazz"</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">0</span>
<span class="n">解释</span><span class="err">：</span><span class="n">字符串</span> <span class="s2">"zzazz"</span> <span class="n">已经是回文串了</span><span class="err">，</span><span class="n">所以不需要做任何插入操作</span><span class="err">。</span>
    
<span class="n">输入</span><span class="err">：</span><span class="n">s</span> <span class="o">=</span> <span class="s2">"mbadm"</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">2</span>
<span class="n">解释</span><span class="err">：</span><span class="n">字符串可变为</span> <span class="s2">"mbdadbm"</span> <span class="n">或者</span> <span class="s2">"mdbabdm"</span> <span class="err">。</span>
</pre></table></code></div></div><p><a href="https://cloud.tencent.com/developer/article/1880906">回文问题终极篇：最小代价构造回文串 - 云+社区 - 腾讯云 (tencent.com)</a></p><p><strong>二维数组<code class="language-plaintext highlighter-rouge">dp[i][j]</code>表示对字符串<code class="language-plaintext highlighter-rouge">s[i..j]</code>最少需要进行<code class="language-plaintext highlighter-rouge">dp[i][j]</code>次插入才能变成回文串</strong>。想求<code class="language-plaintext highlighter-rouge">s</code>的最少插入次数，也就是求<code class="language-plaintext highlighter-rouge">dp[0][n - 1]</code>的大小（<code class="language-plaintext highlighter-rouge">n</code>为<code class="language-plaintext highlighter-rouge">s</code>的长度）。</p><p>当算出<code class="language-plaintext highlighter-rouge">dp[i+1][j-1]</code>，即知道了<code class="language-plaintext highlighter-rouge">s[i+1..j-1]</code>成为回文串的最小插入次数，那么也就可以认为<code class="language-plaintext highlighter-rouge">s[i+1..j-1]</code>已经是一个回文串了，所以通过<code class="language-plaintext highlighter-rouge">dp[i+1][j-1]</code>推导<code class="language-plaintext highlighter-rouge">dp[i][j]</code>的<strong>关键就在于<code class="language-plaintext highlighter-rouge">s[i]</code>和<code class="language-plaintext highlighter-rouge">s[j]</code>这两个字符</strong>。</p><p>如果<code class="language-plaintext highlighter-rouge">s[i] == s[j]</code>，不需要进行任何插入，只要知道如何把<code class="language-plaintext highlighter-rouge">s[i+1..j-1]</code>变成回文串即可。</p><p>如果<code class="language-plaintext highlighter-rouge">s[i] != s[j]</code>，有如下步骤：</p><p><strong>步骤一</strong>，做选择，先将<code class="language-plaintext highlighter-rouge">s[i..j-1]</code>或者<code class="language-plaintext highlighter-rouge">s[i+1..j]</code>变成回文串。怎么做选择呢？谁变成回文串的插入次数少，就选谁呗。</p><p>比如图二的情况，将<code class="language-plaintext highlighter-rouge">s[i+1..j]</code>变成回文串的操作次数更小，因为它本身就是回文串，根本不需要插入；同理，对于图三，将<code class="language-plaintext highlighter-rouge">s[i..j-1]</code>变成回文串的操作次数更小。然而，如果 <code class="language-plaintext highlighter-rouge">s[i+1..j]</code>和<code class="language-plaintext highlighter-rouge">s[i..j-1]</code>都不是回文串，都至少需要插入一个字符才能变成回文，所以选择哪一个都一样。</p><p><strong>步骤二</strong>，根据步骤一的选择，将<code class="language-plaintext highlighter-rouge">s[i..j]</code>变成回文串。</p><p>如果在步骤一中选择把<code class="language-plaintext highlighter-rouge">s[i+1..j]</code>变成回文串，那么在<code class="language-plaintext highlighter-rouge">s[i+1..j]</code>右边插入一个字符<code class="language-plaintext highlighter-rouge">s[i]</code>一定可以将<code class="language-plaintext highlighter-rouge">s[i..j]</code>变成回文；同理，如果在步骤一中选择把<code class="language-plaintext highlighter-rouge">s[i..j-1]</code>变成回文串，在<code class="language-plaintext highlighter-rouge">s[i..j-1]</code>左边插入一个字符<code class="language-plaintext highlighter-rouge">s[j]</code>一定可以将<code class="language-plaintext highlighter-rouge">s[i..j]</code>变成回文。</p><div align="center"><img data-src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205241136018.png" alt="image-20220524113611854" style="zoom:70%;" data-proofer-ignore></div><p><strong>初始化</strong>：当<code class="language-plaintext highlighter-rouge">i == j</code>时<code class="language-plaintext highlighter-rouge">dp[i][j] = 0</code>，因为当<code class="language-plaintext highlighter-rouge">i == j</code>时<code class="language-plaintext highlighter-rouge">s[i..j]</code>就是一个字符，本身就是回文串，所以不需要进行任何插入操作。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">int</span> <span class="nf">minInsertions</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="mf">.</span><span class="nf">size</span><span class="p">();</span>
        <span class="c1">// 定义：对 s[i..j]，最少需要插入 dp[i][j] 次才能变成回文</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&gt;</span> <span class="nf">dp</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
        <span class="c1">// base case：i == j 时 dp[i][j] = 0，单个字符本身就是回文</span>
        <span class="c1">// 从下向上遍历</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 从左向右遍历</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="p">{</span>
                    <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h2 id="01背包问题"><span class="mr-2">01背包问题</span><a href="#01背包问题" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="01背包问题理论"><span class="mr-2">01背包问题理论</span><a href="#01背包问题理论" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>有<code class="language-plaintext highlighter-rouge">n</code>件物品和一个最多能背重量为<code class="language-plaintext highlighter-rouge">w</code> 的背包，第<code class="language-plaintext highlighter-rouge">i</code>件物品的重量是<code class="language-plaintext highlighter-rouge">weight[i]</code>，得到的价值是<code class="language-plaintext highlighter-rouge">value[i] </code>，<strong>每件物品只能用一次</strong>，求解将哪些物品装入背包里物品价值总和最大。</p><p><strong>解法一：二维dp数组01背包</strong></p><p><strong>数组<code class="language-plaintext highlighter-rouge">dp[i][j] </code>表示</strong>从下标为<code class="language-plaintext highlighter-rouge">[0-i]</code>的物品里任意取，放进容量为<code class="language-plaintext highlighter-rouge">j</code>的背包，价值总和最大是多少。</p><p>那么可以有两个方向推出来<code class="language-plaintext highlighter-rouge">dp[i][j]</code>：</p><p><strong>不放物品i</strong>：由<code class="language-plaintext highlighter-rouge">dp[i - 1][j]</code>推出，即背包容量为<code class="language-plaintext highlighter-rouge">j</code>，里面不放物品<code class="language-plaintext highlighter-rouge">i</code>的最大价值，此时<code class="language-plaintext highlighter-rouge">dp[i][j]</code>就是<code class="language-plaintext highlighter-rouge">dp[i - 1][j]</code>。(其实就是当物品<code class="language-plaintext highlighter-rouge">i</code>的重量大于背包<code class="language-plaintext highlighter-rouge">j</code>的重量时，物品<code class="language-plaintext highlighter-rouge">i</code>无法放进背包中，所以被背包内的价值依然和前面相同)。</p><p><strong>放物品i</strong>：由<code class="language-plaintext highlighter-rouge">dp[i - 1][j - weight[i]]</code>推出，<code class="language-plaintext highlighter-rouge">dp[i - 1][j - weight[i]] </code>为背包容量为<code class="language-plaintext highlighter-rouge">j - weight[i]</code>的时候不放物品<code class="language-plaintext highlighter-rouge">i</code>的最大价值，那么<code class="language-plaintext highlighter-rouge">dp[i - 1][j - weight[i]] + value[i] </code>（物品<code class="language-plaintext highlighter-rouge">i</code>的价值），就是背包放物品<code class="language-plaintext highlighter-rouge">i</code>得到的最大价值。</p><p>所以<strong>递归公式</strong>为<code class="language-plaintext highlighter-rouge">dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])</code>。</p><p><strong>初始化</strong>：</p><p>首先从<code class="language-plaintext highlighter-rouge">dp[i][j]</code>的定义出发，如果背包容量<code class="language-plaintext highlighter-rouge">j</code>为0的话，即<code class="language-plaintext highlighter-rouge">dp[i][0]</code>，无论是选取哪些物品，背包价值总和一定为0。</p><p>由状态转移方程 <code class="language-plaintext highlighter-rouge">dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])</code>可以看出<code class="language-plaintext highlighter-rouge">i</code> 是由<code class="language-plaintext highlighter-rouge"> i-1 </code>推导出来，那么<code class="language-plaintext highlighter-rouge">i</code>为0的时候就一定要初始化。<code class="language-plaintext highlighter-rouge">dp[0][j]</code>，即<code class="language-plaintext highlighter-rouge">i</code>为0，存放编号0的物品的时候，各个容量的背包所能存放的最大价值。</p><p>当<code class="language-plaintext highlighter-rouge"> j &lt; weight[0]</code>的时候，<code class="language-plaintext highlighter-rouge">dp[0][j]</code>应该是 0，因为背包容量比编号0的物品重量还小。</p><p>当<code class="language-plaintext highlighter-rouge">j &gt;= weight[0]</code>时，<code class="language-plaintext highlighter-rouge">dp[0][j]</code>应该是<code class="language-plaintext highlighter-rouge">value[0]</code>，因为背包容量放足够放编号0物品。</p><p><code class="language-plaintext highlighter-rouge">dp[0][j] </code>和<code class="language-plaintext highlighter-rouge"> dp[i][0] </code>都已经初始化了，那么其他下标应该初始化多少呢？其实从递归公式可以看出<code class="language-plaintext highlighter-rouge">dp[i][j] </code>是由左上方数值推导出来了，那么其他下标初始为什么数值都可以，因为都会被覆盖。但只不过一开始就统一把<code class="language-plaintext highlighter-rouge">dp</code>数组统一初始为0，更方便一些。</p><p><strong>遍历顺序</strong>：01背包中二维dp数组的两个for遍历的先后循序是可以颠倒的。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="n">int</span> <span class="nf">bagProblem</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span> <span class="n">weight</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span> <span class="n">value</span><span class="p">,</span> <span class="n">int</span> <span class="n">bagweight</span><span class="p">){</span>
	<span class="n">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">weight</span><span class="mf">.</span><span class="nf">size</span><span class="p">();</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&gt;</span> <span class="nf">dp</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">bagweight</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
    <span class="k">for</span><span class="p">(</span><span class="n">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">weight</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">bagweight</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">){</span>
		<span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">for</span><span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 遍历物品</span>
        <span class="k">for</span><span class="p">(</span><span class="n">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">bagweight</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 遍历背包容量</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">weight</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
            <span class="k">else</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="n">weight</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">+</span> <span class="n">value</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="p">}</span>
    <span class="p">}</span>
	<span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">bagweight</span><span class="p">];</span>
<span class="p">}</span>
</pre></table></code></div></div><p>🦄<strong>解法二：一维dp数组（滚动数组）</strong></p><p><strong>数组<code class="language-plaintext highlighter-rouge">dp[j]</code>表示</strong>容量为<code class="language-plaintext highlighter-rouge">j</code>的背包，所背的物品价值可以最大为dp[j]。</p><p><code class="language-plaintext highlighter-rouge">dp[j]</code>可以通过<code class="language-plaintext highlighter-rouge">dp[j - weight[i]]</code>推导出来，<code class="language-plaintext highlighter-rouge">dp[j - weight[i]]</code>表示容量为<code class="language-plaintext highlighter-rouge">j - weight[i]</code>的背包所背的最大价值。</p><p><code class="language-plaintext highlighter-rouge">dp[j - weight[i]] + value[i]</code> 表示 容量为 <code class="language-plaintext highlighter-rouge">j - 物品i重量</code> 的背包 加上 物品<code class="language-plaintext highlighter-rouge">i</code>的价值。（也就是容量为j的背包，放入物品i了之后的价值即<code class="language-plaintext highlighter-rouge">dp[j]</code>）</p><p>此时<code class="language-plaintext highlighter-rouge">dp[j]</code>有两个选择：一个是取自己<code class="language-plaintext highlighter-rouge">dp[j]</code>，相当于二维dp数组中的<code class="language-plaintext highlighter-rouge">dp[i-1][j]</code>，即<strong>不放</strong>物品<code class="language-plaintext highlighter-rouge">i</code>；一个是取<code class="language-plaintext highlighter-rouge">dp[j - weight[i]] + value[i]</code>，即<strong>放</strong>物品<code class="language-plaintext highlighter-rouge">i</code>。取最大的，求最大价值。所以递归公式为<code class="language-plaintext highlighter-rouge">dp[j] = max(dp[j], dp[j - weight[i]] + value[i])</code>。</p><p><strong>初始化</strong>：</p><p><code class="language-plaintext highlighter-rouge">dp[j]</code>表示：容量为<code class="language-plaintext highlighter-rouge">j</code>的背包，所背的物品价值可以最大为<code class="language-plaintext highlighter-rouge">dp[j]</code>，那么<code class="language-plaintext highlighter-rouge">dp[0]</code>就应该是0，因为背包容量为0所背的物品的最大价值就是0。</p><p>那么dp数组除了下标0的位置初始为0，其他下标应该初始化多少呢？</p><p>看一下递归公式：<code class="language-plaintext highlighter-rouge">dp[j] = max(dp[j], dp[j - weight[i]] + value[i])</code>，dp数组在推导的时候一定是取价值最大的数。如果题目给的价值都是正整数，那么非0下标都初始化为0就可以了，这样才能让dp数组在递归公式的过程中取最大的价值，而不是被初始值覆盖。</p><p>那么我假设物品价值都是大于0的，所以dp数组初始化的时候，都初始为0就可以了。</p><p><strong>遍历顺序</strong>：</p><p>遍历背包的顺序要从大到小倒序遍历，<strong>倒序遍历是为了保证物品<code class="language-plaintext highlighter-rouge">i</code>只被放入一次！</strong>但如果一旦正序遍历了，那么物品0就会被重复加入多次！每一个元素一定是不可重复放入，所以从大到小遍历，可以保证每个物品仅被添加一次。从后往前循环，每次取得状态不会和之前取得状态重合，这样每种物品就只取一次了。</p><p><strong>再来看看两个嵌套for循环的顺序，代码中是先遍历物品嵌套遍历背包容量，那可不可以先遍历背包容量嵌套遍历物品呢？</strong></p><p>不可以！因为一维dp的写法，背包容量一定是要倒序遍历，如果遍历背包容量放在上一层，那么每个dp[j]就只会放入一个物品，即背包里只放入了一个物品。<strong>所以一维dp数组的背包在遍历顺序上和二维其实是有很大差异的！</strong></p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="n">int</span> <span class="nf">bagProblem</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span> <span class="n">weight</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span> <span class="n">value</span><span class="p">,</span> <span class="n">int</span> <span class="n">bagweight</span><span class="p">){</span>
	<span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span> <span class="nf">dp</span><span class="p">(</span><span class="n">bagweight</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">for</span><span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">weight</span><span class="mf">.</span><span class="nf">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span> <span class="c1">// 遍历物品</span>
        <span class="k">for</span><span class="p">(</span><span class="n">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">bagweight</span><span class="p">;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">weight</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="n">j</span><span class="o">--</span><span class="p">){</span> <span class="c1">// 遍历背包容量</span>
            <span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="n">weight</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">+</span> <span class="n">value</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="p">}</span>
    <span class="p">}</span>
	<span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="n">bagweight</span><span class="p">];</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="416-分割等和子集"><span class="mr-2">416. 分割等和子集</span><a href="#416-分割等和子集" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>给你一个 <strong>只包含正整数</strong> 的 <strong>非空</strong> 数组 <code class="language-plaintext highlighter-rouge">nums</code> 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">nums</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="n">输出</span><span class="err">：</span><span class="kc">true</span>
<span class="n">解释</span><span class="err">：</span><span class="n">数组可以分割成</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span> <span class="n">和</span> <span class="p">[</span><span class="mi">11</span><span class="p">]</span> <span class="err">。</span>
</pre></table></code></div></div><p>找到集合里能够出现 <code class="language-plaintext highlighter-rouge">sum / 2</code> 的子集总和，就可以分割成两个相同元素和子集了。</p><p><strong>注意：一个商品如果可以重复多次放入是完全背包，而只能放入一次是01背包。</strong>本题中我们要使用01背包，因为每个元素只能用一次。</p><p>只有确定了如下四点，才能把01背包问题套到本题上来：</p><ul><li>背包的容量为 sum / 2<li>背包要放入的商品（集合里的元素）重量为元素的数值，价值也为元素的数值<li><strong>背包如果正好装满</strong>，说明找到了总和为 sum / 2 的子集。<li>背包中每一个元素是不可重复放入。</ul><p>以上分析完，我们就可以套用01背包，来解决这个问题了。</p><p>01背包中，dp[j] 表示容量为<code class="language-plaintext highlighter-rouge">j</code>的背包，所背的物品价值可以最大为<code class="language-plaintext highlighter-rouge">dp[j]</code>。套到本题，<strong>数组<code class="language-plaintext highlighter-rouge">dp[j]</code>表示</strong>背包总容量是<code class="language-plaintext highlighter-rouge">j</code>，最大可以凑成<code class="language-plaintext highlighter-rouge">j</code>的子集总和为<code class="language-plaintext highlighter-rouge">dp[j]</code>。</p><p>01背包的递推公式为<code class="language-plaintext highlighter-rouge">dp[j] = max(dp[j], dp[j - weight[i]] + value[i])</code>，本题相当于背包里放入数值，那么物品i的重量是nums[i]，其价值也是nums[i]，所以<strong>递推公式</strong>为<code class="language-plaintext highlighter-rouge">dp[j] = max(dp[j], dp[j - nums[i]] + nums[i])</code>。</p><p><strong>初始化</strong>：从dp[j]的定义来看，首先dp[0]一定是0。只包含正整数的非空数组，所以非0下标的元素初始化为0就可以了。<code class="language-plaintext highlighter-rouge">dp[i]</code>中的<code class="language-plaintext highlighter-rouge">i</code>表示背包内总和，题目中说：每个数组中的元素不会超过 100，数组的大小不会超过 200，所以总和不会大于20000，背包最大只需要其中一半，所以10001大小就可以了。</p><p><strong>遍历顺序</strong>：如果使用一维dp数组，物品遍历的for循环放在外层，遍历背包的for循环放在内层，且内层for循环倒序遍历！</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">bool</span> <span class="nf">canPartition</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span> <span class="nf">dp</span><span class="p">(</span><span class="mi">10001</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">num</span> <span class="o">:</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">num</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// 和为奇数时，不可能划分成两个和相等的集合</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">sum</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
        <span class="n">int</span> <span class="n">target</span> <span class="o">=</span> <span class="n">sum</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
        <span class="c1">// 开始 01背包</span>
        <span class="k">for</span><span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="mf">.</span><span class="nf">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">//遍历物品</span>
            <span class="k">for</span><span class="p">(</span><span class="n">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">target</span><span class="p">;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="n">j</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span> <span class="c1">//遍历背包容量</span>
                <span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="c1">// 集合中的元素正好可以凑成总和target</span>
        <span class="k">return</span> <span class="n">d</span><span class="p">[</span><span class="n">target</span><span class="p">]</span> <span class="o">==</span> <span class="n">target</span> <span class="o">?</span> <span class="kc">true</span> <span class="o">:</span> <span class="kc">false</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h3 id="1049-最后一块石头的重量-ii"><span class="mr-2">1049. 最后一块石头的重量 II</span><a href="#1049-最后一块石头的重量-ii" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>有一堆石头，用整数数组 <code class="language-plaintext highlighter-rouge">stones</code> 表示。其中 <code class="language-plaintext highlighter-rouge">stones[i]</code> 表示第 <code class="language-plaintext highlighter-rouge">i</code> 块石头的重量。每一回合，从中选出<strong>任意两块石头</strong>，然后将它们一起粉碎。假设石头的重量分别为 <code class="language-plaintext highlighter-rouge">x</code> 和 <code class="language-plaintext highlighter-rouge">y</code>，且 <code class="language-plaintext highlighter-rouge">x &lt;= y</code>。那么粉碎的可能结果如下：</p><ul><li>如果 <code class="language-plaintext highlighter-rouge">x == y</code>，那么两块石头都会被完全粉碎；<li>如果 <code class="language-plaintext highlighter-rouge">x != y</code>，那么重量为 <code class="language-plaintext highlighter-rouge">x</code> 的石头将会完全粉碎，而重量为 <code class="language-plaintext highlighter-rouge">y</code> 的石头新重量为 <code class="language-plaintext highlighter-rouge">y-x</code>。</ul><p>最后，<strong>最多只会剩下一块</strong> 石头。返回此石头 <strong>最小的可能重量</strong> 。如果没有石头剩下，就返回 <code class="language-plaintext highlighter-rouge">0</code>。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">stones</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">1</span>
<span class="n">解释</span><span class="err">：</span>
<span class="n">组合</span> <span class="mi">2</span> <span class="n">和</span> <span class="mi">4</span><span class="err">，</span><span class="n">得到</span> <span class="mi">2</span><span class="err">，</span><span class="n">所以数组转化为</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="err">，</span>
<span class="n">组合</span> <span class="mi">7</span> <span class="n">和</span> <span class="mi">8</span><span class="err">，</span><span class="n">得到</span> <span class="mi">1</span><span class="err">，</span><span class="n">所以数组转化为</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="err">，</span>
<span class="n">组合</span> <span class="mi">2</span> <span class="n">和</span> <span class="mi">1</span><span class="err">，</span><span class="n">得到</span> <span class="mi">1</span><span class="err">，</span><span class="n">所以数组转化为</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="err">，</span>
<span class="n">组合</span> <span class="mi">1</span> <span class="n">和</span> <span class="mi">1</span><span class="err">，</span><span class="n">得到</span> <span class="mi">0</span><span class="err">，</span><span class="n">所以数组转化为</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="err">，</span><span class="n">这就是最优值</span><span class="err">。</span>
</pre></table></code></div></div><p>本题其实就是<strong>尽量让石头分成重量相同的两堆</strong>，相撞之后剩下的石头最小，<strong>这样就化解成01背包问题了</strong>，和416. 分割等和子集非常像。本题物品的重量为<code class="language-plaintext highlighter-rouge">stones[i]</code> ，物品的价值也为<code class="language-plaintext highlighter-rouge">stones[i]</code> ，对应着01背包里的物品重量<code class="language-plaintext highlighter-rouge">weight[i] </code>和 物品价值<code class="language-plaintext highlighter-rouge">value[i]</code>。</p><p><strong>数组<code class="language-plaintext highlighter-rouge">dp[j]</code>表示容量为<code class="language-plaintext highlighter-rouge">j</code>的背包，最多可以背<code class="language-plaintext highlighter-rouge">dp[j]</code>这么重的石头</strong>。</p><p>01背包的递推公式为<code class="language-plaintext highlighter-rouge">dp[j] = max(dp[j], dp[j - weight[i]] + value[i])</code>，本题则是<code class="language-plaintext highlighter-rouge">dp[j] = max(dp[j], dp[j - stones[i]] + stones[i])</code>。</p><p><strong>初始化</strong>：既然 dp[j]中的j表示容量，那么最大容量（重量）是多少呢，就是所有石头的重量和。</p><p>因为提示中给出1 &lt;= stones.length &lt;= 30，1 &lt;= stones[i] &lt;= 1000，所以最大重量就是30 * 1000 。而我们要求的target其实只是最大重量的一半，所以dp数组开到15000大小就可以了。</p><p>接下来就是如何初始化dp[j]，因为重量都不会是负数，所以<code class="language-plaintext highlighter-rouge">dp[j]</code>都初始化为0就可以了，这样在递归公式中<code class="language-plaintext highlighter-rouge">dp[j]</code>才不会被初始值所覆盖。</p><p><strong>遍历顺序</strong>：如果使用一维dp数组，物品遍历的for循环放在外层，遍历背包的for循环放在内层，且内层for循环倒序遍历！</p><p>最后<code class="language-plaintext highlighter-rouge">dp[target]</code>就是容量为<code class="language-plaintext highlighter-rouge">target</code>的背包所能背的最大重量。那么分成两堆石头，一堆石头的总重量是<code class="language-plaintext highlighter-rouge">dp[target]</code>，另一堆就是<code class="language-plaintext highlighter-rouge">sum - dp[target]</code>。在计算<code class="language-plaintext highlighter-rouge">target</code>的时候，<code class="language-plaintext highlighter-rouge">target = sum / 2 </code>因为是向下取整，所以<code class="language-plaintext highlighter-rouge">sum - dp[target] </code>一定是大于等于<code class="language-plaintext highlighter-rouge">dp[target]</code>的。所以相撞之后剩下的最小石头重量就是 <code class="language-plaintext highlighter-rouge">(sum - dp[target]) - dp[target]</code>。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">int</span> <span class="nf">lastStoneWeightII</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&amp;</span> <span class="n">stones</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span> <span class="nf">dp</span><span class="p">(</span><span class="mi">15001</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">stone</span> <span class="o">:</span> <span class="n">stones</span><span class="p">)</span> <span class="n">sum</span> <span class="o">+=</span> <span class="n">stone</span><span class="p">;</span>
        <span class="n">int</span> <span class="n">target</span> <span class="o">=</span> <span class="n">sum</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">stones</span><span class="mf">.</span><span class="nf">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 遍历物品</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">target</span><span class="p">;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">stones</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="n">j</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 遍历背包</span>
                <span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="n">stones</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">+</span> <span class="n">stones</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">sum</span> <span class="o">-</span> <span class="n">dp</span><span class="p">[</span><span class="n">target</span><span class="p">]</span> <span class="o">-</span> <span class="n">dp</span><span class="p">[</span><span class="n">target</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h3 id="494-目标和"><span class="mr-2">494. 目标和</span><a href="#494-目标和" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>给你一个整数数组 <code class="language-plaintext highlighter-rouge">nums</code> 和一个整数 <code class="language-plaintext highlighter-rouge">target</code> 。向数组中的每个整数前添加 <code class="language-plaintext highlighter-rouge">'+'</code> 或 <code class="language-plaintext highlighter-rouge">'-'</code> ，然后串联起所有整数，可以构造一个 <strong>表达式</strong>。</p><p>例如，nums = [2, 1] ，可以在 2 之前添加 ‘+’ ，在 1 之前添加 ‘-‘ ，然后串联起来得到表达式 “+2-1” 。返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">nums</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">target</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">5</span>
<span class="n">解释</span><span class="err">：</span><span class="n">一共有</span> <span class="mi">5</span> <span class="n">种方法让最终目标和为</span> <span class="mi">3</span> <span class="err">。</span>
<span class="o">-</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">=</span> <span class="mi">3</span>
<span class="o">+</span><span class="mi">1</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">=</span> <span class="mi">3</span>
<span class="o">+</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">=</span> <span class="mi">3</span>
<span class="o">+</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">=</span> <span class="mi">3</span>
<span class="o">+</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">=</span> <span class="mi">3</span>
</pre></table></code></div></div><p>如何转化为01背包问题呢？假设加法的总和为x，那么减法对应的总和就是sum - x。所以我们要求的是 x - (sum - x) = target，x = (target + sum) / 2，<strong>此时问题就转化为装满容量为x背包，有几种方法</strong>。</p><p><strong>数组<code class="language-plaintext highlighter-rouge">dp[j] </code>表示</strong>填满<code class="language-plaintext highlighter-rouge">j</code>（包括j）这么大容积的包，有<code class="language-plaintext highlighter-rouge">dp[j]</code>种方法。</p><p>不考虑<code class="language-plaintext highlighter-rouge">nums[i]</code>的情况下，填满容量为<code class="language-plaintext highlighter-rouge">j - nums[i]</code>的背包，有<code class="language-plaintext highlighter-rouge">dp[j - nums[i]]</code>种方法。那么得到<code class="language-plaintext highlighter-rouge">nums[i]</code>的话，凑成<code class="language-plaintext highlighter-rouge">dp[j]</code>就有<code class="language-plaintext highlighter-rouge">dp[j - nums[i]]</code> 种方法，所以<strong>递推公式为</strong><code class="language-plaintext highlighter-rouge">dp[j] += dp[j - nums[i]]</code>。</p><p><strong>初始化</strong>：</p><p>dp[0] = 1，装满容量为0的背包，有1种方法，就是装0件物品。</p><p>dp[j]其他下标对应的数值应该初始化为0，从递归公式也可以看出，dp[j]要保证是0的初始值，才能正确的由dp[j - nums[i]]推导出来。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">int</span> <span class="nf">findTargetSumWays</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="n">int</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="n">int</span> <span class="n">num</span> <span class="o">:</span> <span class="n">nums</span><span class="p">)</span> <span class="n">sum</span> <span class="o">+=</span> <span class="n">num</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">target</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">sum</span> <span class="o">||</span> <span class="p">(</span><span class="n">target</span> <span class="o">+</span> <span class="n">sum</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">){</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">int</span> <span class="n">bag</span> <span class="o">=</span> <span class="p">(</span><span class="n">sum</span> <span class="o">+</span> <span class="n">target</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span> <span class="nf">d</span><span class="p">(</span><span class="n">bag</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="mf">.</span><span class="nf">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span> <span class="c1">// 物品</span>
            <span class="k">for</span><span class="p">(</span><span class="n">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">bag</span><span class="p">;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="n">j</span><span class="o">--</span><span class="p">){</span> <span class="c1">// 背包</span>
                <span class="n">d</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">d</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]];</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">d</span><span class="p">[</span><span class="n">bag</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h3 id="474一和零"><span class="mr-2">474.一和零</span><a href="#474一和零" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>给你一个二进制字符串数组 <code class="language-plaintext highlighter-rouge">strs</code> 和两个整数 <code class="language-plaintext highlighter-rouge">m</code> 和 <code class="language-plaintext highlighter-rouge">n</code> 。请你找出并返回 <code class="language-plaintext highlighter-rouge">strs</code> 的最大子集的长度，该子集中 <strong>最多</strong> 有 <code class="language-plaintext highlighter-rouge">m</code> 个 <code class="language-plaintext highlighter-rouge">0</code> 和 <code class="language-plaintext highlighter-rouge">n</code> 个 <code class="language-plaintext highlighter-rouge">1</code> 。如果 <code class="language-plaintext highlighter-rouge">x</code> 的所有元素也是 <code class="language-plaintext highlighter-rouge">y</code> 的元素，集合 <code class="language-plaintext highlighter-rouge">x</code> 是集合 <code class="language-plaintext highlighter-rouge">y</code> 的 <strong>子集</strong>。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">strs</span> <span class="o">=</span> <span class="p">[</span><span class="s2">"10"</span><span class="p">,</span> <span class="s2">"0001"</span><span class="p">,</span> <span class="s2">"111001"</span><span class="p">,</span> <span class="s2">"1"</span><span class="p">,</span> <span class="s2">"0"</span><span class="p">],</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">4</span>
<span class="n">解释</span><span class="err">：</span><span class="n">最多有</span> <span class="mi">5</span> <span class="n">个</span> <span class="mi">0</span> <span class="n">和</span> <span class="mi">3</span> <span class="n">个</span> <span class="mi">1</span> <span class="n">的最大子集是</span> <span class="p">{</span><span class="s2">"10"</span><span class="p">,</span><span class="s2">"0001"</span><span class="p">,</span><span class="s2">"1"</span><span class="p">,</span><span class="s2">"0"</span><span class="p">}</span> <span class="err">，</span><span class="n">因此答案是</span> <span class="mi">4</span> <span class="err">。</span>
<span class="n">其他满足题意但较小的子集包括</span> <span class="p">{</span><span class="s2">"0001"</span><span class="p">,</span><span class="s2">"1"</span><span class="p">}</span> <span class="n">和</span> <span class="p">{</span><span class="s2">"10"</span><span class="p">,</span><span class="s2">"1"</span><span class="p">,</span><span class="s2">"0"</span><span class="p">}</span> <span class="err">。</span><span class="p">{</span><span class="s2">"111001"</span><span class="p">}</span> <span class="n">不满足题意</span><span class="err">，</span><span class="n">因为它含</span> <span class="mi">4</span> <span class="n">个</span> <span class="mi">1</span> <span class="err">，</span><span class="n">大于</span> <span class="n">n</span> <span class="n">的值</span> <span class="mi">3</span> <span class="err">。</span>
</pre></table></code></div></div><p>本题是01背包问题，不过这个背包有两个维度，一个是m 一个是n，而不同长度的字符串就是不同大小的待装物品。</p><p><strong>数组<code class="language-plaintext highlighter-rouge">dp[i][j]</code>代表</strong>最多有<code class="language-plaintext highlighter-rouge">i</code>个<code class="language-plaintext highlighter-rouge">0</code>和<code class="language-plaintext highlighter-rouge">j</code>个<code class="language-plaintext highlighter-rouge">1</code>的<code class="language-plaintext highlighter-rouge">strs</code>的最大子集的大小为<code class="language-plaintext highlighter-rouge">dp[i][j]</code>。</p><p><code class="language-plaintext highlighter-rouge">dp[i][j] </code>可以由前一个<code class="language-plaintext highlighter-rouge">strs</code>里的字符串推导出来，strs里的字符串有<code class="language-plaintext highlighter-rouge">zeroNum</code>个0，<code class="language-plaintext highlighter-rouge">oneNum</code>个1。<code class="language-plaintext highlighter-rouge">dp[i][j] </code>就是 <code class="language-plaintext highlighter-rouge">dp[i - zeroNum][j - oneNum] + 1</code>。然后我们在遍历的过程中，取<code class="language-plaintext highlighter-rouge">dp[i][j]</code>的最大值，所以递推公式为<code class="language-plaintext highlighter-rouge">dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1)</code>。</p><p>此时大家可以回想一下01背包的递推公式：<code class="language-plaintext highlighter-rouge">dp[j] = max(dp[j], dp[j - weight[i]] + value[i])</code>。对比一下就会发现，字符串的<code class="language-plaintext highlighter-rouge">zeroNum</code>和<code class="language-plaintext highlighter-rouge">oneNum</code>相当于物品的重量（weight[i]），字符串本身的个数相当于物品的价值（value[i]）。<strong>这就是一个典型的01背包！</strong> 只不过物品的重量有了两个维度而已。</p><p><strong>初始化</strong>：01背包的dp数组初始化为0就可以。因为物品价值不会是负数，初始为0，保证递推的时候<code class="language-plaintext highlighter-rouge">dp[i][j]</code>不会被初始值覆盖。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">int</span> <span class="nf">findMaxForm</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">strs</span><span class="p">,</span> <span class="n">int</span> <span class="n">m</span><span class="p">,</span> <span class="n">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&gt;</span> <span class="nf">dp</span><span class="p">(</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">string</span> <span class="n">str</span> <span class="o">:</span> <span class="n">strs</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 遍历物品</span>
            <span class="n">int</span> <span class="n">oneNum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">zeroNum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">str</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="s1">'0'</span><span class="p">)</span> <span class="n">zeroNum</span><span class="o">++</span><span class="p">;</span>
                <span class="k">else</span> <span class="n">oneNum</span><span class="o">++</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">zeroNum</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 遍历背包容量</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">oneNum</span><span class="p">;</span> <span class="n">j</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">zeroNum</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="n">oneNum</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">n</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h2 id="完全背包问题"><span class="mr-2">完全背包问题</span><a href="#完全背包问题" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>有N件物品和一个最多能背重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。<strong>每件物品都有无限个（也就是可以放入背包多次）</strong>，求解将哪些物品装入背包里物品价值总和最大。</p><p><strong>完全背包和01背包问题唯一不同的地方就是，每种物品有无限件</strong>。</p><p><strong>在完全背包中，对于一维dp数组来说，其实两个for循环嵌套顺序是可以颠倒的！</strong>因为<code class="language-plaintext highlighter-rouge">dp[j] </code>是根据下标<code class="language-plaintext highlighter-rouge">j</code>之前所对应的<code class="language-plaintext highlighter-rouge">dp[j]</code>计算出来的，只要保证下标<code class="language-plaintext highlighter-rouge">j</code>之前的<code class="language-plaintext highlighter-rouge">dp[j]</code>都是经过计算的就可以了。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="n">int</span> <span class="nf">bagProblem</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span> <span class="n">weight</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span> <span class="n">value</span><span class="p">,</span> <span class="n">int</span> <span class="n">bagweight</span><span class="p">){</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span> <span class="nf">dp</span><span class="p">(</span><span class="n">bagweight</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">weight</span><span class="mf">.</span><span class="nf">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 遍历物品</span>
        <span class="k">for</span><span class="p">(</span><span class="n">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">weight</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">bagweight</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 遍历背包容量</span>
			<span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="n">weight</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">+</span> <span class="n">value</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="p">}</span>
    <span class="p">}</span>
	<span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="n">bagweight</span><span class="p">];</span>
<span class="p">}</span>
</pre></table></code></div></div><p><strong>遍历顺序</strong>：</p><p>若外层for循环遍历物品（钱币），内层for遍历背包（金钱总额）的情况。</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">coins</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 遍历物品</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">coins</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">amount</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 遍历背包容量</span>
        <span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dp</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="n">coins</span><span class="p">[</span><span class="n">i</span><span class="p">]];</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>假设：coins[0] = 1，coins[1] = 5。</p><p>那么就是先把1加入计算，然后再把5加入计算，得到的方法数量只有{1, 5}这种情况。而不会出现{5, 1}的情况。<strong>所以这种遍历顺序中dp[j]里计算的是组合数！</strong></p><p>如果把两个for交换顺序：</p><div class="language-text highlighter-rouge"><div class="code-header"> <span data-label-text="Text"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>for (int j = 0; j &lt;= amount; j++) { // 遍历背包容量
    for (int i = 0; i &lt; coins.size(); i++) { // 遍历物品
        if (j - coins[i] &gt;= 0) dp[j] += dp[j - coins[i]];
    }
}
</pre></table></code></div></div><p>背包容量的每一个值，都是经过 1 和 5 的计算，包含了{1, 5} 和 {5, 1}两种情况。<strong>此时dp[j]里算出来的就是排列数！</strong></p><p><strong>总结</strong>：如果求<strong>组合数</strong>就是外层for循环遍历物品，内层for遍历背包，如果求<strong>排列数</strong>就是外层for遍历背包，内层for循环遍历物品。</p><h3 id="518-零钱兑换-ii"><span class="mr-2">518. 零钱兑换 II</span><a href="#518-零钱兑换-ii" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>给你一个整数数组 <code class="language-plaintext highlighter-rouge">coins </code>表示不同面额的硬币，另给一个整数 <code class="language-plaintext highlighter-rouge">amount </code>表示总金额。请你计算并返回可以凑成总金额的硬币<strong>组合数</strong>。如果任何硬币组合都无法凑出总金额，返回 0 。<strong>假设每一种面额的硬币有无限个</strong>。 题目数据保证结果符合 32 位带符号整数。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">amount</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">coins</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">4</span>
<span class="n">解释</span><span class="err">：</span><span class="n">有四种方式可以凑成总金额</span><span class="err">：</span>
<span class="mi">5</span><span class="o">=</span><span class="mi">5</span>
<span class="mi">5</span><span class="o">=</span><span class="mi">2</span><span class="o">+</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span>
<span class="mi">5</span><span class="o">=</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span>
<span class="mi">5</span><span class="o">=</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span>
</pre></table></code></div></div><p>这是一道典型的背包问题，一看到钱币数量不限，就知道这是一个<strong>完全背包</strong>。</p><p><strong>数组<code class="language-plaintext highlighter-rouge">dp[j]</code>表示</strong>凑成总金额<code class="language-plaintext highlighter-rouge">j</code>的货币组合数为<code class="language-plaintext highlighter-rouge">dp[j]</code>。</p><p><code class="language-plaintext highlighter-rouge">dp[j]</code>（考虑coins[i]的组合总和） 就是所有的<code class="language-plaintext highlighter-rouge">dp[j - coins[i]]</code>（不考虑coins[i]）相加，所以递推公式为<code class="language-plaintext highlighter-rouge">dp[j] += dp[j - coins[i]]</code>。</p><p><strong>初始化</strong>：首先dp[0]一定要为1，<code class="language-plaintext highlighter-rouge">dp[0] = 1</code>是 递归公式的基础。从<code class="language-plaintext highlighter-rouge">dp[i]</code>的含义上来讲就是，凑成总金额0的货币组合数为1。下标非0的dp[j]初始化为0，这样累计加<code class="language-plaintext highlighter-rouge">dp[j - coins[i]]</code>的时候才不会影响真正的dp[j]。</p><p>纯完全背包求得是能否凑成总和，和凑成总和的元素有没有顺序没关系，即有顺序也行，没有顺序也行！而本题要求凑成总和的<strong>组合数</strong>，<strong>元素之间要求没有顺序</strong>。</p><p>纯完全背包是能凑成总和就行，不用管怎么凑的。而本题是求凑出来的方案个数，且每个方案个数是组合数。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">int</span> <span class="nf">change</span><span class="p">(</span><span class="n">int</span> <span class="n">amount</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&amp;</span> <span class="n">coins</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span> <span class="nf">dp</span><span class="p">(</span><span class="n">amount</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">coins</span><span class="mf">.</span><span class="nf">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 遍历物品</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">coins</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">amount</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 遍历背包</span>
                <span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dp</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="n">coins</span><span class="p">[</span><span class="n">i</span><span class="p">]];</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="n">amount</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h3 id="377-组合总和-ⅳ"><span class="mr-2">377. 组合总和 Ⅳ</span><a href="#377-组合总和-ⅳ" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>给你一个由 <strong>不同</strong> 整数组成的数组 <code class="language-plaintext highlighter-rouge">nums</code> ，和一个目标整数 <code class="language-plaintext highlighter-rouge">target</code> 。请你从 <code class="language-plaintext highlighter-rouge">nums</code> 中找出并返回总和为 <code class="language-plaintext highlighter-rouge">target</code> 的元素组合的个数。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">nums</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="n">target</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">7</span>
<span class="n">解释</span><span class="err">：</span>
<span class="n">所有可能的组合为</span><span class="err">：</span>
<span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">请注意</span><span class="err">，</span><span class="n">顺序不同的序列被视作不同的组合</span><span class="err">。</span>
</pre></table></code></div></div><p>本题题目描述说是求组合，但又说是可以元素相同顺序不同的组合算两个组合，<strong>其实就是求排列！</strong></p><p><strong>数组<code class="language-plaintext highlighter-rouge">dp[i]</code>表示</strong>凑成目标正整数为<code class="language-plaintext highlighter-rouge">i</code>的排列个数为<code class="language-plaintext highlighter-rouge">dp[i]</code>。</p><p>dp[i]（考虑nums[j]）可以由 dp[i - nums[j]]（不考虑nums[j]） 推导出来，因为只要得到nums[j]，排列个数dp[i - nums[j]]，就是dp[i]的一部分，<strong>递推公式</strong>是<code class="language-plaintext highlighter-rouge">dp[i] += dp[i - nums[j]]</code>。</p><p><strong>初始化</strong>：</p><p>因为递推公式dp[i] += dp[i - nums[j]]的缘故，dp[0]要初始化为1，这样递归其他dp[i]的时候才会有数值基础。</p><p>至于dp[0] = 1 有没有意义呢？其实没有意义，所以我也不去强行解释它的意义了，因为题目中也说了：给定目标值是正整数！ 所以dp[0] = 1是没有意义的，仅仅是为了推导递推公式。</p><p>至于非0下标的dp[i]应该初始为多少呢？初始化为0，这样才不会影响dp[i]累加所有的dp[i - nums[j]]。</p><p><strong>遍历顺序</strong>：</p><p>本题为<strong>排列</strong>问题，所以遍历顺序最终遍历顺序：<strong>target（背包）放在外循环，将nums（物品）放在内循环，内循环从前到后遍历</strong>。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre> <span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
     <span class="n">int</span> <span class="nf">combinationSum4</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="n">int</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
         <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span> <span class="nf">dp</span><span class="p">(</span><span class="n">target</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
         <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
         <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">target</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 遍历背包</span>
             <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="mf">.</span><span class="nf">size</span><span class="p">();</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 遍历物品</span>
                 <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="no">INT_MAX</span> <span class="o">-</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]])</span> <span class="p">{</span>
                     <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]];</span>
                 <span class="p">}</span>
             <span class="p">}</span>
         <span class="p">}</span>
         <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="n">target</span><span class="p">];</span>
     <span class="p">}</span>
 <span class="p">};</span>
</pre></table></code></div></div><p>C++测试用例有两个数相加超过int的数据，所以需要在if里加上dp[i] &lt; INT_MAX - dp[i - num]。</p><h3 id="70-爬楼梯-1"><span class="mr-2">70. 爬楼梯</span><a href="#70-爬楼梯-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>假设你正在爬楼梯，需要 <code class="language-plaintext highlighter-rouge">n</code> 阶你才能到达楼顶。每次你可以爬 <code class="language-plaintext highlighter-rouge">1</code> 或 <code class="language-plaintext highlighter-rouge">2</code> 个台阶，你有多少种不同的方法可以爬到楼顶呢？</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">n</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">3</span>
<span class="n">解释</span><span class="err">：</span><span class="n">有三种方法可以爬到楼顶</span><span class="err">。</span>
<span class="mf">1.</span> <span class="mi">1</span> <span class="n">阶</span> <span class="o">+</span> <span class="mi">1</span> <span class="n">阶</span> <span class="o">+</span> <span class="mi">1</span> <span class="n">阶</span>
<span class="mf">2.</span> <span class="mi">1</span> <span class="n">阶</span> <span class="o">+</span> <span class="mi">2</span> <span class="n">阶</span>
<span class="mf">3.</span> <span class="mi">2</span> <span class="n">阶</span> <span class="o">+</span> <span class="mi">1</span> <span class="n">阶</span>
</pre></table></code></div></div><p>进阶版：一步一个台阶，两个台阶，三个台阶，…….，直到 m个台阶，问有多少种不同的方法可以爬到楼顶呢？每一阶可以重复使用，例如跳了1阶，还可以继续跳1阶，<strong>排列问题</strong>。这是一个<strong>完全背包问题</strong>，和377. 组合总和 Ⅳ基本一样。1阶，2阶，…. m阶就是物品，楼顶就是背包。</p><p><strong>数组<code class="language-plaintext highlighter-rouge">dp[i]</code>表示</strong>爬到有<code class="language-plaintext highlighter-rouge">i</code>个台阶的楼顶，有<code class="language-plaintext highlighter-rouge">dp[i]</code>种方法。<strong>递推公式</strong>为<code class="language-plaintext highlighter-rouge">dp[i] += dp[i - j]</code>。</p><p><strong>初始化</strong>：</p><p>既然递归公式是 dp[i] += dp[i - j]，那么dp[0] 一定为1，dp[0]是递归中一切数值的基础所在，如果dp[0]是0的话，其他数值都是0了。下标非0的dp[i]初始化为0，因为dp[i]是靠dp[i-j]累计上来的，dp[i]本身为0这样才不会影响结果。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">int</span> <span class="nf">climbStairs</span><span class="p">(</span><span class="n">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span> <span class="nf">dp</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 遍历背包</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 遍历物品</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">j</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><p>原题答案：</p><p>dp[i]： 爬到第i层楼梯，有dp[i]种方法。</p><p>首先是dp[i - 1]，上i-1层楼梯，有dp[i - 1]种方法，那么再一步跳一个台阶不就是dp[i]了么。还有就是dp[i - 2]，上i-2层楼梯，有dp[i - 2]种方法，那么再一步跳两个台阶不就是dp[i]了么。</p><p>那么dp[i]就是 dp[i - 1]与dp[i - 2]之和，所以dp[i] = dp[i - 1] + dp[i - 2] 。</p><p>初始化dp[1] = 1，dp[2] = 2，然后从i = 3开始递推。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">int</span> <span class="nf">climbStairs</span><span class="p">(</span><span class="n">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="n">n</span><span class="p">;</span> <span class="c1">// 因为下面直接对dp[2]操作了，防止空指针</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span> <span class="nf">dp</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">dp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">dp</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 注意i是从3开始的</span>
            <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><p>优化：</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">int</span> <span class="nf">climbStairs</span><span class="p">(</span><span class="n">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="n">n</span><span class="p">;</span>
        <span class="n">int</span> <span class="n">dp</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
        <span class="n">dp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">dp</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">dp</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
            <span class="n">dp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
            <span class="n">dp</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">sum</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h3 id="322零钱兑换"><span class="mr-2">322.零钱兑换</span><a href="#322零钱兑换" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>给你一个整数数组 <code class="language-plaintext highlighter-rouge">coins</code> ，表示不同面额的硬币；以及一个整数 <code class="language-plaintext highlighter-rouge">amount</code> ，表示总金额。计算并返回可以凑成总金额所需的 <strong>最少的硬币个数</strong> 。如果没有任何一种硬币组合能组成总金额，返回 <code class="language-plaintext highlighter-rouge">-1</code> 。你可以认为每种硬币的数量是<strong>无限</strong>的。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">coins</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="n">amount</span> <span class="o">=</span> <span class="mi">11</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">3</span> 
<span class="n">解释</span><span class="err">：</span><span class="mi">11</span> <span class="o">=</span> <span class="mi">5</span> <span class="o">+</span> <span class="mi">5</span> <span class="o">+</span> <span class="mi">1</span>
<span class="n">输入</span><span class="err">：</span><span class="n">coins</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">amount</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">输出</span><span class="err">：</span><span class="o">-</span><span class="mi">1</span>
</pre></table></code></div></div><p>题目中说每种硬币的数量是无限的，可以看出是典型的<strong>完全背包</strong>问题。</p><p><strong>数组<code class="language-plaintext highlighter-rouge">dp</code> 表示</strong>当目标金额为 <code class="language-plaintext highlighter-rouge">i</code> 时，至少需要 <code class="language-plaintext highlighter-rouge">dp[i]</code> 枚硬币凑出。</p><p>得到dp[j]（考虑coins[i]），只有一个来源，dp[j - coins[i]]（没有考虑coins[i]）。凑足总额为j - coins[i]的最少个数为dp[j - coins[i]]，那么只需要加上一个钱币coins[i]，即dp[j - coins[i]] + 1就是dp[j]（考虑coins[i]）。所以dp[j] 要取所有 dp[j - coins[i]] + 1 中最小的，递推公式为<code class="language-plaintext highlighter-rouge">dp[j] = min(dp[j - coins[i]] + 1, dp[j])</code>。</p><p><strong>初始化</strong>：</p><p>首先凑足总金额为0所需钱币的个数一定是0，那么dp[0] = 0;</p><p>其他下标对应的数值呢？考虑到递推公式的特性，dp[j]必须初始化为一个最大的数，否则就会在min(dp[j - coins[i]] + 1, dp[j])比较的过程中被初始值覆盖，所以下标非0的元素都是应该是最大值。</p><p><strong>遍历顺序</strong>：</p><p>本题求钱币最小个数，<strong>那么钱币有顺序和没有顺序都可以，都不影响钱币的最小个数</strong>。所以本题并不强调集合是组合还是排列。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">int</span> <span class="nf">coinChange</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&amp;</span> <span class="n">coins</span><span class="p">,</span> <span class="n">int</span> <span class="n">amount</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span> <span class="nf">dp</span><span class="p">(</span><span class="n">amount</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="no">INT_MAX</span><span class="p">);</span>
        <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">coins</span><span class="mf">.</span><span class="nf">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 遍历物品</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">coins</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">amount</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 遍历背包</span>
                <span class="c1">// 如果dp[j - coins[i]]是初始值则跳过</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="n">coins</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">==</span> <span class="no">INT_MAX</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
                <span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="n">coins</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="n">amount</span><span class="p">]</span> <span class="o">==</span> <span class="no">INT_MAX</span> <span class="o">?</span> <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="n">dp</span><span class="p">[</span><span class="n">amount</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><p>另一个遍历顺序的版本：</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">int</span> <span class="nf">coinChange</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&amp;</span> <span class="n">coins</span><span class="p">,</span> <span class="n">int</span> <span class="n">amount</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span> <span class="nf">dp</span><span class="p">(</span><span class="n">amount</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="no">INT_MAX</span><span class="p">);</span>
        <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">amount</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 遍历背包</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">coins</span><span class="mf">.</span><span class="nf">size</span><span class="p">();</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 遍历物品</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">coins</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">coins</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">!=</span> <span class="no">INT_MAX</span> <span class="p">)</span> <span class="p">{</span>
                    <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">coins</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="n">amount</span><span class="p">]</span> <span class="o">==</span> <span class="no">INT_MAX</span> <span class="o">?</span> <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="n">dp</span><span class="p">[</span><span class="n">amount</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">};</span>

</pre></table></code></div></div><h3 id="279完全平方数"><span class="mr-2">279.完全平方数</span><a href="#279完全平方数" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>给你一个整数 <code class="language-plaintext highlighter-rouge">n</code> ，返回和为 <code class="language-plaintext highlighter-rouge">n</code> 的完全平方数的最少数量 。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">n</span> <span class="o">=</span> <span class="mi">12</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">3</span> 
<span class="n">解释</span><span class="err">：</span><span class="mi">12</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">4</span>
</pre></table></code></div></div><p>完全平方数就是物品（可以无限件使用），凑个正整数<code class="language-plaintext highlighter-rouge">n</code>就是背包，问凑满这个背包最少有多少物品？</p><p>dp[j]：和为j的完全平方数的最少数量为dp[j]。</p><p>dp[j] 可以由dp[j - i * i]推出， dp[j - i * i] + 1 便可以凑成dp[j]，此时我们要选择最小的dp[j]，所以递推公式为<code class="language-plaintext highlighter-rouge">dp[j] = min(dp[j - i * i] + 1, dp[j])</code>。</p><p>dp[0]表示 和为0的完全平方数的最小数量，那么dp[0]一定是0。非0下标的dp[j]应该是多少呢？从递归公式dp[j] = min(dp[j - i * i] + 1, dp[j])中可以看出每次dp[j]都要选最小的，所以非0下标的dp[j]一定要初始为最大值，这样dp[j]在递推的时候才不会被初始值覆盖。</p><p>本题是求最小值，遍历顺序无要求。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">int</span> <span class="nf">numSquares</span><span class="p">(</span><span class="n">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span> <span class="nf">d</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="no">INT_MAX</span><span class="p">);</span>
        <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="nb">sqrt</span><span class="p">(</span><span class="n">n</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span> <span class="c1">// 遍历物品</span>
            <span class="k">for</span><span class="p">(</span><span class="n">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">){</span> <span class="c1">// 遍历背包</span>
                <span class="n">d</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">d</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="n">i</span> <span class="o">*</span> <span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">d</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">==</span> <span class="no">INT_MAX</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">d</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h3 id="139单词拆分"><span class="mr-2">139.单词拆分</span><a href="#139单词拆分" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>给你一个字符串 <code class="language-plaintext highlighter-rouge">s</code> 和一个字符串列表 <code class="language-plaintext highlighter-rouge">wordDict</code> 作为字典，请你判断是否可以利用字典中出现的单词拼接出 <code class="language-plaintext highlighter-rouge">s</code> 。<strong>注意：</strong>不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="o">:</span> <span class="n">s</span> <span class="o">=</span> <span class="s2">"leetcode"</span><span class="p">,</span> <span class="n">wordDict</span> <span class="o">=</span> <span class="p">[</span><span class="s2">"leet"</span><span class="p">,</span> <span class="s2">"code"</span><span class="p">]</span>
<span class="n">输出</span><span class="o">:</span> <span class="kc">true</span>
<span class="n">解释</span><span class="o">:</span> <span class="n">返回</span> <span class="kc">true</span> <span class="n">因为</span> <span class="s2">"leetcode"</span> <span class="n">可以由</span> <span class="s2">"leet"</span> <span class="n">和</span> <span class="s2">"code"</span> <span class="n">拼接成</span><span class="err">。</span>
</pre></table></code></div></div><p>单词就是物品，字符串s就是背包，单词能否组成字符串s，就是问物品能不能把背包装满。拆分时可以重复使用字典中的单词，说明就是一个<strong>完全背包</strong>！</p><p>数组dp[i]：字符串长度为<code class="language-plaintext highlighter-rouge">i</code>的话，dp[i]为true表示可以拆分为一个或多个在字典中出现的单词。</p><p>如果确定dp[j] 是true，且 <code class="language-plaintext highlighter-rouge">[j, i]</code> 这个区间的子串出现在字典里，那么dp[i]一定是true (j &lt; i)，所以递推公式是<code class="language-plaintext highlighter-rouge"> if([j, i] 这个区间的子串出现在字典里 &amp;&amp; dp[j]是true) </code>那么 dp[i] = true。</p><p><strong>初始化</strong>：从递归公式中可以看出，dp[i] 的状态依靠 dp[j]是否为true，那么dp[0]就是递归的根基，dp[0]一定要为true，否则递归下去后面都都是false了。</p><p>那么dp[0]有没有意义呢？dp[0]表示如果字符串为空的话，说明出现在字典里。但题目中说了“给定一个非空字符串 s” 所以测试数据中不会出现i为0的情况，那么dp[0]初始为true完全就是为了推导公式。</p><p>下标非0的dp[i]初始化为false，只要没有被覆盖说明都是不可拆分为一个或多个在字典中出现的单词。</p><p><strong>遍历顺序</strong>：本题最终要求的是是否都出现过，所以对出现单词集合里的元素是组合还是排列，并不在意！那么本题使用求排列的方式，还是求组合的方式都可以。</p><p>但本题还有特殊性，因为是要求子串，最好是遍历背包放在外循环，将遍历物品放在内循环。如果要是外层for循环遍历物品，内层for遍历背包，就需要把所有的子串都预先放在一个容器里。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">bool</span> <span class="nf">wordBreak</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">wordDict</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="nf">wordSet</span><span class="p">(</span><span class="n">wordDict</span><span class="mf">.</span><span class="nf">begin</span><span class="p">(),</span> <span class="n">wordDict</span><span class="mf">.</span><span class="nb">end</span><span class="p">());</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">bool</span><span class="o">&gt;</span> <span class="nf">dp</span><span class="p">(</span><span class="n">s</span><span class="mf">.</span><span class="nf">size</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
        <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">s</span><span class="mf">.</span><span class="nf">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>   <span class="c1">// 遍历背包</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>       <span class="c1">// 遍历物品</span>
                <span class="n">string</span> <span class="n">word</span> <span class="o">=</span> <span class="n">s</span><span class="mf">.</span><span class="nb">substr</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="n">j</span><span class="p">);</span> <span class="c1">//substr(起始位置，截取的个数)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">wordSet</span><span class="mf">.</span><span class="nf">co</span><span class="p">(</span><span class="n">word</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="p">{</span>
                    <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="n">s</span><span class="mf">.</span><span class="nf">size</span><span class="p">()];</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h2 id="打家劫舍问题"><span class="mr-2">打家劫舍问题</span><a href="#打家劫舍问题" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="198-打家劫舍"><span class="mr-2">198. 打家劫舍</span><a href="#198-打家劫舍" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的<strong>非负整数数组</strong>，计算你不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">4</span>
<span class="n">解释</span><span class="err">：</span><span class="n">偷窃</span> <span class="mi">1</span> <span class="nf">号房屋</span> <span class="p">(</span><span class="n">金额</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="err">，</span><span class="n">然后偷窃</span> <span class="mi">3</span> <span class="nf">号房屋</span> <span class="p">(</span><span class="n">金额</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)</span><span class="err">。</span>
     <span class="n">偷窃到的最高金额</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">=</span> <span class="mi">4</span> <span class="err">。</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">dp[i]</code>：考虑下标<code class="language-plaintext highlighter-rouge">i</code>（包括<code class="language-plaintext highlighter-rouge">i</code>）以内的房屋，最多可以偷窃的金额为<code class="language-plaintext highlighter-rouge">dp[i]</code>。</p><p>决定<code class="language-plaintext highlighter-rouge">dp[i]</code>的因素就是第<code class="language-plaintext highlighter-rouge">i</code>房间偷还是不偷：</p><p>如果偷第<code class="language-plaintext highlighter-rouge">i</code>房间，那么<code class="language-plaintext highlighter-rouge">dp[i] = dp[i - 2] + nums[i]</code> ，即第<code class="language-plaintext highlighter-rouge">i-1</code>房一定是不考虑的，找出 下标<code class="language-plaintext highlighter-rouge">i-2</code>（包括<code class="language-plaintext highlighter-rouge">i-2</code>）以内的房屋，最多可以偷窃的金额为<code class="language-plaintext highlighter-rouge">dp[i-2]</code> 加上第<code class="language-plaintext highlighter-rouge">i</code>房间偷到的钱。</p><p>如果不偷第<code class="language-plaintext highlighter-rouge">i</code>房间，那么<code class="language-plaintext highlighter-rouge">dp[i] = dp[i - 1]</code>，即考虑<code class="language-plaintext highlighter-rouge">i-1</code>房（<strong>注意这里是考虑，并不是一定要偷<code class="language-plaintext highlighter-rouge">i-1</code>房</strong>），然后<code class="language-plaintext highlighter-rouge">dp[i]</code>取最大值，即<code class="language-plaintext highlighter-rouge">dp[i] = max(dp[i - 2] + nums[i], dp[i - 1])</code>。</p><p><strong>初始化</strong>：从递推公式<code class="language-plaintext highlighter-rouge">dp[i] = max(dp[i - 2] + nums[i], dp[i - 1])</code>可以看出，递推公式的基础就是<code class="language-plaintext highlighter-rouge">dp[0]</code> 和 <code class="language-plaintext highlighter-rouge">dp[1]</code>。从<code class="language-plaintext highlighter-rouge">dp[i]</code>的定义上来讲，<code class="language-plaintext highlighter-rouge">dp[0]</code> 一定是<code class="language-plaintext highlighter-rouge"> nums[0]</code>，<code class="language-plaintext highlighter-rouge">dp[1]</code>就是<code class="language-plaintext highlighter-rouge">nums[0]</code>和<code class="language-plaintext highlighter-rouge">nums[1]</code>的最大值，即<code class="language-plaintext highlighter-rouge">dp[1] = max(nums[0], nums[1])</code>。</p><p><strong>遍历顺序</strong>：dp[i] 是根据dp[i - 2] 和 dp[i - 1] 推导出来的，那么一定是从前到后遍历。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">int</span> <span class="nf">rob</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">nums</span><span class="mf">.</span><span class="nb">empty</span><span class="p">())</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">nums</span><span class="mf">.</span><span class="nf">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span> <span class="nf">d</span><span class="p">(</span><span class="n">nums</span><span class="mf">.</span><span class="nf">size</span><span class="p">());</span>
        <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
        <span class="k">for</span><span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="mf">.</span><span class="nf">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">d</span><span class="p">[</span><span class="n">nums</span><span class="mf">.</span><span class="nf">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h3 id="213-打家劫舍-ii"><span class="mr-2">213. 打家劫舍 II</span><a href="#213-打家劫舍-ii" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都<strong>围成一圈</strong> ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">nums</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">3</span>
<span class="n">解释</span><span class="err">：</span><span class="n">你不能先偷窃</span> <span class="mi">1</span> <span class="n">号房屋</span><span class="err">（</span><span class="n">金额</span> <span class="o">=</span> <span class="mi">2</span><span class="err">），</span><span class="n">然后偷窃</span> <span class="mi">3</span> <span class="n">号房屋</span><span class="err">（</span><span class="n">金额</span> <span class="o">=</span> <span class="mi">2</span><span class="err">）</span><span class="p">,</span> <span class="n">因为他们是相邻的</span><span class="err">。</span>
</pre></table></code></div></div><p>这道题目和<strong>198.打家劫舍</strong>是差不多的，唯一区别就是成环了。</p><p>对于一个数组，成环的话主要有如下三种情况：</p><ul><li>情况一：考虑不包含首尾元素<li>情况二：考虑包含首元素，不包含尾元素<li>情况三：考虑包含尾元素，不包含首元素</ul><div align="center"><img data-src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205272041147.png" alt="image-20220527204113996" style="zoom:80%;" data-proofer-ignore></div><p>注意：这里用的是 ⌈<strong>考虑</strong>⌋，例如情况三，虽然是考虑包含尾元素，但不一定要选尾部元素！ 对于情况三，取nums[1] 和 nums[3]就是最大的。<strong>而情况二 和 情况三 都包含了情况一了，所以只考虑情况二和情况三就可以了</strong>。</p><p>分析到这里，本题其实比较简单了， 剩下的和<a href="https://programmercarl.com/0198.打家劫舍.html">198.打家劫舍</a>就是一样的了。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">int</span> <span class="nf">rob</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="mf">.</span><span class="nf">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="mf">.</span><span class="nf">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="n">int</span> <span class="n">result1</span> <span class="o">=</span> <span class="nf">robRange</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">nums</span><span class="mf">.</span><span class="nf">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">2</span><span class="p">);</span> <span class="c1">// 情况二</span>
        <span class="n">int</span> <span class="n">result2</span> <span class="o">=</span> <span class="nf">robRange</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nums</span><span class="mf">.</span><span class="nf">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// 情况三</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">result1</span><span class="p">,</span> <span class="n">result2</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">// 198.打家劫舍的逻辑</span>
    <span class="n">int</span> <span class="nf">robRange</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="n">int</span> <span class="n">start</span><span class="p">,</span> <span class="n">int</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">==</span> <span class="n">start</span><span class="p">)</span> <span class="k">return</span> <span class="n">nums</span><span class="p">[</span><span class="n">start</span><span class="p">];</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span> <span class="nf">dp</span><span class="p">(</span><span class="n">nums</span><span class="mf">.</span><span class="nf">size</span><span class="p">());</span>
        <span class="n">dp</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">start</span><span class="p">];</span>
        <span class="n">dp</span><span class="p">[</span><span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">start</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]);</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="n">end</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h3 id="337-打家劫舍-iii"><span class="mr-2">337. 打家劫舍 III</span><a href="#337-打家劫舍-iii" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 <code class="language-plaintext highlighter-rouge">root</code>。</p><p>除了 <code class="language-plaintext highlighter-rouge">root</code> 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 两个直接相连的房子在同一天晚上被打劫 ，房屋将自动报警。</p><p>给定二叉树的 <code class="language-plaintext highlighter-rouge">root</code> 。返回 <strong>在不触动警报的情况下</strong> ，小偷能够盗取的最高金额。</p><div align="center"><img data-src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202205272053588.png" alt="image-20220527205315463" style="zoom:70%;" data-proofer-ignore></div><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="o">:</span> <span class="n">root</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="kc">null</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="kc">null</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="n">输出</span><span class="o">:</span> <span class="mi">7</span> 
<span class="n">解释</span><span class="o">:</span> <span class="n">小偷一晚能够盗取的最高金额</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">=</span> <span class="mi">7</span>
</pre></table></code></div></div><p>定义函数：返回一个节点偷与不偷两个状态所得到的金钱，返回值是一个长度为2的数组，记录当前节点偷与不偷所得到的的最大金钱。</p><p>dp数组以及下标的含义：下标为0记录不偷该节点所得到的的最大金钱，下标为1记录偷该节点所得到的的最大金钱，本题dp数组就是一个长度为2的数组。</p><p>如果不偷当前节点，那么左右孩子就可以偷，至于到底偷不偷一定是选一个最大的，所以：<code class="language-plaintext highlighter-rouge">val1 = max(left[0], left[1]) + max(right[0], right[1])</code>；如果是偷当前节点，那么左右孩子就不能偷，<code class="language-plaintext highlighter-rouge">val2 = cur-&gt;val + left[0] + right[0]</code>；</p><p>最后当前节点的状态就是<code class="language-plaintext highlighter-rouge">{val2, val1}</code>，即{不偷当前节点得到的最大金钱，偷当前节点得到的最大金钱}。</p><p><strong>初始化</strong>：在遍历的过程中，如果遇到空节点的话，很明显，无论偷还是不偷都是0，所以就返回。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">int</span> <span class="nf">rob</span><span class="p">(</span><span class="nc">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="nf">robTree</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
    <span class="p">}</span>
    <span class="c1">// 返回长度为2的数组，0：不偷，1：偷</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span> <span class="nf">robTree</span><span class="p">(</span><span class="nc">TreeNode</span><span class="o">*</span> <span class="n">cur</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">cur</span> <span class="o">==</span> <span class="kc">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span> <span class="n">left</span> <span class="o">=</span> <span class="nf">robTree</span><span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span> <span class="n">right</span> <span class="o">=</span> <span class="nf">robTree</span><span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
        <span class="c1">// 不偷cur</span>
        <span class="n">int</span> <span class="n">val1</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">left</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">left</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="nb">max</span><span class="p">(</span><span class="n">right</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">right</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
        <span class="c1">// 偷cur</span>
        <span class="n">int</span> <span class="n">val2</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">+</span> <span class="n">left</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">right</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">val1</span><span class="p">,</span> <span class="n">val2</span><span class="p">};</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h2 id="股票买卖问题"><span class="mr-2">股票买卖问题</span><a href="#股票买卖问题" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="121-买卖股票的最佳时机"><span class="mr-2">121. 买卖股票的最佳时机</span><a href="#121-买卖股票的最佳时机" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>给定一个数组 <code class="language-plaintext highlighter-rouge">prices</code> ，它的第 <code class="language-plaintext highlighter-rouge">i</code> 个元素 <code class="language-plaintext highlighter-rouge">prices[i]</code> 表示一支给定股票第 <code class="language-plaintext highlighter-rouge">i</code> 天的价格。你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润，返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code class="language-plaintext highlighter-rouge">0</code> 。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="p">[</span><span class="mi">7</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">5</span>
<span class="n">解释</span><span class="err">：</span><span class="n">在第</span> <span class="mi">2</span> <span class="n">天</span><span class="err">（</span><span class="n">股票价格</span> <span class="o">=</span> <span class="mi">1</span><span class="err">）</span><span class="n">的时候买入</span><span class="err">，</span><span class="n">在第</span> <span class="mi">5</span> <span class="n">天</span><span class="err">（</span><span class="n">股票价格</span> <span class="o">=</span> <span class="mi">6</span><span class="err">）</span><span class="n">的时候卖出</span><span class="err">，</span><span class="n">最大利润</span> <span class="o">=</span> <span class="mi">6</span><span class="o">-</span><span class="mi">1</span> <span class="o">=</span> <span class="mi">5</span> <span class="err">。</span>
     <span class="n">注意利润不能是</span> <span class="mi">7</span><span class="o">-</span><span class="mi">1</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span> <span class="n">因为卖出价格需要大于买入价格</span><span class="err">；</span><span class="n">同时</span><span class="err">，</span><span class="n">你不能在买入前卖出股票</span><span class="err">。</span>
</pre></table></code></div></div><p>定义：<code class="language-plaintext highlighter-rouge">dp[i][1]</code> 表示第<code class="language-plaintext highlighter-rouge">i</code>天<strong>持有</strong>股票所得最多现金 ，<code class="language-plaintext highlighter-rouge">dp[i][0]</code> 表示第<code class="language-plaintext highlighter-rouge">i</code>天<strong>不持有</strong>股票所得最多现金。</p><p>如果第<code class="language-plaintext highlighter-rouge">i</code>天<strong>持有</strong>股票即<code class="language-plaintext highlighter-rouge">dp[i][1]</code>， 那么可以由两个状态推出来：</p><ul><li>第<code class="language-plaintext highlighter-rouge">i-1</code>天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金，即<code class="language-plaintext highlighter-rouge">dp[i - 1][1]</code>；<li>第<code class="language-plaintext highlighter-rouge">i</code>天买入股票，所得现金就是买入今天的股票后所得现金，即<code class="language-plaintext highlighter-rouge">-prices[i]</code>；</ul><p>那么<code class="language-plaintext highlighter-rouge">dp[i][1]</code>应该选所得现金最大的，所以<code class="language-plaintext highlighter-rouge">dp[i][1] = max(dp[i - 1][1], -prices[i])</code>。</p><p>如果第<code class="language-plaintext highlighter-rouge">i</code>天<strong>不持有</strong>股票即<code class="language-plaintext highlighter-rouge">dp[i][0]</code>， 也可以由两个状态推出来：</p><ul><li>第<code class="language-plaintext highlighter-rouge">i-1</code>天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金，即<code class="language-plaintext highlighter-rouge">dp[i - 1][0]</code>；<li>第<code class="language-plaintext highlighter-rouge">i</code>天卖出股票，所得现金就是按照今天股票佳价格卖出后所得现金，即<code class="language-plaintext highlighter-rouge">prices[i] + dp[i - 1][1]</code>；</ul><p>同样<code class="language-plaintext highlighter-rouge">dp[i][1]</code>取最大值，<code class="language-plaintext highlighter-rouge">dp[i][0] = max(dp[i - 1][0], prices[i] + dp[i - 1][1])</code>。</p><p><strong>初始化</strong>：</p><p>由递推公式<code class="language-plaintext highlighter-rouge"> dp[i][1] = max(dp[i - 1][1], -prices[i])</code>和 <code class="language-plaintext highlighter-rouge">dp[i][0] = max(dp[i - 1][0], prices[i] + dp[i - 1][1])</code>可以看出其基础都是要从<code class="language-plaintext highlighter-rouge">dp[0][0]</code>和<code class="language-plaintext highlighter-rouge">dp[0][1]</code>推导出来。</p><p><code class="language-plaintext highlighter-rouge">dp[0][1]</code>表示第0天持有股票，此时的持有股票就一定是买入股票了，因为不可能由前一天推出来，所以<code class="language-plaintext highlighter-rouge">dp[0][1] = - prices[0]</code>。<code class="language-plaintext highlighter-rouge">dp[0][0]</code>表示第0天不持有股票，不持有股票那么现金就是0，所以<code class="language-plaintext highlighter-rouge">dp[0][0] = 0</code>。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre> <span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
     <span class="n">int</span> <span class="nf">maxProfit</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&amp;</span> <span class="n">prices</span><span class="p">)</span> <span class="p">{</span>
         <span class="n">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">prices</span><span class="mf">.</span><span class="nf">size</span><span class="p">();</span>
         <span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
         <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&gt;</span> <span class="nf">dp</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
         <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span> <span class="n">prices</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
         <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
             <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
             <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]);</span>
         <span class="p">}</span>
         <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
     <span class="p">}</span>
 <span class="p">};</span>
</pre></table></code></div></div><h3 id="122-买卖股票的最佳时机-ii"><span class="mr-2">122. 买卖股票的最佳时机 II</span><a href="#122-买卖股票的最佳时机-ii" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>给你一个整数数组 <code class="language-plaintext highlighter-rouge">prices</code> ，其中 <code class="language-plaintext highlighter-rouge">prices[i]</code> 表示某支股票第 <code class="language-plaintext highlighter-rouge">i</code> 天的价格。在每一天，你可以决定是否购买和/或出售股票。你在任何时候 <strong>最多</strong> 只能持有 <strong>一股</strong> 股票。你也可以先购买，然后在 <strong>同一天</strong> 出售。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">prices</span> <span class="o">=</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">7</span>
<span class="n">解释</span><span class="err">：</span><span class="n">在第</span> <span class="mi">2</span> <span class="n">天</span><span class="err">（</span><span class="n">股票价格</span> <span class="o">=</span> <span class="mi">1</span><span class="err">）</span><span class="n">的时候买入</span><span class="err">，</span><span class="n">在第</span> <span class="mi">3</span> <span class="n">天</span><span class="err">（</span><span class="n">股票价格</span> <span class="o">=</span> <span class="mi">5</span><span class="err">）</span><span class="n">的时候卖出</span><span class="p">,</span> <span class="n">这笔交易所能获得利润</span> <span class="o">=</span> <span class="mi">5</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">=</span> <span class="mi">4</span> <span class="err">。</span>
     <span class="n">随后</span><span class="err">，</span><span class="n">在第</span> <span class="mi">4</span> <span class="n">天</span><span class="err">（</span><span class="n">股票价格</span> <span class="o">=</span> <span class="mi">3</span><span class="err">）</span><span class="n">的时候买入</span><span class="err">，</span><span class="n">在第</span> <span class="mi">5</span> <span class="n">天</span><span class="err">（</span><span class="n">股票价格</span> <span class="o">=</span> <span class="mi">6</span><span class="err">）</span><span class="n">的时候卖出</span><span class="p">,</span> <span class="n">这笔交易所能获得利润</span> <span class="o">=</span> <span class="mi">6</span> <span class="o">-</span> <span class="mi">3</span> <span class="o">=</span> <span class="mi">3</span> <span class="err">。</span>
     <span class="n">总利润为</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">=</span> <span class="mi">7</span> <span class="err">。</span>
</pre></table></code></div></div><p>本题和<strong>121. 买卖股票的最佳时机</strong>的唯一区别本题股票可以买卖多次了（注意只有一只股票，所以再次购买前要出售掉之前的股票）。</p><p>定义：<code class="language-plaintext highlighter-rouge">dp[i][1]</code> 表示第<code class="language-plaintext highlighter-rouge">i</code>天<strong>持有</strong>股票所得最多现金 ，<code class="language-plaintext highlighter-rouge">dp[i][0]</code> 表示第<code class="language-plaintext highlighter-rouge">i</code>天<strong>不持有</strong>股票所得最多现金。</p><p>如果第<code class="language-plaintext highlighter-rouge">i</code>天<strong>持有</strong>股票即<code class="language-plaintext highlighter-rouge">dp[i][1]</code>， 那么可以由两个状态推出来：</p><ul><li>第<code class="language-plaintext highlighter-rouge">i-1</code>天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金，即<code class="language-plaintext highlighter-rouge">dp[i - 1][1]</code>；<li>第<code class="language-plaintext highlighter-rouge">i</code>天买入股票，所得现金就是昨天不持有股票的所得现金减去今天的股票价格，即<code class="language-plaintext highlighter-rouge">dp[i - 1][0] - prices[i]</code>；</ul><p>注意这里和121. 买卖股票的最佳时机唯一不同的地方，就是推导<code class="language-plaintext highlighter-rouge">dp[i][1]</code>的时候，第<code class="language-plaintext highlighter-rouge">i</code>天买入股票的情况。在121. 买卖股票的最佳时机中，<strong>因为股票全程只能买卖一次</strong>，所以如果买入股票，那么第<code class="language-plaintext highlighter-rouge">i</code>天持有股票即<code class="language-plaintext highlighter-rouge">dp[i][1]</code>一定就是<code class="language-plaintext highlighter-rouge"> -prices[i]</code>。</p><p>而本题，<strong>因为一只股票可以买卖多次</strong>，所以当第<code class="language-plaintext highlighter-rouge">i</code>天买入股票的时候，所持有的现金可能有之前买卖过的利润。那么第<code class="language-plaintext highlighter-rouge">i</code>天持有股票即<code class="language-plaintext highlighter-rouge">dp[i][1]</code>，如果是第<code class="language-plaintext highlighter-rouge">i</code>天买入股票，所得现金就是昨天不持有股票的所得现金减去今天的股票价格，即<code class="language-plaintext highlighter-rouge">dp[i - 1][0] - prices[i]</code>。</p><p>如果第<code class="language-plaintext highlighter-rouge">i</code>天<strong>不持有</strong>股票即<code class="language-plaintext highlighter-rouge">dp[i][0]</code>的情况， 依然可以由两个状态推出来：</p><ul><li>第<code class="language-plaintext highlighter-rouge">i-1</code>天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金，即<code class="language-plaintext highlighter-rouge">dp[i - 1][0]</code>；<li>第<code class="language-plaintext highlighter-rouge">i</code>天卖出股票，所得现金就是按照今天股票佳价格卖出后所得现金，即<code class="language-plaintext highlighter-rouge">prices[i] + dp[i - 1][1]</code>；</ul><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">int</span> <span class="nf">maxProfit</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&amp;</span> <span class="n">prices</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">prices</span><span class="mf">.</span><span class="nf">size</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&gt;</span> <span class="nf">dp</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
        <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span> <span class="n">prices</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span><span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
            <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h3 id="123-买卖股票的最佳时机-iii"><span class="mr-2">123. 买卖股票的最佳时机 III</span><a href="#123-买卖股票的最佳时机-iii" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>给定一个数组，它的第 <code class="language-plaintext highlighter-rouge">i</code> 个元素是一支给定的股票在第 <code class="language-plaintext highlighter-rouge">i</code> 天的价格。设计一个算法来计算你所能获取的最大利润。你最多可以完成 <strong>两笔</strong> 交易。<strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">prices</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">6</span>
<span class="n">解释</span><span class="err">：</span><span class="n">在第</span> <span class="mi">4</span> <span class="n">天</span><span class="err">（</span><span class="n">股票价格</span> <span class="o">=</span> <span class="mi">0</span><span class="err">）</span><span class="n">的时候买入</span><span class="err">，</span><span class="n">在第</span> <span class="mi">6</span> <span class="n">天</span><span class="err">（</span><span class="n">股票价格</span> <span class="o">=</span> <span class="mi">3</span><span class="err">）</span><span class="n">的时候卖出</span><span class="err">，</span><span class="n">这笔交易所能获得利润</span> <span class="o">=</span> <span class="mi">3</span><span class="o">-</span><span class="mi">0</span> <span class="o">=</span> <span class="mi">3</span> <span class="err">。</span>
<span class="err"> </span>    <span class="n">随后</span><span class="err">，</span><span class="n">在第</span> <span class="mi">7</span> <span class="n">天</span><span class="err">（</span><span class="n">股票价格</span> <span class="o">=</span> <span class="mi">1</span><span class="err">）</span><span class="n">的时候买入</span><span class="err">，</span><span class="n">在第</span> <span class="mi">8</span> <span class="n">天</span> <span class="err">（</span><span class="n">股票价格</span> <span class="o">=</span> <span class="mi">4</span><span class="err">）</span><span class="n">的时候卖出</span><span class="err">，</span><span class="n">这笔交易所能获得利润</span> <span class="o">=</span> <span class="mi">4</span><span class="o">-</span><span class="mi">1</span> <span class="o">=</span> <span class="mi">3</span> <span class="err">。</span>
</pre></table></code></div></div><p>本题中至多买卖两次，这意味着可以买卖一次，可以买卖两次，也可以不买卖。</p><p>一天一共就有五个状态：0. 没有操作，1. 第一次买入，2. 第一次卖出，3. 第二次买入，4. 第二次卖出。</p><p><code class="language-plaintext highlighter-rouge">dp[i][j]</code>中 <code class="language-plaintext highlighter-rouge">i</code>表示第<code class="language-plaintext highlighter-rouge">i</code>天，<code class="language-plaintext highlighter-rouge">j</code>为 <code class="language-plaintext highlighter-rouge">[0 - 4] </code>五个状态，<code class="language-plaintext highlighter-rouge">dp[i][j]</code>表示第<code class="language-plaintext highlighter-rouge">i</code>天状态<code class="language-plaintext highlighter-rouge">j</code>所剩最大现金。</p><p>注意：表示的是第<code class="language-plaintext highlighter-rouge">i</code>天，买入股票的状态，并不是说一定要第<code class="language-plaintext highlighter-rouge">i</code>天买入股票。</p><p>达到<code class="language-plaintext highlighter-rouge">dp[i][1]</code>状态，有两个具体操作：</p><ul><li>操作一：第<code class="language-plaintext highlighter-rouge">i</code>天买入股票，那么<code class="language-plaintext highlighter-rouge">dp[i][1] = dp[i-1][0] - prices[i]</code><li>操作二：第<code class="language-plaintext highlighter-rouge">i</code>天没有操作，而是沿用前一天买入的状态，即<code class="language-plaintext highlighter-rouge">dp[i][1] = dp[i - 1][1]</code></ul><p>取最大值，所以<code class="language-plaintext highlighter-rouge"> dp[i][1] = max(dp[i-1][0] - prices[i], dp[i - 1][1])</code>。</p><p>同理<code class="language-plaintext highlighter-rouge">dp[i][2]</code>也有两个操作：</p><ul><li>操作一：第<code class="language-plaintext highlighter-rouge">i</code>天卖出股票了，那么<code class="language-plaintext highlighter-rouge">dp[i][2] = dp[i - 1][1] + prices[i]</code><li>操作二：第<code class="language-plaintext highlighter-rouge">i</code>天没有操作，沿用前一天卖出股票的状态，即<code class="language-plaintext highlighter-rouge">dp[i][2] = dp[i - 1][2]</code></ul><p>所以<code class="language-plaintext highlighter-rouge">dp[i][2] = max(dp[i - 1][1] + prices[i], dp[i - 1][2])</code>。</p><p>同理可推出剩下状态部分：<code class="language-plaintext highlighter-rouge">dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] - prices[i])</code>，<code class="language-plaintext highlighter-rouge">dp[i][4] = max(dp[i - 1][4], dp[i - 1][3] + prices[i])</code>。</p><p><strong>初始化</strong>：</p><p>第0天<strong>没有操作</strong>，<code class="language-plaintext highlighter-rouge">dp[0][0] = 0</code>。</p><p>第0天做<strong>第一次买入</strong>的操作，<code class="language-plaintext highlighter-rouge">dp[0][1] = -prices[0]</code>。</p><p>第0天做<strong>第一次卖出</strong>的操作，这个初始值应该是多少呢？首先卖出的操作一定是收获利润，整个股票买卖最差情况也就是没有盈利即全程无操作现金为0，从递推公式中可以看出每次是取最大值，那么既然是收获利润，如果比0还小了就没有必要收获这个利润了，所以<code class="language-plaintext highlighter-rouge">dp[0][2] = 0</code>。</p><p>第0天<strong>第二次买入</strong>操作，初始值应该是多少呢？第二次买入依赖于第一次卖出的状态，其实相当于第0天第一次买入了，第一次卖出了，然后再买入一次（第二次买入），那么现在手头上没有现金，只要买入，现金就做相应的减少。所以第二次买入操作，初始化为<code class="language-plaintext highlighter-rouge">dp[0][3] = -prices[0]</code>。</p><p>同理，第0天<strong>第二次卖出</strong>初始化<code class="language-plaintext highlighter-rouge">dp[0][4] = 0</code>。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">int</span> <span class="nf">maxProfit</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&amp;</span> <span class="n">prices</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">prices</span><span class="mf">.</span><span class="nf">size</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&gt;</span> <span class="nf">dp</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
        <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">prices</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">prices</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
            <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
            <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
            <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">3</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
            <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">4</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">4</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h3 id="188买卖股票的最佳时机iv"><span class="mr-2">188.买卖股票的最佳时机IV</span><a href="#188买卖股票的最佳时机iv" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>给定一个整数数组 <code class="language-plaintext highlighter-rouge">prices</code> ，它的第 <code class="language-plaintext highlighter-rouge">i</code> 个元素 <code class="language-plaintext highlighter-rouge">prices[i]</code> 是一支给定的股票在第 <code class="language-plaintext highlighter-rouge">i</code> 天的价格。设计一个算法来计算你所能获取的最大利润。你最多可以完成 <strong>k</strong> 笔交易。<strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">k</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">prices</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">2</span>
<span class="n">解释</span><span class="err">：</span><span class="n">在第</span> <span class="mi">1</span> <span class="nf">天</span> <span class="p">(</span><span class="n">股票价格</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="n">的时候买入</span><span class="err">，</span><span class="n">在第</span> <span class="mi">2</span> <span class="nf">天</span> <span class="p">(</span><span class="n">股票价格</span> <span class="o">=</span> <span class="mi">4</span><span class="p">)</span> <span class="n">的时候卖出</span><span class="err">，</span><span class="n">这笔交易所能获得利润</span> <span class="o">=</span> <span class="mi">4</span><span class="o">-</span><span class="mi">2</span> <span class="o">=</span> <span class="mi">2</span> <span class="err">。</span>
</pre></table></code></div></div><p>本题要求至多有<code class="language-plaintext highlighter-rouge">k</code>次交易。</p><p>二维数组 <code class="language-plaintext highlighter-rouge">dp[i][j]</code> ：第<code class="language-plaintext highlighter-rouge">i</code>天的状态为<code class="language-plaintext highlighter-rouge">j</code>，所剩下的最大现金是<code class="language-plaintext highlighter-rouge">dp[i][j]</code>。</p><p><code class="language-plaintext highlighter-rouge">j</code>的状态表示为：0 表示不操作，1 第一次买入，2 第一次卖出，3 第二次买入，4 第二次卖出 …..</p><p>发现规律：除了0以外，奇数就是买入，偶数就是卖出。题目要求至多有k笔交易，那么<code class="language-plaintext highlighter-rouge">j</code>的范围就定义为 <code class="language-plaintext highlighter-rouge">2 * k + 1 </code>就可以了。</p><p>达到<code class="language-plaintext highlighter-rouge">dp[i][1]</code>状态，有两个具体操作：</p><ul><li>操作一：第<code class="language-plaintext highlighter-rouge">i</code>天买入股票了，那么<code class="language-plaintext highlighter-rouge">dp[i][1] = dp[i - 1][0] - prices[i]</code><li>操作二：第<code class="language-plaintext highlighter-rouge">i</code>天没有操作，而是沿用前一天买入的状态，即<code class="language-plaintext highlighter-rouge">dp[i][1] = dp[i - 1][1]</code></ul><p>选最大的，所以 <code class="language-plaintext highlighter-rouge">dp[i][1] = max(dp[i - 1][0] - prices[i], dp[i - 1][1])</code>。</p><p>同理<code class="language-plaintext highlighter-rouge">dp[i][2]</code>也有两个操作：</p><ul><li>操作一：第<code class="language-plaintext highlighter-rouge">i</code>天卖出股票了，那么<code class="language-plaintext highlighter-rouge">dp[i][2] = dp[i - 1][1] + prices[i]</code><li>操作二：第<code class="language-plaintext highlighter-rouge">i</code>天没有操作，沿用前一天卖出股票的状态，即<code class="language-plaintext highlighter-rouge">dp[i][2] = dp[i - 1][2]</code></ul><p>所以<code class="language-plaintext highlighter-rouge">dp[i][2] = max(dp[i - 1][1] + prices[i], dp[i - 1][2])</code>。</p><p>同理可以类比剩下的状态。</p><p><strong>初始化</strong>：</p><p>第0天<strong>没有操作</strong>，<code class="language-plaintext highlighter-rouge">dp[0][0] = 0</code>。</p><p>第0天做<strong>第一次买入</strong>的操作，<code class="language-plaintext highlighter-rouge">dp[0][1] = -prices[0]</code>。</p><p>第0天做<strong>第一次卖出</strong>的操作，这个初始值应该是多少呢？首先卖出的操作一定是收获利润，整个股票买卖最差情况也就是没有盈利即全程无操作现金为0。从递推公式中可以看出每次是取最大值，那么既然是收获利润如果比0还小了就没有必要收获这个利润了，所以<code class="language-plaintext highlighter-rouge">dp[0][2] = 0</code>。</p><p>第0天<strong>第二次买入操</strong>作，初始值应该是多少呢？不用管第几次，现在手头上没有现金，只要买入，现金就做相应的减少。第二次买入操作，初始化为<code class="language-plaintext highlighter-rouge">dp[0][3] = -prices[0]</code>。</p><p>可以推出<code class="language-plaintext highlighter-rouge">dp[0][j]</code>当<code class="language-plaintext highlighter-rouge">j</code>为奇数的时候都初始化为<code class="language-plaintext highlighter-rouge"> -prices[0]</code>，当<code class="language-plaintext highlighter-rouge">j</code>为偶数的时候都初始化为0。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre> <span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
     <span class="n">int</span> <span class="nf">maxProfit</span><span class="p">(</span><span class="n">int</span> <span class="n">k</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&amp;</span> <span class="n">prices</span><span class="p">)</span> <span class="p">{</span>
         <span class="n">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">prices</span><span class="mf">.</span><span class="nf">size</span><span class="p">();</span>
         <span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
         <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&gt;</span> <span class="nf">dp</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
         <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">k</span><span class="p">;</span> <span class="n">j</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
             <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">prices</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
         <span class="p">}</span>
         <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
             <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
                 <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
                 <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span> <span class="o">+</span> <span class="mi">2</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
             <span class="p">}</span>
         <span class="p">}</span>
         <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">2</span> <span class="o">*</span> <span class="n">k</span><span class="p">];</span>
     <span class="p">}</span>
 <span class="p">};</span>
</pre></table></code></div></div><h3 id="309-最佳买卖股票时机含冷冻期"><span class="mr-2">309. 最佳买卖股票时机含冷冻期</span><a href="#309-最佳买卖股票时机含冷冻期" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>给定一个整数数组<code class="language-plaintext highlighter-rouge">prices</code>，其中第 <code class="language-plaintext highlighter-rouge">prices[i]</code> 表示第 <code class="language-plaintext highlighter-rouge">i</code> 天的股票价格 。设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）：<strong>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)</strong>。<strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="o">:</span> <span class="n">prices</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="n">输出</span><span class="o">:</span> <span class="mi">3</span> 
<span class="n">解释</span><span class="o">:</span> <span class="n">对应的交易状态为</span><span class="o">:</span> <span class="p">[</span><span class="n">买入</span><span class="p">,</span> <span class="n">卖出</span><span class="p">,</span> <span class="n">冷冻期</span><span class="p">,</span> <span class="n">买入</span><span class="p">,</span> <span class="n">卖出</span><span class="p">]</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">dp[i][j]</code>：第<code class="language-plaintext highlighter-rouge">i</code>天状态为<code class="language-plaintext highlighter-rouge">j</code>，所剩的最多现金为<code class="language-plaintext highlighter-rouge">dp[i][j]</code>。</p><p>可以区分出如下四个状态，（将买出股票状态细分为三个状态：状态0，2，3）：</p><ul><li>状态0：今天卖出股票<li>状态1：今天为买入股票状态（今天买入股票，或者是之前就买入了股票然后没有操作）<li>状态2：今天为冷冻期状态，持续一天<li>状态3：今天已经度过冷冻期，一直没操作，今天保持卖出股票状态</ul><p><code class="language-plaintext highlighter-rouge">j</code>的状态为：0：状态0，1：状态1，2：状态2，3：状态3。</p><p>达到今天就卖出股票状态（<strong>状态0</strong>），即<code class="language-plaintext highlighter-rouge">dp[i][0] </code>，只有一种可能：昨天一定是买入股票状态（状态1），今天卖出，<code class="language-plaintext highlighter-rouge">dp[i][0] = dp[i - 1][1] + prices[i]</code></p><p>达到买入股票状态（<strong>状态1</strong>）即<code class="language-plaintext highlighter-rouge">dp[i][1]</code>，有如下情况：</p><ul><li>前一天就是持有股票状态（状态0），<code class="language-plaintext highlighter-rouge">dp[i][1] = dp[i - 1][1]</code><li>前一天是冷冻期（状态2），<code class="language-plaintext highlighter-rouge">dp[i - 1][2] - prices[i]</code><li>前一天已经度过冷冻期（状态3），<code class="language-plaintext highlighter-rouge">dp[i - 1][3] - prices[i]</code></ul><p>取最大值，那么<code class="language-plaintext highlighter-rouge">dp[i][1] = max(dp[i - 1][1], max(dp[i - 1][2], dp[i - 1][3]) - prices[i])</code>。</p><p>达到冷冻期状态（<strong>状态2</strong>），即<code class="language-plaintext highlighter-rouge">dp[i][2]</code>，只有一种情况：昨天卖出了股票（状态0），<code class="language-plaintext highlighter-rouge">dp[i][2] = dp[i - 1][0]</code>。</p><p>已经度过冷冻期（<strong>状态3</strong>）即<code class="language-plaintext highlighter-rouge">dp[i][3]</code>，有两个情况：</p><ul><li>前一天就是冷冻期（状态2）<li>前一天依然度过了冷冻期（状态3）</ul><p><code class="language-plaintext highlighter-rouge">dp[i][3] = max(dp[i - 1][3], dp[i - 1][2])</code></p><p><strong>初始化</strong>：</p><p>今天卖出了股票（状态0），<code class="language-plaintext highlighter-rouge">dp[0][0]</code>初始化为0，因为最少收益就是0，绝不会是负数。</p><p>如果是持有股票状态（状态1）那么<code class="language-plaintext highlighter-rouge">dp[0][1] = -prices[0]</code>，买入股票所剩现金为负数。</p><p>处在冷冻期（状态2），<code class="language-plaintext highlighter-rouge">dp[0][2]</code>初始化为0。</p><p>保持卖出股票已经度过了冷冻期（状态3），<code class="language-plaintext highlighter-rouge">dp[0][3]</code>初始化为0。</p><p>最后结果是取状态0，状态2，和状态3的最大值。别把状态2忘了，状态2是冷冻期，最后一天如果是冷冻期也可能是最大值。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">int</span> <span class="nf">maxProfit</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&amp;</span> <span class="n">prices</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">prices</span><span class="mf">.</span><span class="nf">size</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&gt;</span> <span class="nf">dp</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
        <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-=</span> <span class="n">prices</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> 
        <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="nb">max</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">3</span><span class="p">])</span> <span class="o">-</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
            <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
            <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">3</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="nb">max</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">3</span><span class="p">]));</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h3 id="714-买卖股票的最佳时机含手续费"><span class="mr-2">714. 买卖股票的最佳时机含手续费</span><a href="#714-买卖股票的最佳时机含手续费" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>给定一个整数数组 <code class="language-plaintext highlighter-rouge">prices</code>，其中 <code class="language-plaintext highlighter-rouge">prices[i]</code>表示第 <code class="language-plaintext highlighter-rouge">i</code> 天的股票价格 ；整数 <code class="language-plaintext highlighter-rouge">fee</code> 代表了交易股票的手续费用。你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。返回获得利润的最大值。<strong>注意：</strong>这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">prices</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">9</span><span class="p">],</span> <span class="n">fee</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">8</span>
<span class="n">解释</span><span class="err">：</span><span class="n">能够达到的最大利润</span><span class="o">:</span>  
<span class="n">在此处买入</span> <span class="n">prices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">在此处卖出</span> <span class="n">prices</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">8</span>
<span class="n">在此处买入</span> <span class="n">prices</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">在此处卖出</span> <span class="n">prices</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mi">9</span>
<span class="n">总利润</span><span class="o">:</span> <span class="p">((</span><span class="mi">8</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="p">((</span><span class="mi">9</span> <span class="o">-</span> <span class="mi">4</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">=</span> <span class="mi">8</span>
</pre></table></code></div></div><p>本题和动态规划<strong>122.买卖股票的最佳时机II</strong>的区别就是这里需要多一个<strong>减去手续费</strong>的操作。</p><p><code class="language-plaintext highlighter-rouge">dp[i][1]</code>表示第<code class="language-plaintext highlighter-rouge">i</code>天<strong>持有</strong>股票所省最多现金，<code class="language-plaintext highlighter-rouge">dp[i][0] </code>表示第<code class="language-plaintext highlighter-rouge">i</code>天<strong>不持有</strong>股票所得最多现金。</p><p>如果第<code class="language-plaintext highlighter-rouge">i</code>天<strong>持有</strong>股票即<code class="language-plaintext highlighter-rouge">dp[i][1]</code>， 那么可以由两个状态推出来：</p><ul><li>第<code class="language-plaintext highlighter-rouge">i-1</code>天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金，即<code class="language-plaintext highlighter-rouge">dp[i - 1][1]</code><li>第<code class="language-plaintext highlighter-rouge">i</code>天买入股票，所得现金就是昨天不持有股票的所得现金减去今天的股票价格，即<code class="language-plaintext highlighter-rouge">dp[i - 1][0] - prices[i]</code></ul><p>所以：<code class="language-plaintext highlighter-rouge">dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i])</code>。</p><p>如果第<code class="language-plaintext highlighter-rouge">i</code>天<strong>不持有</strong>股票即<code class="language-plaintext highlighter-rouge">dp[i][0]</code>的情况， 依然可以由两个状态推出来：</p><ul><li>第<code class="language-plaintext highlighter-rouge">i-1</code>天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金，即<code class="language-plaintext highlighter-rouge">dp[i - 1][0]</code><li>第<code class="language-plaintext highlighter-rouge">i</code>天卖出股票，所得现金就是按照今天股票价格卖出后所得现金，<strong>注意这里需要有手续费了</strong>，即<code class="language-plaintext highlighter-rouge">dp[i - 1][1] + prices[i] - fee</code></ul><p>所以：<code class="language-plaintext highlighter-rouge">dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i] - fee)</code>。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">int</span> <span class="nf">maxProfit</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&amp;</span> <span class="n">prices</span><span class="p">,</span> <span class="n">int</span> <span class="n">fee</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">prices</span><span class="mf">.</span><span class="nf">size</span><span class="p">();</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&gt;</span> <span class="nf">dp</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
        <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-=</span> <span class="n">prices</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> 
        <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
            <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">fee</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]);</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h1 id="参考资料">参考资料</h1><p><a href="https://labuladong.github.io/algo/">labuladong 的算法小抄 :: labuladong的算法小抄</a></p><p><a href="https://programmercarl.com/">代码随想录 (programmercarl.com)</a></p><p><a href="https://leetcode-cn.com/problemset/all/">题库 - 力扣 (LeetCode) 全球极客挚爱的技术成长平台 (leetcode-cn.com)</a></p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/'>算法刷题</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/%E7%AE%97%E6%B3%95/" class="post-tag no-text-decoration" >算法</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 本文由作者按照 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 进行授权</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">分享</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=%E4%BA%94%E3%80%81%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92+-+%E5%8D%A1%E5%8D%A1%E6%88%90%E9%95%BF%E6%B1%87%E8%81%9A%E9%98%BF%E8%B1%B9&url=%2Fposts%2F%25E4%25BA%2594-%25E5%258A%25A8%25E6%2580%2581%25E8%25A7%2584%25E5%2588%2592%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=%E4%BA%94%E3%80%81%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92+-+%E5%8D%A1%E5%8D%A1%E6%88%90%E9%95%BF%E6%B1%87%E8%81%9A%E9%98%BF%E8%B1%B9&u=%2Fposts%2F%25E4%25BA%2594-%25E5%258A%25A8%25E6%2580%2581%25E8%25A7%2584%25E5%2588%2592%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=%2Fposts%2F%25E4%25BA%2594-%25E5%258A%25A8%25E6%2580%2581%25E8%25A7%2584%25E5%2588%2592%2F&text=%E4%BA%94%E3%80%81%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92+-+%E5%8D%A1%E5%8D%A1%E6%88%90%E9%95%BF%E6%B1%87%E8%81%9A%E9%98%BF%E8%B1%B9" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="分享链接" data-title-succeed="链接已复制！"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">最近更新</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/%E5%85%B3%E6%B3%A8/">关注</a><li><a href="/posts/%E4%B8%83-%E8%A1%A5%E5%85%85/">七、补充</a><li><a href="/posts/%E5%85%AD-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/">六、贪心算法</a><li><a href="/posts/%E4%BA%94-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">五、动态规划</a><li><a href="/posts/%E5%9B%9B-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/">四、回溯算法</a></ul></div><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/%E7%AE%97%E6%B3%95/">算法</a> <a class="post-tag" href="/tags/%E8%B5%84%E6%BA%90/">资源</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">文章内容</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>相关文章</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/%E4%B8%83-%E8%A1%A5%E5%85%85/"><div class="card-body"> <em class="small" data-ts="1655865240" data-df="YYYY-MM-DD" > 2022-06-22 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>七、补充</h3><div class="text-muted small"><p> 7. 整数反转 给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。如果反转后整数超过 32 位的有符号整数的范围 [−231, 231 − 1] ，就返回 0。假设环境不允许存储 64 位整数（有符号或无符号）。 输入：x = 123 输出：321 class Solution { public: int reverse(int x) { ...</p></div></div></a></div><div class="card"> <a href="/posts/%E5%85%AD-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"><div class="card-body"> <em class="small" data-ts="1655951640" data-df="YYYY-MM-DD" > 2022-06-23 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>六、贪心算法</h3><div class="text-muted small"><p> 435. 无重叠区间 给定一个区间的集合 intervals ，其中 intervals[i] = [starti, endi] ，返回需要移除区间的最小数量，使剩余区间互不重叠 。 输入: intervals = [[1,2],[2,3],[3,4],[1,3]] 输出: 1 解释: 移除 [1,3] 后，剩下的区间没有重叠。 右边界排序，从左向右记录非交叉区间的个数，最后用区间总...</p></div></div></a></div><div class="card"> <a href="/posts/%E5%9B%9B-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"><div class="card-body"> <em class="small" data-ts="1656124440" data-df="YYYY-MM-DD" > 2022-06-25 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>四、回溯算法</h3><div class="text-muted small"><p> 排列组合子集问题 78. 子集 给你一个整数数组 nums，数组中的元素互不相同 ，返回该数组所有可能的子集（幂集）。解集不能包含重复的子集，你可以按任意顺序 返回解集。 1 2 输入：nums = [1,2,3] 输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]] 本质上子集问题就是遍历这样用一棵回溯树： 1 2 3 4 5 6 ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/%E5%85%AD-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/" class="btn btn-outline-primary" prompt="上一篇"><p>六、贪心算法</p></a> <a href="/posts/%E5%9B%9B-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/" class="btn btn-outline-primary" prompt="下一篇"><p>四、回溯算法</p></a></div></div></div><footer class="row pl-3 pr-3"><div class="col-12 d-flex justify-content-between align-items-center text-muted pl-0 pr-0"><div class="footer-left"><p class="mb-0"> © 2022 <a href="https://twitter.com/username">CARLOSGP2021</a>. <span data-toggle="tooltip" data-placement="top" title="除非另有说明，本网站上的博客文章均由作者按照知识共享署名 4.0 国际 (CC BY 4.0) 许可协议进行授权。">保留部分权利。</span></p></div><div class="footer-right"><p class="mb-0"> 本站由 <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> 生成，采用 <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> 主题。</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/%E7%AE%97%E6%B3%95/">算法</a> <a class="post-tag" href="/tags/%E8%B5%84%E6%BA%90/">资源</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><script src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js"></script> <script> $(function() { function updateMermaid(event) { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { const mode = event.data.message; if (typeof mermaid === "undefined") { return; } let expectedTheme = (mode === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* Re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } let initTheme = "default"; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches ) ) { initTheme = "dark"; } let mermaidConf = { theme: initTheme /* <default|dark|forest|neutral> */ }; /* Markdown converts to HTML */ $("pre").has("code.language-mermaid").each(function() { let svgCode = $(this).children().html(); $(this).addClass("unloaded"); $(this).after(`<div class=\"mermaid\">${svgCode}</div>`); }); mermaid.initialize(mermaidConf); window.addEventListener("message", updateMermaid); }); </script><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a><div id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-animation="true" data-autohide="false"><div class="toast-header"> <button type="button" class="ml-2 ml-auto close" data-dismiss="toast" aria-label="Close"> <span aria-hidden="true">&times;</span> </button></div><div class="toast-body text-center pt-0"><p class="pl-2 pr-2 mb-3"></p><button type="button" class="btn btn-primary" aria-label="Update"> </button></div></div><script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">搜索结果为空</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/asia/shanghai.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script>
