<!DOCTYPE html><html lang="zh-CN" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="prefer-datetime-locale" content="Asia/Shanghai"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="四、回溯算法" /><meta name="author" content="卡卡成长汇聚阿豹" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="排列组合子集问题" /><meta property="og:description" content="排列组合子集问题" /><link rel="canonical" href="/posts/%E5%9B%9B-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/" /><meta property="og:url" content="/posts/%E5%9B%9B-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/" /><meta property="og:site_name" content="卡卡成长汇聚阿豹" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-06-25T02:34:00+00:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="四、回溯算法" /><meta name="twitter:site" content="@twitter_username" /><meta name="twitter:creator" content="@卡卡成长汇聚阿豹" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"卡卡成长汇聚阿豹"},"dateModified":"2022-06-27T07:10:18+00:00","datePublished":"2022-06-25T02:34:00+00:00","description":"排列组合子集问题","headline":"四、回溯算法","mainEntityOfPage":{"@type":"WebPage","@id":"/posts/%E5%9B%9B-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"},"url":"/posts/%E5%9B%9B-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"}</script><title>四、回溯算法 | 卡卡成长汇聚阿豹</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="卡卡成长汇聚阿豹"><meta name="application-name" content="卡卡成长汇聚阿豹"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="/assets/config/kaka.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">卡卡成长汇聚阿豹</a></div><div class="site-subtitle font-italic">微信公众号：卡卡成长汇聚</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>首页</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>分类</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>标签</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>归档</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>关于</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/CARLOSGP2021" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/twitter_username" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['example','doamin.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> 首页 </a> </span> <span>四、回溯算法</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> 文章</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="搜索..."> </span> <span id="search-cancel" >取消</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>四、回溯算法</h1><div class="post-meta text-muted"> <span> 发表于 <em class="" data-ts="1656124440" data-df="YYYY-MM-DD" data-toggle="tooltip" data-placement="bottom"> 2022-06-25 </em> </span> <span> 更新于 <em class="" data-ts="1656313818" data-df="YYYY-MM-DD" data-toggle="tooltip" data-placement="bottom"> 2022-06-27 </em> </span><div class="d-flex justify-content-between"> <span> 作者 <em> CARLOSGP2021 </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="9182 字"> <em>51 分钟</em>阅读</span></div></div></div><div class="post-content"><h2 id="排列组合子集问题"><span class="mr-2">排列组合子集问题</span><a href="#排列组合子集问题" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="78-子集"><span class="mr-2">78. 子集</span><a href="#78-子集" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>给你一个整数数组 <code class="language-plaintext highlighter-rouge">nums</code>，<strong>数组中的元素互不相同</strong> ，返回该数组所有可能的子集（幂集）。解集不能包含重复的子集，你可以按任意顺序 返回解集。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre> <span class="n">输入</span><span class="err">：</span><span class="n">nums</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
 <span class="n">输出</span><span class="err">：</span><span class="p">[[],[</span><span class="mi">1</span><span class="p">],[</span><span class="mi">2</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]]</span>
</pre></table></code></div></div><p>本质上子集问题就是遍历这样用一棵回溯树：</p><div align="center"><img data-src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202206111654937.png" alt="image-20220611165427827" style="zoom:80%;" data-proofer-ignore></div><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&gt;</span> <span class="n">res</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span> <span class="n">path</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&gt;</span> <span class="nf">subsets</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">backtrack</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">void</span> <span class="nf">backtrack</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="n">int</span> <span class="n">start</span><span class="p">){</span>
        <span class="n">res</span><span class="mf">.</span><span class="nf">push_back</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
        <span class="k">for</span><span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="mf">.</span><span class="nf">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="n">path</span><span class="mf">.</span><span class="nf">push_back</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
            <span class="nf">backtrack</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
            <span class="n">path</span><span class="mf">.</span><span class="nf">pop_back</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h3 id="90-子集-ii"><span class="mr-2">90. 子集 II</span><a href="#90-子集-ii" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>给你一个整数数组<code class="language-plaintext highlighter-rouge">nums</code>，<strong>其中可能包含重复元素</strong>，请你返回该数组所有可能的子集（幂集）。解集不能包含重复的子集，返回的解集中，子集可以按任意顺序排列。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">nums</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="n">输出</span><span class="err">：</span><span class="p">[[],[</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">2</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]]</span>
</pre></table></code></div></div><p>这道题目和<strong>78.子集</strong>的区别就是集合里有重复的元素，而且求取的子集path要去重。需要先进行排序，让相同的元素靠在一起，如果发现 <code class="language-plaintext highlighter-rouge">nums[i] == nums[i-1]</code>，则跳过。path中加入一个元素，不会再加入相同的元素。</p><div align="center"><img data-src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202206111737073.png" alt="image-20220611173659959" style="zoom:80%;" data-proofer-ignore></div><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&gt;</span> <span class="n">res</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span> <span class="n">path</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&gt;</span> <span class="nf">subsetsWithDup</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
        <span class="nb">sort</span><span class="p">(</span><span class="n">nums</span><span class="mf">.</span><span class="nf">begin</span><span class="p">(),</span> <span class="n">nums</span><span class="mf">.</span><span class="nb">end</span><span class="p">());</span>	<span class="c1">// 去重前需要排序</span>
        <span class="nf">backtrack</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">void</span> <span class="nf">backtrack</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="n">int</span> <span class="n">start</span><span class="p">){</span>
        <span class="n">res</span><span class="mf">.</span><span class="nf">push_back</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
        <span class="k">for</span><span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="mf">.</span><span class="nf">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="k">if</span><span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="n">start</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span> <span class="k">continue</span><span class="p">;</span> <span class="c1">// 去重</span>
            <span class="n">path</span><span class="mf">.</span><span class="nf">push_back</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
            <span class="nf">backtrack</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
            <span class="n">path</span><span class="mf">.</span><span class="nf">pop_back</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h3 id="77-组合"><span class="mr-2">77. 组合</span><a href="#77-组合" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>给定两个整数 <code class="language-plaintext highlighter-rouge">n</code> 和 <code class="language-plaintext highlighter-rouge">k</code>，返回范围 <code class="language-plaintext highlighter-rouge">[1, n]</code> 中所有可能的 <code class="language-plaintext highlighter-rouge">k</code> 个数的组合，你可以按 <strong>任何顺序</strong> 返回答案。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">n</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">输出</span><span class="err">：</span>
<span class="p">[</span>
  <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span>
  <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span>
  <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span>
  <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span>
  <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span>
  <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span>
<span class="p">]</span>
</pre></table></code></div></div><p>大小为 k 的组合就是大小为 k 的子集，还是以 nums = [1,2,3] 为例，刚才求所有子集，就是把所有节点的值都收集起来；现在只需要把第 2 层（根节点视为第 0 层）的节点收集起来，就是大小为 2 的所有组合：</p><div align="center"><img data-src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202206111758888.png" alt="image-20220611175811776" style="zoom:80%;" data-proofer-ignore></div><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&gt;</span> <span class="n">res</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span> <span class="n">path</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&gt;</span> <span class="nf">combine</span><span class="p">(</span><span class="n">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">backtrack</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">void</span> <span class="nf">backtrack</span><span class="p">(</span><span class="n">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">int</span> <span class="n">k</span><span class="p">,</span> <span class="n">int</span> <span class="n">start</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="n">k</span> <span class="o">==</span> <span class="n">path</span><span class="mf">.</span><span class="nf">size</span><span class="p">()){</span>
            <span class="n">res</span><span class="mf">.</span><span class="nf">push_back</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">for</span><span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="n">path</span><span class="mf">.</span><span class="nf">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
            <span class="nf">backtrack</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
            <span class="n">path</span><span class="mf">.</span><span class="nf">pop_back</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h3 id="39-组合总和"><span class="mr-2">39. 组合总和</span><a href="#39-组合总和" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>给你一个<strong>无重复元素</strong>的整数数组 <code class="language-plaintext highlighter-rouge">candidates </code>和一个目标整数 <code class="language-plaintext highlighter-rouge">target </code>，找出 <code class="language-plaintext highlighter-rouge">candidates </code>中可以使数字和为目标数 <code class="language-plaintext highlighter-rouge">target </code>的 所有不同组合 ，并以列表形式返回。你可以按任意顺序返回这些组合。<code class="language-plaintext highlighter-rouge">candidates </code>中的<strong>同一个数字可以无限制重复被选取</strong> 。如果至少一个数字的被选数量不同，则两种组合是不同的。 对于给定的输入，保证和为 <code class="language-plaintext highlighter-rouge">target </code>的不同组合数少于 150 个。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre> <span class="n">输入</span><span class="err">：</span><span class="n">candidates</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">],</span> <span class="n">target</span> <span class="o">=</span> <span class="mi">7</span>
 <span class="n">输出</span><span class="err">：</span><span class="p">[[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">7</span><span class="p">]]</span>
 <span class="n">解释</span><span class="err">：</span>
 <span class="mi">2</span> <span class="n">和</span> <span class="mi">3</span> <span class="n">可以形成一组候选</span><span class="err">，</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">=</span> <span class="mi">7</span> <span class="err">。</span><span class="n">注意</span> <span class="mi">2</span> <span class="n">可以使用多次</span><span class="err">。</span><span class="mi">7</span> <span class="n">也是一个候选</span><span class="err">，</span> <span class="mi">7</span> <span class="o">=</span> <span class="mi">7</span> <span class="err">。</span><span class="n">仅有这两种组合</span><span class="err">。</span>
</pre></table></code></div></div><p>本道题中：输入数组无重复元素，每个元素可以被无限次使用。</p><p>标准的子集/组合问题是如何保证不重复使用元素的？在于 <code class="language-plaintext highlighter-rouge">backtrack</code> 递归时输入的参数 <code class="language-plaintext highlighter-rouge">start</code>， <code class="language-plaintext highlighter-rouge">i</code> 从 <code class="language-plaintext highlighter-rouge">start </code>开始，那么下一层回溯树就是从 <code class="language-plaintext highlighter-rouge">start + 1</code> 开始，从而保证 <code class="language-plaintext highlighter-rouge">nums[start]</code> 这个元素不会被重复使用。</p><div align="center"><img data-src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202206121142519.png" alt="image-20220612114218321" style="zoom:70%;" data-proofer-ignore></div><p>想让每个元素被重复使用，我只要把 <code class="language-plaintext highlighter-rouge">i + 1</code> 改成 <code class="language-plaintext highlighter-rouge">i</code> 即可。这相当于给之前的回溯树添加了一条树枝，在遍历这棵树的过程中，一个元素可以被无限次使用。</p><div align="center"><img data-src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202206121145763.png" alt="image-20220612114503646" style="zoom:80%;" data-proofer-ignore></div><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&gt;</span> <span class="n">res</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span> <span class="n">path</span><span class="p">;</span>
    <span class="n">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&gt;</span> <span class="nf">combinationSum</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&amp;</span> <span class="n">candidates</span><span class="p">,</span> <span class="n">int</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">backtrack</span><span class="p">(</span><span class="n">candidates</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">void</span> <span class="nf">backtrack</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&amp;</span> <span class="n">candidates</span><span class="p">,</span> <span class="n">int</span> <span class="n">target</span><span class="p">,</span> <span class="n">int</span> <span class="n">start</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="n">sum</span> <span class="o">&gt;</span> <span class="n">target</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">sum</span> <span class="o">==</span> <span class="n">target</span><span class="p">){</span>
            <span class="n">res</span><span class="mf">.</span><span class="nf">push_back</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">for</span><span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">candidates</span><span class="mf">.</span><span class="nf">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="n">path</span><span class="mf">.</span><span class="nf">push_back</span><span class="p">(</span><span class="n">candidates</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">candidates</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="nf">backtrack</span><span class="p">(</span><span class="n">candidates</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
            <span class="n">path</span><span class="mf">.</span><span class="nf">pop_back</span><span class="p">();</span>
            <span class="n">sum</span> <span class="o">-=</span> <span class="n">candidates</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h3 id="40-组合总和-ii"><span class="mr-2">40. 组合总和 II</span><a href="#40-组合总和-ii" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>给定一个候选人编号的集合 <code class="language-plaintext highlighter-rouge">candidates </code>和一个目标数 <code class="language-plaintext highlighter-rouge">target </code>，找出 <code class="language-plaintext highlighter-rouge">candidates</code> 中所有可以使数字和为 <code class="language-plaintext highlighter-rouge">target </code>的组合。<code class="language-plaintext highlighter-rouge">candidates</code> 中的<strong>每个数字在每个组合中只能使用一次 **。注意：</strong>解集不能包含重复的组合**。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="o">:</span> <span class="n">candidates</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="n">target</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
<span class="n">输出</span><span class="o">:</span>
<span class="p">[</span>
	<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span>
	<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span>
	<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">7</span><span class="p">],</span>
	<span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
<span class="p">]</span>
</pre></table></code></div></div><p>本道题中：输入数组有重复元素，每个元素只能使用一次，需要去重。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&gt;</span> <span class="n">res</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span> <span class="n">path</span><span class="p">;</span>
    <span class="n">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&gt;</span> <span class="nf">combinationSum2</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&amp;</span> <span class="n">candidates</span><span class="p">,</span> <span class="n">int</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
        <span class="nb">sort</span><span class="p">(</span><span class="n">candidates</span><span class="mf">.</span><span class="nf">begin</span><span class="p">(),</span> <span class="n">candidates</span><span class="mf">.</span><span class="nb">end</span><span class="p">());</span>
        <span class="nf">backtrack</span><span class="p">(</span><span class="n">candidates</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">void</span> <span class="nf">backtrack</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&amp;</span> <span class="n">candidates</span><span class="p">,</span> <span class="n">int</span> <span class="n">target</span><span class="p">,</span> <span class="n">int</span> <span class="n">start</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="n">sum</span> <span class="o">&gt;</span> <span class="n">target</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">sum</span> <span class="o">==</span> <span class="n">target</span><span class="p">){</span>
            <span class="n">res</span><span class="mf">.</span><span class="nf">push_back</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">for</span><span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">candidates</span><span class="mf">.</span><span class="nf">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="k">if</span><span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="n">start</span> <span class="o">&amp;&amp;</span> <span class="n">candidates</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">candidates</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">continue</span><span class="p">;</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">candidates</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="n">path</span><span class="mf">.</span><span class="nf">push_back</span><span class="p">(</span><span class="n">candidates</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
            <span class="nf">backtrack</span><span class="p">(</span><span class="n">candidates</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
            <span class="n">sum</span> <span class="o">-=</span> <span class="n">candidates</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="n">path</span><span class="mf">.</span><span class="nf">pop_back</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h3 id="216-组合总和-iii"><span class="mr-2">216. 组合总和 III</span><a href="#216-组合总和-iii" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>找出所有相加之和为 <code class="language-plaintext highlighter-rouge">n</code> 的 <code class="language-plaintext highlighter-rouge">k</code> 个数的组合，且满足下列条件：只使用数字1到9，<strong>每个数字最多使用一次</strong>，返回所有可能的有效组合的列表。该列表不能包含相同的组合两次，组合可以以任何顺序返回。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre> <span class="n">输入</span><span class="o">:</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">7</span>
 <span class="n">输出</span><span class="o">:</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">]]</span>
 <span class="n">解释</span><span class="o">:</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">=</span> <span class="mi">7</span><span class="err">，</span><span class="n">没有其他符合的组合了</span><span class="err">。</span>
</pre></table></code></div></div><p>本道题中：输入数组无重复元素，每个元素只能使用一次。当满足<code class="language-plaintext highlighter-rouge">sum == n &amp;&amp; k == path.size()</code>时，<code class="language-plaintext highlighter-rouge">path</code>加入<code class="language-plaintext highlighter-rouge">res</code>。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&gt;</span> <span class="n">res</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span> <span class="n">path</span><span class="p">;</span>
    <span class="n">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&gt;</span> <span class="nf">combinationSum3</span><span class="p">(</span><span class="n">int</span> <span class="n">k</span><span class="p">,</span> <span class="n">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">backtrack</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">void</span> <span class="nf">backtrack</span><span class="p">(</span><span class="n">int</span> <span class="n">k</span><span class="p">,</span> <span class="n">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">int</span> <span class="n">start</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="n">sum</span> <span class="o">&gt;</span> <span class="n">n</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">sum</span> <span class="o">==</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">k</span> <span class="o">==</span> <span class="n">path</span><span class="mf">.</span><span class="nf">size</span><span class="p">()){</span>
            <span class="n">res</span><span class="mf">.</span><span class="nf">push_back</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">for</span><span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">9</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">i</span><span class="p">;</span>
            <span class="n">path</span><span class="mf">.</span><span class="nf">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
            <span class="nf">backtrack</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
            <span class="n">sum</span> <span class="o">-=</span> <span class="n">i</span><span class="p">;</span>
            <span class="n">path</span><span class="mf">.</span><span class="nf">pop_back</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>  
<span class="p">};</span>
</pre></table></code></div></div><h3 id="46-全排列"><span class="mr-2">46. 全排列</span><a href="#46-全排列" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>给定一个<strong>不含重复数字</strong>的数组 <code class="language-plaintext highlighter-rouge">nums</code>，返回其所有可能的全排列，你可以按任意顺序返回答案。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">nums</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="n">输出</span><span class="err">：</span><span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span>
</pre></table></code></div></div><p>排列问题就是穷举元素，nums[i] 之后也可以出现 nums[i] 左边的元素，所以之前的那一套玩不转了，需要额外使用 <code class="language-plaintext highlighter-rouge">used</code> 数组来标记哪些元素还可以被选择。</p><div align="center"><img data-src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202206121430486.png" alt="image-20220612143008374" style="zoom:70%;" data-proofer-ignore></div><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&gt;</span> <span class="n">res</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span> <span class="n">path</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&gt;</span> <span class="nf">permute</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">bool</span><span class="o">&gt;</span> <span class="nf">used</span><span class="p">(</span><span class="n">nums</span><span class="mf">.</span><span class="nf">size</span><span class="p">(),</span> <span class="kc">false</span><span class="p">);</span>
        <span class="nf">backtrack</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">used</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">void</span> <span class="nf">backtrack</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">bool</span><span class="o">&gt;&amp;</span> <span class="n">used</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="n">path</span><span class="mf">.</span><span class="nf">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">nums</span><span class="mf">.</span><span class="nf">size</span><span class="p">()){</span>
            <span class="n">res</span><span class="mf">.</span><span class="nf">push_back</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">for</span><span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="mf">.</span><span class="nf">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="c1">// path里已经收录的元素，直接跳过</span>
            <span class="k">if</span><span class="p">(</span><span class="n">used</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">continue</span><span class="p">;</span>
            <span class="n">path</span><span class="mf">.</span><span class="nf">push_back</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
            <span class="n">used</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
            <span class="nf">backtrack</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">used</span><span class="p">);</span>
            <span class="n">path</span><span class="mf">.</span><span class="nf">pop_back</span><span class="p">();</span>
            <span class="n">used</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><p>path里已经收录的元素，直接跳过：</p><div align="center"><img data-src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202206121449434.png" alt="image-20220612144916318" style="zoom:80%;" data-proofer-ignore></div><h3 id="47-全排列-ii"><span class="mr-2">47. 全排列 II</span><a href="#47-全排列-ii" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>给定一个可包含重复数字的序列 <code class="language-plaintext highlighter-rouge">nums</code> ，按任意顺序返回所有<strong>不重复</strong>的全排列。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">nums</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="n">输出</span><span class="err">：</span>
<span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span>
 <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
 <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">nums</code> 数组当中包含重复的元素，如何去掉重复的全排列呢？<strong>保证相同元素在排列中的相对位置保持不变即可</strong>。首先对 <code class="language-plaintext highlighter-rouge">nums </code>进行排序，然后添加了一句额外的剪枝逻辑。</p><p>那么反映到代码上，剪枝逻辑如下：</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="c1">// 新添加的剪枝逻辑，固定相同的元素在排列中的相对位置</span>
<span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">used</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">])</span> <span class="o">{</span>
    <span class="c1">// 如果前面的相邻相等元素没有用过，则跳过</span>
    <span class="k">continue</span><span class="o">;</span>
<span class="o">}</span>
<span class="c1">// 选择 nums[i]</span>
</pre></table></code></div></div><p>当出现重复元素时，比如输入 <code class="language-plaintext highlighter-rouge">nums = [1,2,2',2'']</code>，<code class="language-plaintext highlighter-rouge">2'</code> 只有在 <code class="language-plaintext highlighter-rouge">2</code> 已经被使用的情况下才会被选择，同理，<code class="language-plaintext highlighter-rouge">2''</code> 只有在 <code class="language-plaintext highlighter-rouge">2'</code> 已经被使用的情况下才会被选择，这就保证了相同元素在排列中的相对位置保证固定。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&gt;</span> <span class="n">res</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span> <span class="n">path</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&gt;</span> <span class="nf">permuteUnique</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
        <span class="nb">sort</span><span class="p">(</span><span class="n">nums</span><span class="mf">.</span><span class="nf">begin</span><span class="p">(),</span> <span class="n">nums</span><span class="mf">.</span><span class="nb">end</span><span class="p">());</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">bool</span><span class="o">&gt;</span> <span class="nf">used</span><span class="p">(</span><span class="n">nums</span><span class="mf">.</span><span class="nf">size</span><span class="p">(),</span> <span class="kc">false</span><span class="p">);</span>
        <span class="nf">backtrack</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">used</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">void</span> <span class="nf">backtrack</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">bool</span><span class="o">&gt;&amp;</span> <span class="n">used</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="n">path</span><span class="mf">.</span><span class="nf">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">nums</span><span class="mf">.</span><span class="nf">size</span><span class="p">()){</span>
            <span class="n">res</span><span class="mf">.</span><span class="nf">push_back</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">for</span><span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="mf">.</span><span class="nf">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="k">if</span><span class="p">(</span><span class="n">used</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">continue</span><span class="p">;</span>
            <span class="k">if</span><span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">used</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]){</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">path</span><span class="mf">.</span><span class="nf">push_back</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
            <span class="n">used</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
            <span class="nf">backtrack</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">used</span><span class="p">);</span>
            <span class="n">path</span><span class="mf">.</span><span class="nf">pop_back</span><span class="p">();</span>
            <span class="n">used</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h3 id="491-递增子序列"><span class="mr-2">491. 递增子序列</span><a href="#491-递增子序列" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>给你一个整数数组 <code class="language-plaintext highlighter-rouge">nums </code>，找出并返回所有该数组中不同的递增子序列，递增子序列中至少有两个元素 。你可以按任意顺序返回答案。数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">nums</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span>
<span class="n">输出</span><span class="err">：</span><span class="p">[[</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">7</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">7</span><span class="p">],[</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">],[</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">7</span><span class="p">],[</span><span class="mi">7</span><span class="p">,</span><span class="mi">7</span><span class="p">]]</span>
</pre></table></code></div></div><p>本题求自增子序列，是不能对原数组经行排序的，排完序的数组都是自增子序列了，所以不能使用之前的去重逻辑！使用<code class="language-plaintext highlighter-rouge">unordered_set&lt;int&gt;</code>来记录本层元素是否重复使用。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&gt;</span> <span class="n">result</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span> <span class="n">path</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&gt;</span> <span class="nf">findSubsequences</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">backtracking</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">void</span> <span class="nf">backtracking</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="n">int</span> <span class="n">startIndex</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="mf">.</span><span class="nf">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">result</span><span class="mf">.</span><span class="nf">push_back</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
            <span class="c1">// 注意这里不要加return，要取树上的节点</span>
        <span class="p">}</span>
        <span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span> <span class="n">uset</span><span class="p">;</span> <span class="c1">// 使用set对本层元素进行去重</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">startIndex</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="mf">.</span><span class="nf">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">path</span><span class="mf">.</span><span class="nb">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">path</span><span class="mf">.</span><span class="nf">back</span><span class="p">())</span> <span class="o">||</span> <span class="n">uset</span><span class="mf">.</span><span class="nb">count</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="p">{</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">uset</span><span class="mf">.</span><span class="nf">insert</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span> <span class="c1">// 记录这个元素在本层用过了，本层后面不能再用了</span>
            <span class="n">path</span><span class="mf">.</span><span class="nf">push_back</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
            <span class="nf">backtracking</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
            <span class="n">path</span><span class="mf">.</span><span class="nf">pop_back</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">};</span>

</pre></table></code></div></div><p>用数组来做哈希，效率就高了很多。注意题目中说了，数值范围[-100,100]，所以完全可以用数组来做哈希。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&gt;</span> <span class="n">result</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span> <span class="n">path</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&gt;</span> <span class="nf">findSubsequences</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">backtracking</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">void</span> <span class="nf">backtracking</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="n">int</span> <span class="n">startIndex</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="mf">.</span><span class="nf">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">result</span><span class="mf">.</span><span class="nf">push_back</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">int</span> <span class="n">used</span><span class="p">[</span><span class="mi">201</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span> <span class="c1">// 这里使用数组来进行去重操作，题目说数值范围[-100, 100]</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">startIndex</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="mf">.</span><span class="nf">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">path</span><span class="mf">.</span><span class="nb">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">path</span><span class="mf">.</span><span class="nf">back</span><span class="p">())</span> <span class="o">||</span> <span class="n">used</span><span class="p">[</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">100</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">used</span><span class="p">[</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">100</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 记录这个元素在本层用过了，本层后面不能再用了</span>
            <span class="n">path</span><span class="mf">.</span><span class="nf">push_back</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
            <span class="nf">backtracking</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
            <span class="n">path</span><span class="mf">.</span><span class="nf">pop_back</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h2 id="切割问题"><span class="mr-2">切割问题</span><a href="#切割问题" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="131-分割回文串"><span class="mr-2">131. 分割回文串</span><a href="#131-分割回文串" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是 回文串 ，返回 s 所有可能的分割方案。回文串是正着读和反着读都一样的字符串。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">s</span> <span class="o">=</span> <span class="s2">"aab"</span>
<span class="n">输出</span><span class="err">：</span><span class="p">[[</span><span class="s2">"a"</span><span class="p">,</span><span class="s2">"a"</span><span class="p">,</span><span class="s2">"b"</span><span class="p">],[</span><span class="s2">"aa"</span><span class="p">,</span><span class="s2">"b"</span><span class="p">]]</span>
</pre></table></code></div></div><p>本题要思考如下问题：</p><ul><li>切割问题可以抽象为组合问题<li>如何模拟那些切割线<li>切割问题中递归如何终止<li>在递归循环中如何截取子串<li>如何判断回文</ul><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&gt;</span> <span class="n">result</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">path</span><span class="p">;</span> <span class="c1">// 放已经回文的子串</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&gt;</span> <span class="nf">partition</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">backtracking</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">void</span> <span class="nf">backtracking</span> <span class="p">(</span><span class="k">const</span> <span class="no">string</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">,</span> <span class="n">int</span> <span class="n">startIndex</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 如果起始位置已经大于s的大小，说明已经找到了一组分割方案了</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">startIndex</span> <span class="o">&gt;=</span> <span class="n">s</span><span class="mf">.</span><span class="nf">size</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">result</span><span class="mf">.</span><span class="nf">push_back</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">startIndex</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="mf">.</span><span class="nf">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="nf">isPalindrome</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">startIndex</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span> <span class="k">continue</span><span class="p">;</span>
            <span class="n">string</span> <span class="n">str</span> <span class="o">=</span> <span class="n">s</span><span class="mf">.</span><span class="nb">substr</span><span class="p">(</span><span class="n">startIndex</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="n">startIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
            <span class="n">path</span><span class="mf">.</span><span class="nf">push_back</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
            <span class="nf">backtracking</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// 寻找i + 1为起始位置的子串</span>
            <span class="n">path</span><span class="mf">.</span><span class="nf">pop_back</span><span class="p">();</span>        <span class="c1">// 回溯过程，弹出本次已经填在的子串</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">bool</span> <span class="nf">isPalindrome</span><span class="p">(</span><span class="k">const</span> <span class="no">string</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">,</span> <span class="n">int</span> <span class="n">start</span><span class="p">,</span> <span class="n">int</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">start</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">j</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="p">{</span>
                <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h3 id="93-复原-ip-地址"><span class="mr-2">93. 复原 IP 地址</span><a href="#93-复原-ip-地址" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。例如：”0.1.2.201” 和 “192.168.1.1” 是 有效 IP 地址，但是 “0.011.255.245”、”192.168.1.312” 和 “192.168@1.1” 是 无效 IP 地址。</p><p>给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的有效 IP 地址，这些地址可以通过在 s 中插入 ‘.’ 来形成。你不能重新排序或删除 s 中的任何数字。你可以按任何顺序返回答案。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">s</span> <span class="o">=</span> <span class="s2">"25525511135"</span>
<span class="n">输出</span><span class="err">：</span><span class="p">[</span><span class="s2">"255.255.11.135"</span><span class="p">,</span><span class="s2">"255.255.111.35"</span><span class="p">]</span>
</pre></table></code></div></div><p>在131.分割回文串中我列举的分割字符串的难点，本题都覆盖了。而且本题还需要操作字符串添加逗号作为分隔符，并验证区间的合法性。可以说是131.分割回文串的加强版。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">result</span><span class="p">;</span><span class="c1">// 记录结果</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="nf">restoreIpAddresses</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">backtracking</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// startIndex: 搜索的起始位置，pointNum:添加逗点的数量</span>
    <span class="n">void</span> <span class="nf">backtracking</span><span class="p">(</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">,</span> <span class="n">int</span> <span class="n">startIndex</span><span class="p">,</span> <span class="n">int</span> <span class="n">pointNum</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">pointNum</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 逗点数量为3时，分隔结束</span>
            <span class="c1">// 判断第四段子字符串是否合法，如果合法就放进result中</span>
            <span class="k">if</span> <span class="p">(</span><span class="nf">isValid</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">startIndex</span><span class="p">,</span> <span class="n">s</span><span class="mf">.</span><span class="nf">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">result</span><span class="mf">.</span><span class="nf">push_back</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">startIndex</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="mf">.</span><span class="nf">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nf">isValid</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">startIndex</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span> <span class="k">continue</span><span class="p">;</span>        <span class="c1">// 判断 [startIndex,i] 这个区间的子串是否合法</span>
			<span class="n">s</span><span class="mf">.</span><span class="nf">insert</span><span class="p">(</span><span class="n">s</span><span class="mf">.</span><span class="nf">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">,</span> <span class="s1">'.'</span><span class="p">);</span>  <span class="c1">// 在i的后面插入一个逗点</span>
			<span class="n">pointNum</span><span class="o">++</span><span class="p">;</span>
			<span class="nf">backtracking</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">pointNum</span><span class="p">);</span>   <span class="c1">// 插入逗点之后下一个子串的起始位置为i + 2</span>
			<span class="n">pointNum</span><span class="o">--</span><span class="p">;</span>                         <span class="c1">// 回溯</span>
			<span class="n">s</span><span class="mf">.</span><span class="nf">erase</span><span class="p">(</span><span class="n">s</span><span class="mf">.</span><span class="nf">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>         <span class="c1">// 回溯删掉逗点</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="c1">// 判断字符串s在左闭又闭区间[start, end]所组成的数字是否合法</span>
    <span class="n">bool</span> <span class="nf">isValid</span><span class="p">(</span><span class="k">const</span> <span class="no">string</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">,</span> <span class="n">int</span> <span class="n">start</span><span class="p">,</span> <span class="n">int</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&gt;</span> <span class="n">end</span><span class="p">)</span> <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">==</span> <span class="s1">'0'</span> <span class="o">&amp;&amp;</span> <span class="n">start</span> <span class="o">!=</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 0开头的数字不合法</span>
            <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="s1">'9'</span> <span class="o">||</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="s1">'0'</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 遇到非数字字符不合法</span>
                <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">num</span> <span class="o">=</span> <span class="n">num</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">+</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="s1">'0'</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">num</span> <span class="o">&gt;</span> <span class="mi">255</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 如果大于255了不合法</span>
                <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h3 id="468-验证ip地址"><span class="mr-2">468. 验证IP地址</span><a href="#468-验证ip地址" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>给定一个字符串 <code class="language-plaintext highlighter-rouge">queryIP</code>。如果是有效的 IPv4 地址，返回 “IPv4” ；如果是有效的 IPv6 地址，返回 “IPv6” ；如果不是上述类型的 IP 地址，返回 “Neither” 。</p><p>有效的IPv4地址 是 “<code class="language-plaintext highlighter-rouge">x1.x2.x3.x4</code>” 形式的IP地址。 其中 0 &lt;= xi &lt;= 255 且 xi 不能包含前导零。例如: “192.168.1.1” 、 “192.168.1.0” 为有效IPv4地址， “192.168.01.1” 为无效IPv4地址; “192.168.1.00” 、 “192.168@1.1” 为无效IPv4地址。</p><p>一个有效的IPv6地址 是一个格式为“x1:x2:x3:x4:x5:x6:x7:x8” 的IP地址，其中: 1 &lt;= xi.length &lt;= 4；xi 是一个 十六进制字符串 ，可以包含数字、小写英文字母( ‘a’ 到 ‘f’ )和大写英文字母( ‘A’ 到 ‘F’ )；在 xi 中允许前导零。</p><p>例如 “2001:0db8:85a3:0000:0000:8a2e:0370:7334” 和 “2001:db8:85a3:0:0:8A2E:0370:7334” 是有效的 IPv6 地址，而 “2001:0db8:85a3::8A2E:037j:7334” 和 “02001:0db8:85a3:0000:0000:8a2e:0370:7334” 是无效的 IPv6 地址。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">queryIP</span> <span class="o">=</span> <span class="s2">"172.16.254.1"</span>
<span class="n">输出</span><span class="err">：</span><span class="s2">"IPv4"</span>
<span class="n">解释</span><span class="err">：</span><span class="n">有效的</span> <span class="nc">IPv4</span> <span class="n">地址</span><span class="err">，</span><span class="n">返回</span> <span class="s2">"IPv4"</span>
</pre></table></code></div></div><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">string</span> <span class="nf">validIPAddress</span><span class="p">(</span><span class="n">string</span> <span class="n">queryIP</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">queryIP</span><span class="mf">.</span><span class="nb">empty</span><span class="p">())</span> <span class="k">return</span> <span class="s2">"Neither"</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="nf">isIPv4</span><span class="p">(</span><span class="n">queryIP</span><span class="p">))</span> <span class="k">return</span> <span class="s2">"IPv4"</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="nf">isIPv6</span><span class="p">(</span><span class="n">queryIP</span><span class="p">))</span> <span class="k">return</span> <span class="s2">"IPv6"</span><span class="p">;</span>
        <span class="k">return</span> <span class="s2">"Neither"</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">//将字符串从.或者:分割开</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="nb">split</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">,</span> <span class="n">string</span> <span class="n">spliter</span><span class="p">)</span> <span class="p">{</span>  
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">;</span>
        <span class="n">int</span> <span class="n">i</span><span class="p">;</span>
        <span class="c1">//遍历字符串查找spliter</span>
        <span class="k">while</span><span class="p">((</span><span class="n">i</span> <span class="o">=</span> <span class="n">s</span><span class="mf">.</span><span class="nf">find</span><span class="p">(</span><span class="n">spliter</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">s</span><span class="mf">.</span><span class="n">npos</span><span class="p">){</span>  
            <span class="c1">//将分割的部分加入vector中</span>
            <span class="n">res</span><span class="mf">.</span><span class="nf">push_back</span><span class="p">(</span><span class="n">s</span><span class="mf">.</span><span class="nb">substr</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">));</span>  
            <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="mf">.</span><span class="nb">substr</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">res</span><span class="mf">.</span><span class="nf">push_back</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">bool</span> <span class="nf">isIPv4</span> <span class="p">(</span><span class="n">string</span> <span class="no">IP</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">s</span> <span class="o">=</span> <span class="nb">split</span><span class="p">(</span><span class="no">IP</span><span class="p">,</span> <span class="s2">"."</span><span class="p">);</span>  
        <span class="k">if</span><span class="p">(</span><span class="n">s</span><span class="mf">.</span><span class="nf">size</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">)</span> <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="mf">.</span><span class="nf">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="k">if</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="mf">.</span><span class="nf">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="mf">.</span><span class="nf">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">){</span>
                <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">if</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">'0'</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="mf">.</span><span class="nf">size</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">){</span>
                <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">for</span><span class="p">(</span><span class="n">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="mf">.</span><span class="nf">size</span><span class="p">();</span> <span class="n">j</span><span class="o">++</span><span class="p">){</span>
                <span class="k">if</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="s1">'0'</span> <span class="o">||</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="s1">'9'</span><span class="p">){</span>
                    <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="n">int</span> <span class="n">num</span> <span class="o">=</span> <span class="nf">stoi</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
            <span class="k">if</span><span class="p">(</span><span class="n">num</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">num</span> <span class="o">&gt;</span> <span class="mi">255</span><span class="p">){</span>
                <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
<span class="p">}</span>

    <span class="n">bool</span> <span class="nf">isIPv6</span> <span class="p">(</span><span class="n">string</span> <span class="no">IP</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">s</span> <span class="o">=</span> <span class="nb">split</span><span class="p">(</span><span class="no">IP</span><span class="p">,</span> <span class="s2">":"</span><span class="p">);</span>
        <span class="c1">//IPv6必定为8组</span>
        <span class="k">if</span><span class="p">(</span><span class="n">s</span><span class="mf">.</span><span class="nf">size</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">8</span><span class="p">)</span> <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="mf">.</span><span class="nf">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span> 
            <span class="c1">//每个分割不能缺省，不能超过4位</span>
            <span class="k">if</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="mf">.</span><span class="nf">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="mf">.</span><span class="nf">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">){</span>
                <span class="k">return</span> <span class="kc">false</span><span class="p">;</span> 
            <span class="p">}</span>
            <span class="k">for</span><span class="p">(</span><span class="n">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="mf">.</span><span class="nf">size</span><span class="p">();</span> <span class="n">j</span><span class="o">++</span><span class="p">){</span>
                <span class="c1">//不能出现a-f A-F 0-9以外的字符</span>
                <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="p">((</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="s1">'0'</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="s1">'9'</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="s1">'a'</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="s1">'f'</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="s1">'A'</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="s1">'F'</span><span class="p">))){</span>
                    <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
    <span class="p">}</span>

<span class="p">}</span>
</pre></table></code></div></div><h2 id="岛屿问题"><span class="mr-2">岛屿问题</span><a href="#岛屿问题" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>岛屿系列题目的核心考点就是用 DFS/BFS 算法<strong>遍历二维数组</strong>。</p><h3 id="200-岛屿数量"><span class="mr-2">200. 岛屿数量</span><a href="#200-岛屿数量" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。此外，你可以假设该网格的四条边均被水包围。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre> <span class="n">输入</span><span class="err">：</span><span class="n">grid</span> <span class="o">=</span> <span class="p">[</span>
   <span class="p">[</span><span class="s2">"1"</span><span class="p">,</span><span class="s2">"1"</span><span class="p">,</span><span class="s2">"1"</span><span class="p">,</span><span class="s2">"1"</span><span class="p">,</span><span class="s2">"0"</span><span class="p">],</span>
   <span class="p">[</span><span class="s2">"1"</span><span class="p">,</span><span class="s2">"1"</span><span class="p">,</span><span class="s2">"0"</span><span class="p">,</span><span class="s2">"1"</span><span class="p">,</span><span class="s2">"0"</span><span class="p">],</span>
   <span class="p">[</span><span class="s2">"1"</span><span class="p">,</span><span class="s2">"1"</span><span class="p">,</span><span class="s2">"0"</span><span class="p">,</span><span class="s2">"0"</span><span class="p">,</span><span class="s2">"0"</span><span class="p">],</span>
   <span class="p">[</span><span class="s2">"0"</span><span class="p">,</span><span class="s2">"0"</span><span class="p">,</span><span class="s2">"0"</span><span class="p">,</span><span class="s2">"0"</span><span class="p">,</span><span class="s2">"0"</span><span class="p">]</span>
 <span class="p">]</span>
 <span class="n">输出</span><span class="err">：</span><span class="mi">1</span>
</pre></table></code></div></div><p>用 DFS 算法解决岛屿题目是最常见的，每次遇到一个岛屿中的陆地，就用 DFS 算法吧这个岛屿「淹掉」。</p><p>如何使用 DFS 算法遍历二维数组？把二维数组中的每个格子看做「图」中的一个节点，这个节点和周围的四个节点连通，这样二维矩阵就被抽象成了一幅网状的「图」。</p><p>为什么每次遇到岛屿，都要用 DFS 算法把岛屿「淹了」呢？主要是为了省事，避免维护 <code class="language-plaintext highlighter-rouge">visited</code> 数组。遍历图是需要 <code class="language-plaintext highlighter-rouge">visited</code> 数组记录遍历过的节点防止走回头路。因为 <code class="language-plaintext highlighter-rouge">dfs</code> 函数遍历到值为 <code class="language-plaintext highlighter-rouge">0</code> 的位置会直接返回，所以只要把经过的位置都设置为 <code class="language-plaintext highlighter-rouge">0</code>，就可以起到不走回头路的作用。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">int</span> <span class="nf">numIslands</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">char</span><span class="o">&gt;&gt;&amp;</span> <span class="n">grid</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">grid</span><span class="mf">.</span><span class="nf">size</span><span class="p">(),</span> <span class="n">n</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="mf">.</span><span class="nf">size</span><span class="p">();</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="s1">'1'</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">count</span><span class="o">++</span><span class="p">;</span>            <span class="c1">// 每发现一个岛屿，岛屿数量加一</span>
                    <span class="nf">dfs</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>    <span class="c1">// 然后使用 DFS 将岛屿淹了</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">count</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 从 (i, j) 开始，将与之相邻的陆地都变成海水</span>
    <span class="n">void</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">char</span><span class="o">&gt;&gt;&amp;</span> <span class="n">grid</span><span class="p">,</span> <span class="n">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">int</span> <span class="n">j</span><span class="p">){</span>
        <span class="n">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">grid</span><span class="mf">.</span><span class="nf">size</span><span class="p">(),</span> <span class="n">n</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="mf">.</span><span class="nf">size</span><span class="p">();</span>
        <span class="k">if</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">m</span> <span class="o">||</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="s1">'0'</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
        <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="s1">'0'</span><span class="p">;</span>
        <span class="nf">dfs</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
        <span class="nf">dfs</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="nf">dfs</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
        <span class="nf">dfs</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h3 id="1254-统计封闭岛屿的数目"><span class="mr-2">1254. 统计封闭岛屿的数目</span><a href="#1254-统计封闭岛屿的数目" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>二维矩阵 grid 由 0 （土地）和 1 （水）组成。岛是由最大的4个方向连通的 0 组成的群，封闭岛是一个 <strong>完全 由1包围</strong>（左、上、右、下）的岛，请返回 封闭岛屿 的数目。</p><div align="center"><img data-src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202206141112335.png" alt="img" style="zoom:80%;" data-proofer-ignore></div><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">grid</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]]</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">2</span>
<span class="n">解释</span><span class="err">：</span><span class="n">灰色区域的岛屿是封闭岛屿</span><span class="err">，</span><span class="n">因为这座岛屿完全被水域包围</span><span class="err">（</span><span class="n">即被</span> <span class="mi">1</span> <span class="n">区域包围</span><span class="err">）。</span>
</pre></table></code></div></div><p>和上一题有两点不同：</p><ol><li><p>用 <code class="language-plaintext highlighter-rouge">0</code> 表示陆地，用 <code class="language-plaintext highlighter-rouge">1</code> 表示海水。</p><li><p>让你计算「封闭岛屿」的数目。所谓「封闭岛屿」就是上下左右全部被 <code class="language-plaintext highlighter-rouge">1</code> 包围的 <code class="language-plaintext highlighter-rouge">0</code>，也就是说<strong>靠边的陆地不算作「封闭岛屿」</strong>。</p></ol><p>那么如何判断「封闭岛屿」呢？把上一题中那些靠边的岛屿排除掉，剩下的就是「封闭岛屿」。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">int</span> <span class="nf">closedIsland</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">grid</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">grid</span><span class="mf">.</span><span class="nf">size</span><span class="p">(),</span> <span class="n">n</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="mf">.</span><span class="nf">size</span><span class="p">();</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="nf">dfs</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>        <span class="c1">// 把靠上边的岛屿淹掉</span>
            <span class="nf">dfs</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>    <span class="c1">// 把靠下边的岛屿淹掉</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="nf">dfs</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>        <span class="c1">// 把靠左边的岛屿淹掉</span>
            <span class="nf">dfs</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>    <span class="c1">// 把靠右边的岛屿淹掉</span>
        <span class="p">}</span>
        <span class="c1">// 遍历 grid，剩下的岛屿都是封闭岛屿</span>
        <span class="n">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">count</span><span class="o">++</span><span class="p">;</span>            <span class="c1">// 每发现一个岛屿，岛屿数量加一</span>
                    <span class="nf">dfs</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>    <span class="c1">// 然后使用 DFS 将岛屿淹了</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">count</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 从 (i, j) 开始，将与之相邻的陆地都变成海水</span>
    <span class="n">void</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">grid</span><span class="p">,</span> <span class="n">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">int</span> <span class="n">j</span><span class="p">){</span>
        <span class="n">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">grid</span><span class="mf">.</span><span class="nf">size</span><span class="p">(),</span> <span class="n">n</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="mf">.</span><span class="nf">size</span><span class="p">();</span>
        <span class="k">if</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">m</span> <span class="o">||</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
        <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="nf">dfs</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
        <span class="nf">dfs</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="nf">dfs</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
        <span class="nf">dfs</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h3 id="1020-飞地的数量"><span class="mr-2">1020. 飞地的数量</span><a href="#1020-飞地的数量" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>给你一个大小为 m x n 的二进制矩阵 <code class="language-plaintext highlighter-rouge">grid </code>，其中 0 表示一个海洋单元格、1 表示一个陆地单元格。一次 <strong>移动 **是指从一个陆地单元格走到另一个相邻（上、下、左、右）的陆地单元格或跨过 grid 的边界。返回网格中</strong>无法**在任意次数的移动中离开网格边界的陆地单元格的数量。</p><div align="center"><img data-src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202206141123972.jpeg" alt="img" style="zoom:50%;" data-proofer-ignore></div><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre> <span class="n">输入</span><span class="err">：</span><span class="n">grid</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]]</span>
 <span class="n">输出</span><span class="err">：</span><span class="mi">3</span>
 <span class="n">解释</span><span class="err">：</span><span class="n">有三个</span> <span class="mi">1</span> <span class="n">被</span> <span class="mi">0</span> <span class="n">包围</span><span class="err">。</span><span class="n">一个</span> <span class="mi">1</span> <span class="n">没有被包围</span><span class="err">，</span><span class="n">因为它在边界上</span><span class="err">。</span>
</pre></table></code></div></div><p>这题不求封闭岛屿的数量，而是求封闭岛屿的面积总和，本质上和上一题是一样的。思路都是一样的，先把靠边的陆地淹掉，然后去数剩下的陆地数量。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">int</span> <span class="nf">numEnclaves</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">grid</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">grid</span><span class="mf">.</span><span class="nf">size</span><span class="p">(),</span> <span class="n">n</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="mf">.</span><span class="nf">size</span><span class="p">();</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="nf">dfs</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>        <span class="c1">// 把靠上边的岛屿淹掉</span>
            <span class="nf">dfs</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>    <span class="c1">// 把靠下边的岛屿淹掉</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="nf">dfs</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>        <span class="c1">// 把靠左边的岛屿淹掉</span>
            <span class="nf">dfs</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>    <span class="c1">// 把靠右边的岛屿淹掉</span>
        <span class="p">}</span>
        <span class="c1">// 遍历 grid，剩下的岛屿都是封闭岛屿</span>
        <span class="n">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">count</span><span class="o">++</span><span class="p">;</span>            <span class="c1">// 每发现一个岛屿，岛屿数量加一</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">count</span><span class="p">;</span>

    <span class="p">}</span>

    <span class="c1">// 从 (i, j) 开始，将与之相邻的陆地都变成海水</span>
    <span class="n">void</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">grid</span><span class="p">,</span> <span class="n">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">int</span> <span class="n">j</span><span class="p">){</span>
        <span class="n">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">grid</span><span class="mf">.</span><span class="nf">size</span><span class="p">(),</span> <span class="n">n</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="mf">.</span><span class="nf">size</span><span class="p">();</span>
        <span class="k">if</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">m</span> <span class="o">||</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
        <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="nf">dfs</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
        <span class="nf">dfs</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="nf">dfs</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
        <span class="nf">dfs</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h3 id="695-岛屿的最大面积"><span class="mr-2">695. 岛屿的最大面积</span><a href="#695-岛屿的最大面积" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>给你一个大小为 m x n 的二进制矩阵 grid 。岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在 水平或者竖直的四个方向上 相邻。你可以假设<strong>grid 的四个边缘都被 0（代表水）包围着</strong>。岛屿的面积是岛上值为 1 的单元格的数目。计算并返回 grid 中最大的岛屿面积。如果没有岛屿，则返回面积为 0 。</p><div align="center"><img data-src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202206141131954.jpeg" alt="img" style="zoom:40%;" data-proofer-ignore></div><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">grid</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]]</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">6</span>
<span class="n">解释</span><span class="err">：</span><span class="n">答案不应该是</span> <span class="mi">11</span> <span class="err">，</span><span class="n">因为岛屿只能包含水平或垂直这四个方向上的</span> <span class="mi">1</span> <span class="err">。</span>
</pre></table></code></div></div><p>这题的大体思路和之前完全一样，只不过 <code class="language-plaintext highlighter-rouge">dfs</code> 函数淹没岛屿的同时，还应该想办法记录这个岛屿的面积。可以给 <code class="language-plaintext highlighter-rouge">dfs</code> 函数设置返回值，记录每次淹没的陆地的个数。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">int</span> <span class="nf">maxAreaOfIsland</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">grid</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">grid</span><span class="mf">.</span><span class="nf">size</span><span class="p">(),</span> <span class="n">n</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="mf">.</span><span class="nf">size</span><span class="p">();</span>
        <span class="n">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                    <span class="c1">// 淹没岛屿，并更新最大岛屿面积</span>
                    <span class="n">count</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">));</span>  
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">count</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 淹没与 (i, j) 相邻的陆地，并返回淹没的陆地面积</span>
    <span class="n">int</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">grid</span><span class="p">,</span> <span class="n">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">int</span> <span class="n">j</span><span class="p">){</span>
        <span class="n">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">grid</span><span class="mf">.</span><span class="nf">size</span><span class="p">(),</span> <span class="n">n</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="mf">.</span><span class="nf">size</span><span class="p">();</span>
        <span class="k">if</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">m</span> <span class="o">||</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">return</span> 
        <span class="nf">dfs</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="o">+</span>
        <span class="nf">dfs</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span>
        <span class="nf">dfs</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="o">+</span>
        <span class="nf">dfs</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h3 id="1905-统计子岛屿"><span class="mr-2">1905. 统计子岛屿</span><a href="#1905-统计子岛屿" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>给你两个 m x n 的二进制矩阵 grid1 和 grid2 ，它们只包含 0 （表示水域）和 1 （表示陆地）。一个 岛屿 是由 四个方向 （水平或者竖直）上相邻的 1 组成的区域。<strong>任何矩阵以外的区域都视为水域</strong>。如果 grid2 的一个岛屿，被 grid1 的一个岛屿 完全 包含，也就是说 grid2 中该岛屿的每一个格子都被 grid1 中同一个岛屿完全包含，那么我们称 grid2 中的这个岛屿为 子岛屿 。请你返回 grid2 中子岛屿的数目。</p><div align="center"><img data-src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202206141253750.png" style="zoom:80%;" data-proofer-ignore></div><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">grid1</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]],</span> 
<span class="n">grid2</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]]</span>
<span class="n">输出</span><span class="err">：</span><span class="mi">3</span>
<span class="n">解释</span><span class="err">：</span><span class="n">如上图所示</span><span class="err">，</span><span class="n">左边为</span> <span class="n">grid1</span> <span class="err">，</span><span class="n">右边为</span> <span class="n">grid2</span><span class="err">。</span><span class="n">grid2</span> <span class="n">中标红的</span> <span class="mi">1</span> <span class="n">区域是子岛屿</span><span class="err">，</span><span class="n">总共有</span> <span class="mi">3</span> <span class="n">个子岛屿</span><span class="err">。</span>
</pre></table></code></div></div><p>什么情况下 <code class="language-plaintext highlighter-rouge">grid2</code> 中的一个岛屿 <code class="language-plaintext highlighter-rouge">B</code> 是 <code class="language-plaintext highlighter-rouge">grid1</code> 中的一个岛屿 <code class="language-plaintext highlighter-rouge">A</code> 的子岛？当岛屿 <code class="language-plaintext highlighter-rouge">B</code> 中所有陆地在岛屿 <code class="language-plaintext highlighter-rouge">A</code> 中也是陆地的时候，岛屿 <code class="language-plaintext highlighter-rouge">B</code> 是岛屿 <code class="language-plaintext highlighter-rouge">A</code> 的子岛。<strong>反过来说，如果岛屿 <code class="language-plaintext highlighter-rouge">B</code> 中存在一片陆地，在岛屿 <code class="language-plaintext highlighter-rouge">A</code> 的对应位置是海水，那么岛屿 <code class="language-plaintext highlighter-rouge">B</code> 就不是岛屿 <code class="language-plaintext highlighter-rouge">A</code> 的子岛</strong>。那么，我们只要遍历 <code class="language-plaintext highlighter-rouge">grid2</code> 中的所有岛屿，把那些不可能是子岛的岛屿排除掉，剩下的就是子岛。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">int</span> <span class="nf">countSubIslands</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">grid1</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">grid2</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">grid1</span><span class="mf">.</span><span class="nf">size</span><span class="p">(),</span> <span class="n">n</span> <span class="o">=</span> <span class="n">grid1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="mf">.</span><span class="nf">size</span><span class="p">();</span>
        <span class="k">for</span><span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="k">for</span><span class="p">(</span><span class="n">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">){</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">grid1</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">grid2</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                    <span class="c1">// 这个岛屿肯定不是子岛，淹掉</span>
                    <span class="nf">dfs</span><span class="p">(</span><span class="n">grid2</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="c1">// 现在 grid2 中剩下的岛屿都是子岛，计算岛屿数量</span>
        <span class="n">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">grid2</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">res</span><span class="o">++</span><span class="p">;</span>
                    <span class="nf">dfs</span><span class="p">(</span><span class="n">grid2</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 从 (i, j) 开始，将与之相邻的陆地都变成海水</span>
    <span class="n">void</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">grid</span><span class="p">,</span> <span class="n">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">int</span> <span class="n">j</span><span class="p">){</span>
        <span class="n">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">grid</span><span class="mf">.</span><span class="nf">size</span><span class="p">(),</span> <span class="n">n</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="mf">.</span><span class="nf">size</span><span class="p">();</span>
        <span class="k">if</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">m</span> <span class="o">||</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
        <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="nf">dfs</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
        <span class="nf">dfs</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="nf">dfs</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
        <span class="nf">dfs</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h2 id="玩游戏"><span class="mr-2">玩游戏</span><a href="#玩游戏" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="51-n-皇后"><span class="mr-2">51. N 皇后</span><a href="#51-n-皇后" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。给你一个整数 n ，返回所有不同的 n 皇后问题的解决方案。每一种解法包含一个不同的 n 皇后问题的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p><div align="center"><img data-src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202206121524334.png" alt="image-20220612152411212" style="zoom:80%;" data-proofer-ignore></div><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">n</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">输出</span><span class="err">：</span><span class="p">[[</span><span class="s2">".Q.."</span><span class="p">,</span><span class="s2">"...Q"</span><span class="p">,</span><span class="s2">"Q..."</span><span class="p">,</span><span class="s2">"..Q."</span><span class="p">],[</span><span class="s2">"..Q."</span><span class="p">,</span><span class="s2">"Q..."</span><span class="p">,</span><span class="s2">"...Q"</span><span class="p">,</span><span class="s2">".Q.."</span><span class="p">]]</span>
<span class="n">解释</span><span class="err">：</span><span class="n">如上图所示</span><span class="err">，</span><span class="mi">4</span> <span class="n">皇后问题存在两个不同的解法</span><span class="err">。</span>
</pre></table></code></div></div><p>皇后的约束条件：不能同行、不能同列、不能同斜线。</p><p>搜索皇后的位置，可以抽象为一棵树：</p><div align="center"><img data-src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202206131136053.png" alt="image-20220613113646889" style="zoom:80%;" data-proofer-ignore></div><p>那么我们用皇后们的约束条件，来回溯搜索这棵树，<strong>只要搜索到了树的叶子节点，说明就找到了皇后们的合理位置了</strong>。</p><p>用<code class="language-plaintext highlighter-rouge">row</code>来记录当前遍历到棋盘的第几层，递归深度就是<code class="language-plaintext highlighter-rouge">row</code>控制棋盘的行，每一层里for循环的<code class="language-plaintext highlighter-rouge">col</code>控制棋盘的列，一行一列，确定了放置皇后的位置。每次都是要从新的一行的起始位置开始搜，所以都是从0开始。</p><p>那如何验证棋盘是否合法呢？按照皇后的约束条件。<strong>没有在同行进行检查</strong>，因为在单层搜索的过程中，每一层递归，只会选for循环（也就是同一行）里的一个元素，所以不用去重了。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&gt;</span> <span class="n">res</span><span class="p">;</span>
    <span class="cm">/* 输入棋盘边长 n，返回所有合法的放置 */</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&gt;</span> <span class="nf">solveNQueens</span><span class="p">(</span><span class="n">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// '.' 表示空，'Q' 表示皇后，初始化空棋盘。</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="nf">board</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nf">string</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="s1">'.'</span><span class="p">));</span>
        <span class="nf">backtrack</span><span class="p">(</span><span class="n">board</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="c1">// 路径：board 中小于 row 的那些行都已经成功放置了皇后</span>
    <span class="c1">// 选择列表：第 row 行的所有列都是放置皇后的选择</span>
    <span class="c1">// 结束条件：row 超过 board 的最后一行</span>
    <span class="n">void</span> <span class="nf">backtrack</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">board</span><span class="p">,</span> <span class="n">int</span> <span class="n">row</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 触发结束条件</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">row</span> <span class="o">==</span> <span class="n">board</span><span class="mf">.</span><span class="nf">size</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">res</span><span class="mf">.</span><span class="nf">push_back</span><span class="p">(</span><span class="n">board</span><span class="p">);</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">board</span><span class="p">[</span><span class="n">row</span><span class="p">]</span><span class="mf">.</span><span class="nf">size</span><span class="p">();</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">col</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">col</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 排除不合法选择</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nf">isValid</span><span class="p">(</span><span class="n">board</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">))</span> <span class="k">continue</span><span class="p">;</span>
            <span class="c1">// 做选择</span>
            <span class="n">board</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="s1">'Q'</span><span class="p">;</span>
            <span class="c1">// 进入下一行决策</span>
            <span class="nf">backtrack</span><span class="p">(</span><span class="n">board</span><span class="p">,</span> <span class="n">row</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
            <span class="c1">// 撤销选择</span>
            <span class="n">board</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="s1">'.'</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="cm">/* 是否可以在 board[row][col] 放置皇后？*/</span>
    <span class="n">bool</span> <span class="nf">isValid</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">board</span><span class="p">,</span> <span class="n">int</span> <span class="n">row</span><span class="p">,</span> <span class="n">int</span> <span class="n">col</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">board</span><span class="mf">.</span><span class="nf">size</span><span class="p">();</span>
        <span class="c1">// 检查列是否有皇后互相冲突</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">row</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="n">board</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">col</span><span class="p">]</span> <span class="o">==</span> <span class="s1">'Q'</span><span class="p">)</span> <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// 检查右上方是否有皇后互相冲突</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">row</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">col</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">,</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="n">board</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="s1">'Q'</span><span class="p">)</span> <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// 检查左上方是否有皇后互相冲突</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">row</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">col</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">,</span> <span class="n">j</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="n">board</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="s1">'Q'</span><span class="p">)</span> <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h3 id="37-解数独"><span class="mr-2">37. 解数独</span><a href="#37-解数独" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>编写一个程序，通过填充空格来解决数独问题。数独的解法需遵循如下规则：</p><ol><li><p>数字 1-9 在每一行只能出现一次。</p><li><p>数字 1-9 在每一列只能出现一次。</p><li><p>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。</p></ol><p>数独部分空格内已填入了数字，空白格用 ‘.’ 表示。</p><div align="center"><img data-src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202206141406503.png" alt="img" style="zoom:80%;" data-proofer-ignore></div><p>算法的核心思路非常非常的简单，就是对每一个空着的格子穷举 1 到 9，如果遇到不合法的数字（在同一行或同一列或同一个 3×3 的区域中存在相同的数字）则跳过，如果找到一个合法的数字，则继续穷举下一个空格子。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">void</span> <span class="nf">solveSudoku</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">char</span><span class="o">&gt;&gt;&amp;</span> <span class="n">board</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">backtrack</span><span class="p">(</span><span class="n">board</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">bool</span> <span class="nf">backtrack</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">char</span><span class="o">&gt;&gt;&amp;</span> <span class="n">board</span><span class="p">,</span> <span class="n">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">int</span> <span class="n">j</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="n">j</span> <span class="o">==</span> <span class="mi">9</span><span class="p">){</span>
            <span class="c1">// 穷举到最后一列的话就换到下一行重新开始。</span>
            <span class="k">return</span> <span class="nf">backtrack</span><span class="p">(</span><span class="n">board</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="c1">// 找到一个可行解，触发 base case</span>
        <span class="k">if</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">9</span><span class="p">)</span> <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">board</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">'.'</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 如果有预设数字，不用我们穷举</span>
            <span class="k">return</span> <span class="nf">backtrack</span><span class="p">(</span><span class="n">board</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">for</span><span class="p">(</span><span class="n">char</span> <span class="n">ch</span> <span class="o">=</span> <span class="s1">'1'</span><span class="p">;</span> <span class="n">ch</span> <span class="o">&lt;=</span> <span class="s1">'9'</span><span class="p">;</span> <span class="n">ch</span><span class="o">++</span><span class="p">){</span>
            <span class="c1">// 如果遇到不合法的数字，就跳过</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nf">isValid</span><span class="p">(</span><span class="n">board</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">ch</span><span class="p">))</span> <span class="k">continue</span><span class="p">;</span>
            <span class="n">board</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">ch</span><span class="p">;</span>
            <span class="c1">// 如果找到一个可行解，立即结束</span>
            <span class="k">if</span> <span class="p">(</span><span class="nf">backtrack</span><span class="p">(</span><span class="n">board</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
            <span class="n">board</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="s1">'.'</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// 穷举完 1~9，依然没有找到可行解，此路不通</span>
        <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 判断 board[i][j] 是否可以填入 ch</span>
    <span class="n">bool</span> <span class="nf">isValid</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">char</span><span class="o">&gt;&gt;&amp;</span> <span class="n">board</span><span class="p">,</span> <span class="n">int</span> <span class="n">row</span><span class="p">,</span> <span class="n">int</span> <span class="n">col</span><span class="p">,</span> <span class="n">char</span> <span class="n">ch</span><span class="p">){</span>
        <span class="k">for</span><span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">9</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="c1">// 判断行是否存在重复</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">board</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">ch</span><span class="p">)</span> <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
            <span class="c1">// 判断列是否存在重复</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">board</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">col</span><span class="p">]</span> <span class="o">==</span> <span class="n">ch</span><span class="p">)</span> <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
            <span class="c1">// 判断 3 x 3 方框是否存在重复</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">board</span><span class="p">[(</span><span class="n">row</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">+</span> <span class="n">i</span> <span class="o">/</span> <span class="mi">3</span><span class="p">][(</span><span class="n">col</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">+</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="n">ch</span><span class="p">){</span>
                <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h2 id="22-括号生成"><span class="mr-2">22. 括号生成</span><a href="#22-括号生成" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre> <span class="n">输入</span><span class="err">：</span><span class="n">n</span> <span class="o">=</span> <span class="mi">3</span>
 <span class="n">输出</span><span class="err">：</span><span class="p">[</span><span class="s2">"((()))"</span><span class="p">,</span><span class="s2">"(()())"</span><span class="p">,</span><span class="s2">"(())()"</span><span class="p">,</span><span class="s2">"()(())"</span><span class="p">,</span><span class="s2">"()()()"</span><span class="p">]</span>
</pre></table></code></div></div><p>一个「合法」括号组合的左括号数量一定等于右括号数量，并且对于一个「合法」的括号字符串组合 p，必然对于任何 0 &lt;= i &lt; len(p) 都有：子串 p[0..i] 中左括号的数量都大于或等于右括号的数量。</p><blockquote><p>比如这个括号组合 <code class="language-plaintext highlighter-rouge">))((</code>，前几个子串都是右括号多于左括号，显然不是合法的括号组合。</p></blockquote><p>题目相当于有 2n 个位置，每个位置可以放置字符 ( 或者 )，组成的所有括号组合中，有多少个是合法的？</p><p>用 <code class="language-plaintext highlighter-rouge">left </code>记录还可以使用多少个左括号，用 <code class="language-plaintext highlighter-rouge">right </code>记录还可以使用多少个右括号，就可以直接套用回溯算法套路框架了。</p><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">;</span> <span class="c1">// 记录所有合法的括号组合</span>
    <span class="n">string</span> <span class="n">track</span><span class="p">;</span>       <span class="c1">// 回溯过程中的路径</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="nf">generateParenthesis</span><span class="p">(</span><span class="n">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">backtrack</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span> <span class="c1">// 可用的左括号和右括号数量初始化为 n</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 可用的左括号数量为 left 个，可用的右括号数量为 riht 个</span>
    <span class="n">void</span> <span class="nf">backtrack</span><span class="p">(</span><span class="n">int</span> <span class="n">left</span><span class="p">,</span> <span class="n">int</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 若左括号剩下的多，说明不合法</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">right</span> <span class="o">&lt;</span> <span class="n">left</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
        <span class="c1">// 数量小于 0 肯定是不合法的</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
        <span class="c1">// 当所有括号都恰好用完时，得到一个合法的括号组合</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">right</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">res</span><span class="mf">.</span><span class="nf">push_back</span><span class="p">(</span><span class="n">track</span><span class="p">);</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// 尝试放一个左括号</span>
        <span class="n">track</span><span class="mf">.</span><span class="nf">push_back</span><span class="p">(</span><span class="s1">'('</span><span class="p">);</span> <span class="c1">// 选择</span>
        <span class="nf">backtrack</span><span class="p">(</span><span class="n">left</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">right</span><span class="p">);</span>
        <span class="n">track</span><span class="mf">.</span><span class="nf">pop_back</span><span class="p">();</span> <span class="c1">// 撤消选择</span>
        <span class="c1">// 尝试放一个右括号</span>
        <span class="n">track</span><span class="mf">.</span><span class="nf">push_back</span><span class="p">(</span><span class="s1">')'</span><span class="p">);</span> <span class="c1">// 选择</span>
        <span class="nf">backtrack</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">track</span><span class="mf">.</span><span class="nf">pop_back</span><span class="p">();</span> <span class="c1">// 撤消选择</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h2 id="17-电话号码的字母组合"><span class="mr-2">17. 电话号码的字母组合</span><a href="#17-电话号码的字母组合" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合，答案可以按任意顺序返回。给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><div align="center"><img data-src="https://fastly.jsdelivr.net/gh/CARLOSGP2021/myFigures/img/202206141452844.png" alt="img" style="zoom:150%;" data-proofer-ignore></div><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">输入</span><span class="err">：</span><span class="n">digits</span> <span class="o">=</span> <span class="s2">"23"</span>
<span class="n">输出</span><span class="err">：</span><span class="p">[</span><span class="s2">"ad"</span><span class="p">,</span><span class="s2">"ae"</span><span class="p">,</span><span class="s2">"af"</span><span class="p">,</span><span class="s2">"bd"</span><span class="p">,</span><span class="s2">"be"</span><span class="p">,</span><span class="s2">"bf"</span><span class="p">,</span><span class="s2">"cd"</span><span class="p">,</span><span class="s2">"ce"</span><span class="p">,</span><span class="s2">"cf"</span><span class="p">]</span>
</pre></table></code></div></div><div class="language-php highlighter-rouge"><div class="code-header"> <span data-label-text="PHP"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
    <span class="k">const</span> <span class="no">string</span> <span class="no">letterMap</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">""</span><span class="p">,</span>     <span class="c1">// 0</span>
        <span class="s2">""</span><span class="p">,</span>     <span class="c1">// 1</span>
        <span class="s2">"abc"</span><span class="p">,</span>  <span class="c1">// 2</span>
        <span class="s2">"def"</span><span class="p">,</span>  <span class="c1">// 3</span>
        <span class="s2">"ghi"</span><span class="p">,</span>  <span class="c1">// 4</span>
        <span class="s2">"jkl"</span><span class="p">,</span>  <span class="c1">// 5</span>
        <span class="s2">"mno"</span><span class="p">,</span>  <span class="c1">// 6</span>
        <span class="s2">"pqrs"</span><span class="p">,</span> <span class="c1">// 7</span>
        <span class="s2">"tuv"</span><span class="p">,</span>  <span class="c1">// 8</span>
        <span class="s2">"wxyz"</span><span class="p">,</span> <span class="c1">// 9</span>
    <span class="p">};</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">result</span><span class="p">;</span>
    <span class="n">string</span> <span class="n">s</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="nf">letterCombinations</span><span class="p">(</span><span class="n">string</span> <span class="n">digits</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">digits</span><span class="mf">.</span><span class="nb">empty</span><span class="p">())</span> <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
        <span class="nf">backtracking</span><span class="p">(</span><span class="n">digits</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">void</span> <span class="nf">backtracking</span><span class="p">(</span><span class="k">const</span> <span class="no">string</span><span class="o">&amp;</span> <span class="n">digits</span><span class="p">,</span> <span class="n">int</span> <span class="n">index</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">==</span> <span class="n">digits</span><span class="mf">.</span><span class="nf">size</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">result</span><span class="mf">.</span><span class="nf">push_back</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">int</span> <span class="n">digit</span> <span class="o">=</span> <span class="n">digits</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">-</span> <span class="s1">'0'</span><span class="p">;</span>        <span class="c1">// 将index指向的数字转为int</span>
        <span class="n">string</span> <span class="n">letters</span> <span class="o">=</span> <span class="n">letterMap</span><span class="p">[</span><span class="n">digit</span><span class="p">];</span>      <span class="c1">// 取数字对应的字符集</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">letters</span><span class="mf">.</span><span class="nf">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">s</span><span class="mf">.</span><span class="nf">push_back</span><span class="p">(</span><span class="n">letters</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>            <span class="c1">// 处理</span>
            <span class="nf">backtracking</span><span class="p">(</span><span class="n">digits</span><span class="p">,</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>    <span class="c1">// 递归，注意index + 1，下一层要处理下一个数字了</span>
            <span class="n">s</span><span class="mf">.</span><span class="nf">pop_back</span><span class="p">();</span>                       <span class="c1">// 回溯</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><p>注意：<code class="language-plaintext highlighter-rouge">index</code>用来记录遍历第几个数字，就是用来遍历digits的。</p><h1 id="参考资料">参考资料</h1><p><a href="https://labuladong.github.io/algo/">labuladong 的算法小抄 :: labuladong的算法小抄</a></p><p><a href="https://programmercarl.com/">代码随想录 (programmercarl.com)</a></p><p><a href="https://leetcode-cn.com/problemset/all/">题库 - 力扣 (LeetCode) 全球极客挚爱的技术成长平台 (leetcode-cn.com)</a></p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/'>算法刷题</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/%E7%AE%97%E6%B3%95/" class="post-tag no-text-decoration" >算法</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 本文由作者按照 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 进行授权</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">分享</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=%E5%9B%9B%E3%80%81%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95+-+%E5%8D%A1%E5%8D%A1%E6%88%90%E9%95%BF%E6%B1%87%E8%81%9A%E9%98%BF%E8%B1%B9&url=%2Fposts%2F%25E5%259B%259B-%25E5%259B%259E%25E6%25BA%25AF%25E7%25AE%2597%25E6%25B3%2595%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=%E5%9B%9B%E3%80%81%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95+-+%E5%8D%A1%E5%8D%A1%E6%88%90%E9%95%BF%E6%B1%87%E8%81%9A%E9%98%BF%E8%B1%B9&u=%2Fposts%2F%25E5%259B%259B-%25E5%259B%259E%25E6%25BA%25AF%25E7%25AE%2597%25E6%25B3%2595%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=%2Fposts%2F%25E5%259B%259B-%25E5%259B%259E%25E6%25BA%25AF%25E7%25AE%2597%25E6%25B3%2595%2F&text=%E5%9B%9B%E3%80%81%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95+-+%E5%8D%A1%E5%8D%A1%E6%88%90%E9%95%BF%E6%B1%87%E8%81%9A%E9%98%BF%E8%B1%B9" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="分享链接" data-title-succeed="链接已复制！"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">最近更新</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/%E5%85%B3%E6%B3%A8/">关注</a><li><a href="/posts/%E4%B8%83-%E8%A1%A5%E5%85%85/">七、补充</a><li><a href="/posts/%E5%85%AD-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/">六、贪心算法</a><li><a href="/posts/%E4%BA%94-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">五、动态规划</a><li><a href="/posts/%E5%9B%9B-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/">四、回溯算法</a></ul></div><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/%E7%AE%97%E6%B3%95/">算法</a> <a class="post-tag" href="/tags/%E8%B5%84%E6%BA%90/">资源</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">文章内容</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>相关文章</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/%E4%B8%83-%E8%A1%A5%E5%85%85/"><div class="card-body"> <em class="small" data-ts="1655865240" data-df="YYYY-MM-DD" > 2022-06-22 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>七、补充</h3><div class="text-muted small"><p> 7. 整数反转 给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。如果反转后整数超过 32 位的有符号整数的范围 [−231, 231 − 1] ，就返回 0。假设环境不允许存储 64 位整数（有符号或无符号）。 输入：x = 123 输出：321 class Solution { public: int reverse(int x) { ...</p></div></div></a></div><div class="card"> <a href="/posts/%E5%85%AD-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"><div class="card-body"> <em class="small" data-ts="1655951640" data-df="YYYY-MM-DD" > 2022-06-23 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>六、贪心算法</h3><div class="text-muted small"><p> 435. 无重叠区间 给定一个区间的集合 intervals ，其中 intervals[i] = [starti, endi] ，返回需要移除区间的最小数量，使剩余区间互不重叠 。 输入: intervals = [[1,2],[2,3],[3,4],[1,3]] 输出: 1 解释: 移除 [1,3] 后，剩下的区间没有重叠。 右边界排序，从左向右记录非交叉区间的个数，最后用区间总...</p></div></div></a></div><div class="card"> <a href="/posts/%E4%BA%94-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"><div class="card-body"> <em class="small" data-ts="1656124440" data-df="YYYY-MM-DD" > 2022-06-25 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>五、动态规划</h3><div class="text-muted small"><p> 动态规划是什么？解决动态规划问题有什么技巧？如何学习动态规划？ 首先，动态规划问题的一般形式就是求最值。动态规划其实是运筹学的一种最优化方法，只不过在计算机问题上应用比较多，比如说让你求最长递增子序列呀，最小编辑距离呀等等。 既然是要求最值，核心问题是什么呢？求解动态规划的核心问题是穷举。因为要求最值，肯定要把所有可行的答案穷举出来，然后在其中找最值呗。 首先，虽然动态规划的核心思想就...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/%E4%BA%94-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" class="btn btn-outline-primary" prompt="上一篇"><p>五、动态规划</p></a> <a href="/posts/%E4%B8%89-%E6%95%B0%E7%BB%84/" class="btn btn-outline-primary" prompt="下一篇"><p>三、数组</p></a></div></div></div><footer class="row pl-3 pr-3"><div class="col-12 d-flex justify-content-between align-items-center text-muted pl-0 pr-0"><div class="footer-left"><p class="mb-0"> © 2022 <a href="https://twitter.com/username">CARLOSGP2021</a>. <span data-toggle="tooltip" data-placement="top" title="除非另有说明，本网站上的博客文章均由作者按照知识共享署名 4.0 国际 (CC BY 4.0) 许可协议进行授权。">保留部分权利。</span></p></div><div class="footer-right"><p class="mb-0"> 本站由 <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> 生成，采用 <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> 主题。</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/%E7%AE%97%E6%B3%95/">算法</a> <a class="post-tag" href="/tags/%E8%B5%84%E6%BA%90/">资源</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><script src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js"></script> <script> $(function() { function updateMermaid(event) { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { const mode = event.data.message; if (typeof mermaid === "undefined") { return; } let expectedTheme = (mode === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* Re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } let initTheme = "default"; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches ) ) { initTheme = "dark"; } let mermaidConf = { theme: initTheme /* <default|dark|forest|neutral> */ }; /* Markdown converts to HTML */ $("pre").has("code.language-mermaid").each(function() { let svgCode = $(this).children().html(); $(this).addClass("unloaded"); $(this).after(`<div class=\"mermaid\">${svgCode}</div>`); }); mermaid.initialize(mermaidConf); window.addEventListener("message", updateMermaid); }); </script><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a><div id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-animation="true" data-autohide="false"><div class="toast-header"> <button type="button" class="ml-2 ml-auto close" data-dismiss="toast" aria-label="Close"> <span aria-hidden="true">&times;</span> </button></div><div class="toast-body text-center pt-0"><p class="pl-2 pr-2 mb-3"></p><button type="button" class="btn btn-primary" aria-label="Update"> </button></div></div><script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">搜索结果为空</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/asia/shanghai.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script>
